{"id": "VA0000", "language": "verus", "source": "apps", "source_id": "apps_test_1", "vc-description": "Given a positive integer x, find the positive integer not exceeding x that has the maximum sum of digits. \nIf multiple such integers exist, return the largest one.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn int_to_digits(x: int) -> Seq<int>\n  recommends x >= 0\n{\n  if x == 0 { seq![0] }\n  else { int_to_digits_helper(x) }\n}\n\nspec fn int_to_digits_helper(x: int) -> Seq<int>\n  recommends x > 0\n  decreases x\n{\n  if x < 10 { seq![x] }\n  else { int_to_digits_helper(x / 10).add(seq![x % 10]) }\n}\n\nspec fn digit_sum(digits: Seq<int>) -> int\n  decreases digits.len()\n{\n  if digits.len() == 0 { 0 }\n  else { digits[0] + digit_sum(digits.subrange(1, digits.len() as int)) }\n}\n\nspec fn valid_input(x: int) -> bool\n{\n  x >= 1\n}\n\nspec fn valid_result(x: int, result: int) -> bool\n  recommends valid_input(x)\n{\n  result > 0 &&\n  result <= x &&\n  (forall|y: int| 1 <= y <= x ==> digit_sum(int_to_digits(y)) <= digit_sum(int_to_digits(result))) &&\n  (forall|y: int| 1 <= y <= x && digit_sum(int_to_digits(y)) == digit_sum(int_to_digits(result)) ==> y <= result)\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8) -> (result: i8)\n  requires valid_input(x as int)\n  ensures valid_result(x as int, result as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0002", "language": "verus", "source": "apps", "source_id": "apps_test_10", "vc-description": "Given a Martian year with n days and Earth-like weeks (5 work days + 2 days off),\ndetermine the minimum and maximum possible number of days off in that year.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn min_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let min_additional = if remaining_days > 5 { remaining_days - 5 } else { 0 };\n  2 * complete_weeks + min_additional\n}\n\nspec fn max_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let max_additional = if remaining_days < 2 { remaining_days } else { 2 };\n  2 * complete_weeks + max_additional\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n  result.len() == 2 &&\n  result[0] >= 0 && result[1] >= 0 &&\n  result[0] <= result[1] &&\n  result[0] <= n && result[1] <= n &&\n  result[0] == min_days_off(n) &&\n  result[1] == max_days_off(n)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)", "vc-code": "{\n  assume(false);\n  Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0003", "language": "verus", "source": "apps", "source_id": "apps_test_11", "vc-description": "Given n tiles numbered 1 to n, paint tiles according to rules:\n- Tile can be painted Red if divisible by a (gives p chocolates)\n- Tile can be painted Blue if divisible by b (gives q chocolates)  \n- If divisible by both a and b, choose the color giving more chocolates\nFind the maximum total chocolates possible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: int, b: int, p: int, q: int) -> bool {\n  n > 0 && a > 0 && b > 0 && p > 0 && q > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a > 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8, p: i8, q: i8) -> (result: i8)\n  requires valid_input(n as int, a as int, b as int, p as int, q as int)\n  ensures result >= 0", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0004", "language": "verus", "source": "apps", "source_id": "apps_test_22", "vc-description": "Check if a string is an \"s-palindrome\" - meaning it is symmetric when mirrored horizontally about its center.\nSome letters are symmetric: A, H, I, M, O, o, T, U, V, v, W, w, X, x, Y\nSome letters are mirror pairs: (p,q) and (b,d)\nAll other letters cannot form valid s-palindromes", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_s_palindrome(s: Seq<char>) -> bool {\n    let pal = seq!['A', 'H', 'I', 'M', 'O', 'o', 'T', 'U', 'V', 'v', 'W', 'w', 'X', 'x', 'Y'];\n    \n    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> {\n        let j = s.len() - 1 - i;\n        if i >= j {\n            true\n        } else {\n            if s[i] == s[j] {\n                pal.contains(s[i])\n            } else {\n                (s[i] == 'p' && s[j] == 'q') || (s[i] == 'q' && s[j] == 'p') ||\n                (s[i] == 'b' && s[j] == 'd') || (s[i] == 'd' && s[j] == 'b')\n            }\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: &str) -> (result: String)\n    requires\n        s@.len() >= 1,\n    ensures\n        result@ == seq!['T', 'A', 'K'] || result@ == seq!['N', 'I', 'E'],\n        (result@ == seq!['T', 'A', 'K']) <==> is_s_palindrome(s@),", "vc-code": "{\n    assume(false);\n    \"NIE\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0005", "language": "verus", "source": "apps", "source_id": "apps_test_27", "vc-description": "Given a string s of n lowercase Latin letters, find the minimum number of operations\nto construct it starting from an empty string. Operations are: (1) add one character\nto the end (unlimited use), (2) copy current string and append it to itself (at most once).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, s: Seq<char>) -> bool {\n    s.len() == n\n}\n\nspec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {\n    max_copy_savings_up_to(s, n, n / 2)\n}\n\nspec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat\n    decreases limit\n{\n    if limit == 0 { 0 }\n    else {\n        let i = (limit - 1) as nat;\n        let current = if can_copy_at(s, n, i) { i } else { 0 };\n        let prev = max_copy_savings_up_to(s, n, i);\n        if current > prev { current } else { prev }\n    }\n}\n\nspec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {\n    let prefix_len = i + 1;\n    let end_pos = i + 1 + prefix_len;\n    end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i+1) as int, end_pos as int)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8, s: Vec<char>) -> (result: u8)\n    requires \n        valid_input(n as nat, s@)\n    ensures \n        result as nat <= n as nat,\n        n == 0 ==> result == 0,\n        n > 0 ==> result >= 1,\n        result as nat == n as nat - max_copy_savings(s@, n as nat)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0007", "language": "verus", "source": "apps", "source_id": "apps_test_45", "vc-description": "Given positive integers n and k, find a strictly increasing sequence of k positive integers \nthat sum to n and have the maximum possible greatest common divisor (GCD). \nIf no such sequence exists, return -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n > 0 && k > 0\n}\n\nspec fn is_strictly_increasing(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i+1]\n}\n\nspec fn all_positive(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] > 0\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool\n{\n    s.len() == k && all_positive(s) && is_strictly_increasing(s) && sum_seq(s) == n\n}\n\nspec fn is_possible(n: int, k: int) -> bool\n{\n    k * (k + 1) / 2 <= n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        ((result.len() == 1 && result[0] == -1) || \n         (valid_sequence(result@.map(|_i: int, x: i8| x as int), n as int, k as int))) &&\n        ((result.len() == 1 && result[0] == -1) <==> !is_possible(n as int, k as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0008", "language": "verus", "source": "apps", "source_id": "apps_test_48", "vc-description": "Given an n × m multiplication table where element at row i and column j equals i·j (1-indexed),\nfind the k-th smallest number among all n·m elements in the table.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_less_value(n: int, m: int, target: int) -> int\n  decreases n\n{\n  if n <= 0 {\n    0\n  } else {\n    let max_j = (target - 1) / n;\n    let actual_max_j = if max_j > m { m } else { max_j };\n    let contribution = if actual_max_j >= 1 { actual_max_j } else { 0 };\n    contribution + count_less_value(n - 1, m, target)\n  }\n}\n\nspec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {\n  if target <= 0 {\n    0\n  } else if target >= n * m {\n    n * m\n  } else {\n    count_less_value(n, m, target + 1)\n  }\n}\n\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, k: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int)\n  ensures \n    1 <= result as int <= (n as int) * (m as int),\n    count_less_or_equal_value(n as int, m as int, result as int) >= k as int,\n    result as int == 1 || count_less_or_equal_value(n as int, m as int, (result as int) - 1) < k as int", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0009", "language": "verus", "source": "apps", "source_id": "apps_test_50", "vc-description": "You start with r bourles and no shares. There are n buying opportunities and m selling opportunities for shares. \nFind the maximum bourles you can have after trading. You can buy any number of shares at any buying price \nand sell any number of shares (up to what you own) at any selling price.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n' as char)\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, int, int, Seq<int>, Seq<int>)\n    recommends valid_input(input)\n{\n    (1, 1, 1, Seq::<int>::empty(), Seq::<int>::empty())\n}\n\nspec fn compute_max_bourles(r: int, s: Seq<int>, b: Seq<int>) -> int\n    recommends r >= 1 && s.len() >= 1 && b.len() >= 1 &&\n               (forall|i: int| 0 <= i < s.len() ==> s[i] >= 1) &&\n               (forall|i: int| 0 <= i < b.len() ==> b[i] >= 1)\n{\n    r\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<u8>) -> (result: Vec<u8>)\n    requires input.len() > 0 && input@.contains('\\n' as u8) && valid_input(input@.map(|i: int, x: u8| x as char))\n    ensures result.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0010", "language": "verus", "source": "apps", "source_id": "apps_test_56", "vc-description": "Simulate pouring champagne into a pyramid of glasses for t seconds.\nThe pyramid has n levels where level i has i glasses (1-indexed).\nEach second, 1 unit is poured into the top glass. Each glass has capacity 1.\nWhen a glass overflows, excess champagne splits equally to the two glasses below.\nCount the number of completely full glasses after t seconds.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, t: int) -> bool {\n    1 <= n <= 10 && 0 <= t <= 10000\n}\n\nspec fn total_glasses(n: int) -> int {\n    n * (n + 1) / 2\n}\n\nspec fn valid_result(result: int, n: int, t: int) -> bool {\n    result >= 0 && result <= total_glasses(n)\n}\n\nspec fn correct_for_edge_cases(result: int, n: int, t: int) -> bool {\n    (t == 0 ==> result == 0) &&\n    (n == 1 && t >= 1 ==> result == 1) &&\n    (n == 1 && t == 0 ==> result == 0) &&\n    (t >= 1 && n > 1 ==> result >= 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, t: i8) -> (result: i8)\nrequires \n    valid_input(n as int, t as int)\nensures \n    valid_result(result as int, n as int, t as int),\n    correct_for_edge_cases(result as int, n as int, t as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0011", "language": "verus", "source": "apps", "source_id": "apps_test_59", "vc-description": "Given an array of n integers where each integer from 1 to n appears exactly once,\ndetermine if the array can be sorted in ascending order using only allowed adjacent swaps.\nYou can swap elements at positions i and i+1 only if the i-th character in a given\nbinary string is '1'. You can perform any number of such swaps in any order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {\n    n >= 2 &&\n    a.len() == n &&\n    p.len() == n - 1 &&\n    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] == '0' || #[trigger] p[i] == '1') &&\n    (forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= n) &&\n    a.to_set() =~= Set::new(|i: int| 1 <= i <= n)\n}\n\nspec fn max_up_to(a: Seq<int>, i: int) -> int\n    recommends 0 <= i < a.len()\n    decreases i when i >= 0\n{\n    if i == 0 { \n        a[0] \n    } else if i > 0 && a[i] > max_up_to(a, i-1) { \n        a[i] \n    } else if i > 0 { \n        max_up_to(a, i-1) \n    } else {\n        a[0]\n    }\n}\n\nspec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool\n    recommends valid_input(n, a, p)\n{\n    forall|i: int| 0 <= i < n - 1 ==> \n        (#[trigger] p[i] == '0' ==> max_up_to(a, i) <= i + 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>, p: Vec<char>) -> (result: String)\n    requires\n        valid_input(n as int, a@.map(|i, x| x as int), p@),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> can_sort(n as int, a@.map(|i, x| x as int), p@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0012", "language": "verus", "source": "apps", "source_id": "apps_test_62", "vc-description": "Two players play a game on a sequence of n non-negative integers. Each player can either\nreduce a single element by some value or globally reduce all elements by the minimum value.\nThe player who cannot make a move (all elements are 0) loses. Determine the winner assuming\nboth players play optimally.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    (stdin_input[stdin_input.len() as int - 1] == '\\n' || \n     !exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n')\n}\n\nspec fn valid_result(result: Seq<char>) -> bool {\n    result == seq!['B','i','t','A','r','y','o'] || result == seq!['B','i','t','L','G','M']\n}\n\nspec fn game_result(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    seq!['B','i','t','L','G','M']\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_result(result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0013", "language": "verus", "source": "apps", "source_id": "apps_test_65", "vc-description": "Given an array of integers, find the minimum distance between any two occurrences \nof the minimum value in the array. The minimum value is guaranteed to appear at least twice.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn seq_min(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n    arr.len() >= 2 && \n    exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr[i] == #[trigger] arr[j] && arr[i] == seq_min(arr)\n}", "vc-helpers": "spec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {\n    arr@.map(|i, v| v as int)\n}", "vc-spec": "fn solve(arr: Vec<i8>) -> (result: u8)\n    requires \n        valid_input(arr_to_seq(arr)),\n    ensures \n        result > 0,\n        result as int <= arr.len() - 1,\n        exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) && j - i == result as int,\n        forall|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) ==> j - i >= result as int,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0014", "language": "verus", "source": "apps", "source_id": "apps_test_66", "vc-description": "Two athletes Willman and Bolt compete in a race with step lengths w and b meters respectively.\nThe race distance L is chosen uniformly at random from integers 1 to t (inclusive).\nEach athlete can take at most floor(L/step_length) steps, traveling floor(L/step_length) * step_length distance.\nThey tie when they travel the same total distance: floor(L/w) * w = floor(L/b) * b.\nFind the probability that they tie, expressed as an irreducible fraction.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn gcd(a: int, b: int) -> int \n    decreases (if b == 0 { 0 } else { abs(b) })\n{\n    if b == 0 { abs(a) } else { gcd(b, a % b) }\n}\n\nspec fn valid_input(t: int, w: int, b: int) -> bool {\n    t > 0 && w > 0 && b > 0\n}\n\nspec fn valid_fraction(numerator: int, denominator: int) -> bool {\n    numerator >= 0 && denominator > 0 && numerator <= denominator\n}\n\nspec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool\n    recommends valid_fraction(numerator, denominator)\n{\n    gcd(numerator, denominator) == 1\n}", "vc-helpers": "", "vc-spec": "fn solve(t: u64, w: u64, b: u64) -> (result: (u64, u64))\n    requires\n        t > 0 && w > 0 && b > 0,\n    ensures\n        result.1 > 0,\n        result.0 <= result.1", "vc-code": "{\n    assume(false);\n    (0, 1)\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0016", "language": "verus", "source": "apps", "source_id": "apps_test_73", "vc-description": "Calculate the minimum number of days needed to finish reading a book with c pages.\nDay 1: Read min(v_1, v_0) pages. Day n (n >= 2): Go back l pages, then read min(v_1, v_0 + (n-1) * a) pages total.\nThe book is finished when the last page is read for the first time.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn compute_position(days: int, v0: int, v1: int, a: int, l: int) -> int\n    decreases days\n{\n    if days <= 0 {\n        0\n    } else {\n        let prev_pos = compute_position(days - 1, v0, v1, a, l);\n        let after_reread = if prev_pos - l > 0 { prev_pos - l } else { 0 };\n        let read_today = if v1 < v0 + a * (days - 1) { v1 } else { v0 + a * (days - 1) };\n        after_reread + read_today\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(c: u8, v0: u8, v1: u8, a: u8, l: u8) -> (result: u8)\n    requires\n        1 <= c && c <= 100,\n        0 <= l && l < v0 && v0 <= v1 && v1 <= 100,\n        0 <= a && a <= 100\n    ensures\n        result >= 1,\n        compute_position(result as int, v0 as int, v1 as int, a as int, l as int) >= c as int,\n        forall|days: int| 1 <= days && days < result as int ==> compute_position(days, v0 as int, v1 as int, a as int, l as int) < c as int", "vc-code": "{\n    assume(false);\n    1\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0017", "language": "verus", "source": "apps", "source_id": "apps_test_76", "vc-description": "Given n commentary boxes and m delegations, make the number of boxes divisible by m at minimum cost.\nYou can build a box for cost a or demolish a box for cost b.\nFind the minimum cost to make n divisible by m.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: int, b: int) -> bool {\n    n >= 1 && m >= 1 && a >= 1 && b >= 1\n}\n\nspec fn min_cost_to_divisible(n: int, m: int, a: int, b: int) -> int {\n    let k = n % m;\n    if k * b < (m - k) * a { k * b } else { (m - k) * a }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a as int, b as int)\n    ensures \n        result as int == min_cost_to_divisible(n as int, m as int, a as int, b as int),\n        result as int >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0018", "language": "verus", "source": "apps", "source_id": "apps_test_87", "vc-description": "Given a month number and the weekday of its first day, determine how many columns \nare needed for a calendar table where each column represents one week (Monday through Sunday).\nThe calendar places dates sequentially and a new column is needed when transitioning \nfrom Sunday to Monday.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(m: int, d: int) -> bool {\n    1 <= m <= 12 && 1 <= d <= 7\n}\n\nspec fn days_in_month(m: int) -> int {\n    if 1 <= m <= 12 {\n        seq![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][m-1]\n    } else {\n        0\n    }\n}\n\nspec fn columns_needed(m: int, d: int) -> int {\n    if valid_input(m, d) {\n        1 + (d - 1 + days_in_month(m) - 1) / 7\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(m: i8, d: i8) -> (result: i8)\n    requires valid_input(m as int, d as int)\n    ensures result as int == columns_needed(m as int, d as int) && 4 <= result as int <= 6", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0022", "language": "verus", "source": "apps", "source_id": "apps_test_102", "vc-description": "Convert an integer score (0 ≤ s ≤ 99) to its English word representation \nusing only lowercase letters and hyphens. Numbers 0-19 have unique forms,\nnumbers 20-99 combine tens words with units using hyphens, multiples of 10\nfrom 20-90 stand alone.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    is_valid_integer_string(s) && \n    { let n = parse_integer(s); 0 <= n <= 99 }\n}\n\nspec fn correct_english_word(n: int) -> Seq<char> {\n    if n == 0 { seq!['z', 'e', 'r', 'o'] }\n    else if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else if n == 10 { seq!['t', 'e', 'n'] }\n    else if n == 11 { seq!['e', 'l', 'e', 'v', 'e', 'n'] }\n    else if n == 12 { seq!['t', 'w', 'e', 'l', 'v', 'e'] }\n    else if n == 13 { seq!['t', 'h', 'i', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 14 { seq!['f', 'o', 'u', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 15 { seq!['f', 'i', 'f', 't', 'e', 'e', 'n'] }\n    else if n == 16 { seq!['s', 'i', 'x', 't', 'e', 'e', 'n'] }\n    else if n == 17 { seq!['s', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n'] }\n    else if n == 18 { seq!['e', 'i', 'g', 'h', 't', 'e', 'e', 'n'] }\n    else if n == 19 { seq!['n', 'i', 'n', 'e', 't', 'e', 'e', 'n'] }\n    else if n == 20 { seq!['t', 'w', 'e', 'n', 't', 'y'] }\n    else if n == 30 { seq!['t', 'h', 'i', 'r', 't', 'y'] }\n    else if n == 40 { seq!['f', 'o', 'r', 't', 'y'] }\n    else if n == 50 { seq!['f', 'i', 'f', 't', 'y'] }\n    else if n == 60 { seq!['s', 'i', 'x', 't', 'y'] }\n    else if n == 70 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y'] }\n    else if n == 80 { seq!['e', 'i', 'g', 'h', 't', 'y'] }\n    else if n == 90 { seq!['n', 'i', 'n', 'e', 't', 'y'] }\n    else if 21 <= n <= 29 { seq!['t', 'w', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 31 <= n <= 39 { seq!['t', 'h', 'i', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 41 <= n <= 49 { seq!['f', 'o', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 51 <= n <= 59 { seq!['f', 'i', 'f', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 61 <= n <= 69 { seq!['s', 'i', 'x', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 71 <= n <= 79 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 81 <= n <= 89 { seq!['e', 'i', 'g', 'h', 't', 'y', '-'] + unit_word(n % 10) }\n    else { seq!['n', 'i', 'n', 'e', 't', 'y', '-'] + unit_word(n % 10) }\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    (s.len() >= 1 && s.len() <= 3 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9') ||\n    (s.len() >= 2 && s.len() <= 4 && s[s.len() - 1] == '\\n' && forall|i: int| 0 <= i < s.len() - 1 ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    if s[s.len() - 1] == '\\n' {\n        parse_integer_helper(s.subrange(0, s.len() - 1))\n    } else {\n        parse_integer_helper(s)\n    }\n}\n\nspec fn parse_integer_helper(s: Seq<char>) -> int {\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() == 2 {\n        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))\n    } else {\n        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))\n    }\n}\n\nspec fn unit_word(n: int) -> Seq<char> {\n    if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else { seq![] }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let n = parse_integer(stdin_input@);\n            result@ == correct_english_word(n) + seq!['\\n']\n        }),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0023", "language": "verus", "source": "apps", "source_id": "apps_test_106", "vc-description": "Given a circular building with n entrances, m floors per entrance, and k apartments per floor,\nfind the minimum time to travel from apartment a to apartment b. Apartments are numbered 1 to n·m·k\nsequentially. Travel costs: stairs 5s/floor, adjacent entrances 15s, elevator 10s wait + 1s/floor,\nsame floor 0s. Can walk around building in either direction.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {\n  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b\n}\n\nspec fn get_entrance(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  (apt - 1) / (m * k)\n}\n\nspec fn get_floor(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  ((apt - 1) - get_entrance(apt, m, k) * m * k) / k\n}\n\nspec fn min_travel_time(floors: int) -> int\n  recommends floors >= 0\n{\n  let stair_time = 5 * floors;\n  let elevator_time = 10 + floors;\n  if stair_time < elevator_time { stair_time } else { elevator_time }\n}\n\nspec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int\n  recommends n > 0\n{\n  let clockwise = (entrance_b - entrance_a + n) % n;\n  let counterclockwise = (entrance_a - entrance_b + n) % n;\n  if clockwise <= counterclockwise { clockwise } else { counterclockwise }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, k: i8, a: i8, b: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int, a as int, b as int)\n  ensures result as int >= 0", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0024", "language": "verus", "source": "apps", "source_id": "apps_test_113", "vc-description": "Find the minimum positive integer x such that x is divisible by n and x ends with k or more zeros in base 10.\nA number ends with k zeros if and only if it's divisible by 10^k = 2^k × 5^k.\nAlgorithm: Factor out powers of 2 and 5 from n, then multiply n by additional factors needed to achieve k trailing zeros.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 }\n    else { base * power(base, exp - 1) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        n > 0 && k >= 0,\n    ensures \n        result > 0,\n        (result as int) % (n as int) == 0,\n        (result as int) % power(10, k as int) == 0,\n        forall|m: int| #[trigger] (m % (n as int)) == 0 && #[trigger] (m % power(10, k as int)) == 0 && m > 0 ==> (result as int) <= m,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0026", "language": "verus", "source": "apps", "source_id": "apps_test_116", "vc-description": "Given two time intervals [l1, r1] and [l2, r2], and a specific minute k,\nfind the number of minutes in the intersection of these intervals,\nexcluding minute k if it falls within the intersection.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    l1 <= r1 && l2 <= r2\n}\n\nspec fn intersection_left(l1: int, l2: int) -> int {\n    if l1 > l2 { l1 } else { l2 }\n}\n\nspec fn intersection_right(r1: int, r2: int) -> int {\n    if r1 < r2 { r1 } else { r2 }\n}\n\nspec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    if right - left + 1 > 0 { right - left + 1 } else { 0 }\n}\n\nspec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    left <= k <= right\n}\n\nspec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {\n    let intersection_size_val = intersection_size(l1, r1, l2, r2);\n    if k_in_intersection(l1, r1, l2, r2, k) {\n        if intersection_size_val - 1 > 0 { intersection_size_val - 1 } else { 0 }\n    } else {\n        intersection_size_val\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(l1: i8, r1: i8, l2: i8, r2: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(l1 as int, r1 as int, l2 as int, r2 as int, k as int)\n    ensures \n        result as int == expected_result(l1 as int, r1 as int, l2 as int, r2 as int, k as int),\n        result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0027", "language": "verus", "source": "apps", "source_id": "apps_test_125", "vc-description": "Given a 4-way intersection with 4 road parts arranged counter-clockwise, determine if a traffic accident\nbetween cars and pedestrians is possible. Each road part has 4 traffic lights: left turn (l), straight (s),\nright turn (r), and pedestrian crossing (p). Each light can be red (0) or green (1). An accident is possible\nif a pedestrian crossing light is green and a car light is green that allows cars to reach that crossing.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_newlines(s: Seq<char>, idx: int) -> int\n    decreases s.len() - idx\n{\n    if idx >= s.len() {\n        0\n    } else if s[idx] == '\\n' {\n        1 + count_newlines(s, idx + 1)\n    } else {\n        count_newlines(s, idx + 1)\n    }\n}\n\nspec fn valid_input_string(s: Seq<char>) -> bool {\n    s.len() >= 7 &&\n    contains_four_lines(s) &&\n    all_lines_have_four_valid_integers(s)\n}\n\nspec fn contains_four_lines(s: Seq<char>) -> bool {\n    count_newlines(s, 0) >= 3\n}\n\nspec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1' || s[i] == ' ' || s[i] == '\\n')\n}\n\nspec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {\n    input_lines.len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&\n    (forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> \n        (#[trigger] input_lines[i][j] >= 0 && #[trigger] input_lines[i][j] <= 1)) &&\n    string_contains_four_lines_of_four_integers(s, input_lines)\n}\n\nspec fn string_contains_four_lines_of_four_integers(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {\n    input_lines.len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&\n    valid_input_string(s)\n}\n\nspec fn accident_possible(lanes: Seq<Seq<int>>) -> bool\n    recommends \n        lanes.len() == 4,\n        forall|i: int| 0 <= i < 4 ==> #[trigger] lanes[i].len() == 4,\n        forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> \n            (#[trigger] lanes[i][j] == 0 || #[trigger] lanes[i][j] == 1)\n{\n    exists|i: int| 0 <= i < 4 && accident_at_lane(i, lanes)\n}\n\nspec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool\n    recommends \n        0 <= i < 4,\n        lanes.len() == 4,\n        forall|j: int| 0 <= j < 4 ==> #[trigger] lanes[j].len() == 4\n{\n    (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||\n    (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||\n    (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||\n    (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> (#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),\n        valid_input_string(s@)\n    ensures \n        result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@,\n        exists|input_lines: Seq<Seq<int>>| \n            parse_input(s@, input_lines) && \n            (result@ == \"YES\\n\"@ <==> accident_possible(input_lines)),\n        result.len() >= 3", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0028", "language": "verus", "source": "apps", "source_id": "apps_test_126", "vc-description": "Given a phone keypad layout and a phone number, determine if the finger movement \nsequence between consecutive key presses is unique (no other number produces the same sequence).\nThe keypad layout is: 1-2-3 in top row, 4-5-6 in middle row, 7-8-9 in bottom row, \nand 0 below 8.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn string_to_digits(s: Seq<char>) -> Set<int> {\n    Set::new(|i: int| \n        0 <= i < s.len() && \n        '0' <= s[i] && \n        s[i] <= '9' && \n        (s[i] as int) - ('0' as int) >= 0\n    ).map(|i: int| (s[i] as int) - ('0' as int))\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n')\n}\n\nspec fn has_unique_movement_sequence(digits: Set<int>) -> bool {\n    (digits.contains(1) || digits.contains(4) || digits.contains(7) || digits.contains(0)) &&\n    (digits.contains(1) || digits.contains(2) || digits.contains(3)) &&\n    (digits.contains(3) || digits.contains(6) || digits.contains(9) || digits.contains(0)) &&\n    (digits.contains(7) || digits.contains(0) || digits.contains(9))\n}\n\nspec fn find_char_index(s: Seq<char>, c: char) -> int {\n    if exists|i: int| 0 <= i < s.len() && s[i] == c {\n        choose|i: int| 0 <= i < s.len() && s[i] == c\n    } else {\n        -1\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if !s.contains('\\n') {\n        seq![s]\n    } else {\n        let idx = find_char_index(s, '\\n');\n        if idx == -1 {\n            seq![s]\n        } else if idx < s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx + 1, s.len() as int)))\n        } else {\n            seq![s]\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() == 3 || result@.len() == 4,\n        result@.len() > 0,\n        ({\n            let lines = split_lines(input@);\n            lines.len() >= 2 ==> {\n                let digits_str = lines[1];\n                let digits = string_to_digits(digits_str);\n                has_unique_movement_sequence(digits) ==> result@.len() == 4\n            }\n        })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0029", "language": "verus", "source": "apps", "source_id": "apps_test_128", "vc-description": "Given n cows initially arranged in positions 1, 2, ..., n, find the maximum number of inversions\nachievable using at most k swaps. An inversion is a pair (i,j) where i < j but the cow in \nposition i has a larger label than the cow in position j.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn compute_inversions(n: int, k: int, iterations: int) -> int\n    decreases iterations when iterations >= 0\n{\n    if iterations == 0 { 0 }\n    else { compute_inversions(n, k, iterations - 1) + (n - 2*(iterations-1) - 1) + (n - 2*(iterations-1) - 2) }\n}\n\nspec fn sum_inversions_formula(n: int, iterations: int) -> int\n    decreases iterations when iterations >= 0\n{\n    if iterations == 0 { 0 }\n    else { sum_inversions_formula(n, iterations - 1) + (n - 2*(iterations-1) - 1) + (n - 2*(iterations-1) - 2) }\n}\n\nspec fn sum_of_consecutive_pairs(n: int, k: int) -> int {\n    let iterations = k;\n    if iterations == 0 { 0 }\n    else { sum_inversions_formula(n, iterations) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires n as int >= 1 && k as int >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0031", "language": "verus", "source": "apps", "source_id": "apps_test_135", "vc-description": "Given two integers n and k, determine whether all remainders n mod i for i = 1, 2, ..., k are distinct.\nSpecifically, check if n mod 1 = 0, n mod 2 = 1, n mod 3 = 2, ..., n mod k = k-1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1\n}\n\nspec fn all_remainders_distinct(n: int, k: int) -> bool {\n    valid_input(n, k) ==> forall|i: int| 1 <= i <= k ==> #[trigger] (n % i) == (i - 1)\n}\n\nspec fn has_non_distinct_remainder(n: int, k: int) -> bool {\n    valid_input(n, k) ==> exists|i: int| 1 <= i <= k && #[trigger] (n % i) != (i - 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: String)\n    requires\n        valid_input(n as int, k as int),\n    ensures\n        result@ == seq!['Y', 'e', 's', '\\n'] <==> all_remainders_distinct(n as int, k as int),\n        result@ == seq!['N', 'o', '\\n'] <==> has_non_distinct_remainder(n as int, k as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0033", "language": "verus", "source": "apps", "source_id": "apps_test_145", "vc-description": "Given a username string containing only lowercase English letters, determine the user's gender\nbased on the number of distinct characters: odd count means male, even count means female.\nOutput \"IGNORE HIM!\" for male, \"CHAT WITH HER!\" for female.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_distinct(s: Seq<char>) -> int {\n    s.to_set().len() as int\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() - 1] == '\\n' &&\n    input.len() >= 2 &&\n    forall|i: int| 0 <= i < input.len() - 1 ==> 'a' <= input[i] && input[i] <= 'z'\n}\n\nspec fn correct_output(username: Seq<char>, output: Seq<char>) -> bool {\n    let distinct_count = count_distinct(username);\n    (distinct_count % 2 == 1 ==> output == seq!['I', 'G', 'N', 'O', 'R', 'E', ' ', 'H', 'I', 'M', '!', '\\n']) &&\n    (distinct_count % 2 == 0 ==> output == seq!['C', 'H', 'A', 'T', ' ', 'W', 'I', 'T', 'H', ' ', 'H', 'E', 'R', '!', '\\n'])\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires valid_input(input@)\n    ensures ({\n        let username = input@.subrange(0, input@.len() - 1);\n        correct_output(username, output@)\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0034", "language": "verus", "source": "apps", "source_id": "apps_test_148", "vc-description": "Given a circular subway with n stations, determine if two trains moving in opposite directions\nwill ever meet at the same station. Train 1 moves clockwise (1→2→...→n→1), Train 2 moves \ncounterclockwise (n→(n-1)→...→1→n). Daniel boards Train 1 at station a, exits at x.\nVlad boards Train 2 at station b, exits at y. All a,x,b,y are distinct.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == '\\n') &&\n    {\n        let parts = parse_input(input);\n        parts.len() == 5 &&\n        parts[0] >= 4 && parts[0] <= 100 &&\n        parts[1] >= 1 && parts[1] <= parts[0] &&\n        parts[2] >= 1 && parts[2] <= parts[0] &&\n        parts[3] >= 1 && parts[3] <= parts[0] &&\n        parts[4] >= 1 && parts[4] <= parts[0] &&\n        parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&\n        parts[2] != parts[3] && parts[2] != parts[4] &&\n        parts[3] != parts[4]\n    }\n}\n\nspec fn trains_will_meet(input: Seq<char>) -> bool \n    recommends\n        input.len() > 0,\n        exists|i: int| 0 <= i < input.len() && input[i] == '\\n',\n        valid_input(input),\n{\n    let parts = parse_input(input);\n    let n = parts[0];\n    let a = parts[1];\n    let x = parts[2];\n    let b = parts[3];\n    let y = parts[4];\n\n    if a == b { true }\n    else { simulate_trains(n, a, x, b, y) }\n}\n\nspec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool\n    recommends\n        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,\n        a != x && a != b && a != y && x != b && x != y && b != y,\n{\n    simulate_trains_helper(n, a, x, b, y, 2 * n)\n}\n\nspec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {\n    if fuel <= 0 {\n        false\n    } else {\n        /* Placeholder simulation logic - returns false for now */\n        false\n    }\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<int> {\n    /* Placeholder parsing logic - returns empty sequence for now */\n    seq![]\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<u8>) -> (result: String)\n    requires \n        stdin_input.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n' as u8,\n        valid_input(stdin_input@.map(|i, x: u8| x as char)),\n    ensures\n        result@ =~= seq!['Y', 'E', 'S', '\\n'] || result@ =~= seq!['N', 'O', '\\n'],\n        result@ =~= seq!['Y', 'E', 'S', '\\n'] <==> trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n        result@ =~= seq!['N', 'O', '\\n'] <==> !trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"NO\\n\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0036", "language": "verus", "source": "apps", "source_id": "apps_test_157", "vc-description": "Given the number of lemons (a), apples (b), and pears (c), find the maximum total number of fruits\nthat can be used to make a compote following the recipe ratio of 1:2:4 (lemons:apples:pears).\nFruits must be used whole and cannot be cut or broken. If no complete recipe units can be made, output 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= c <= 1000\n}\n\nspec fn max_recipe_units(a: int, b: int, c: int) -> int {\n    if a <= b / 2 && a <= c / 4 {\n        a\n    } else if b / 2 <= a && b / 2 <= c / 4 {\n        b / 2\n    } else {\n        c / 4\n    }\n}\n\nspec fn total_fruits_used(units: int) -> int {\n    units * 7\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int)\n    ensures \n        result as int == total_fruits_used(max_recipe_units(a as int, b as int, c as int)),\n        result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0039", "language": "verus", "source": "apps", "source_id": "apps_test_164", "vc-description": "Given a rectangular football field where Robo-Wallace is at position (x_b, y_b) with a ball of radius r,\nfind a point x_w on the right wall (at y = y_w) such that kicking the ball there will cause it to bounce\nonce and go through the goal. The goal is located at x = 0, between y-coordinates y_1 and y_2.\nThe ball moves in straight lines and bounces elastically off walls. A goal is scored when the ball's\ncenter crosses the y-axis between y_1 and y_2. Output x_w if possible, otherwise -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {\n    y1 < y2 < y_w &&\n    y_b + r < y_w &&\n    2 * r < y2 - y1 &&\n    x_b > 0 && y_b > 0 && r > 0 &&\n    2 * (y_w - r) - y1 - y_b - r != 0\n}\n\nspec fn compute_w(y_w: int, r: int) -> int {\n    y_w - r\n}\n\nspec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {\n    2 * (y_w - r) - y1 - y_b - r\n}\n\nspec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {\n    2 * (y_w - r) - y2 - y_b\n}\n\nspec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {\n    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)\n}\n\nspec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {\n    (new_y1 * new_y1 + x_b * x_b) * r * r\n}\n\nspec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool\n    recommends valid_input(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    let new_y2 = compute_new_y2(y_w, r, y2, y_b);\n    let left_side = compute_left_side(x_b, new_y1, new_y2);\n    let right_side = compute_right_side(x_b, new_y1, r);\n    left_side <= right_side\n}\n\nspec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int\n    recommends \n        valid_input(y1, y2, y_w, x_b, y_b, r) &&\n        !is_impossible(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    x_b * (new_y1 + y_b - w) / new_y1\n}", "vc-helpers": "", "vc-spec": "fn solve(y1: i8, y2: i8, y_w: i8, x_b: i8, y_b: i8, r: i8) -> (result: i8)\n    requires \n        valid_input(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n    ensures \n        is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result == -1,\n        !is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result as int == compute_solution(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0040", "language": "verus", "source": "apps", "source_id": "apps_test_165", "vc-description": "Calculate the minimum number of meals Vasiliy could have missed during his sanatorium stay.\nGiven counts of breakfasts (b), dinners (d), and suppers (s) he had, determine how many meals\nhe definitively missed based on arrival/departure timing constraints.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a }\n    else if b >= c { b }\n    else { c }\n}\n\nspec fn calculate_missed_meals(input: Seq<char>) -> int {\n    /* Implementation placeholder for spec function */\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char> {\n    /* Specification for integer to string conversion */\n    seq![]\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\nrequires valid_input(input@)\nensures result@ == int_to_string_spec(calculate_missed_meals(input@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0041", "language": "verus", "source": "apps", "source_id": "apps_test_171", "vc-description": "Given a password string, determine if it meets complexity requirements.\nA password is complex if it has at least 5 characters, contains at least\none uppercase letter, one lowercase letter, and one digit.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn contains_lowercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'a' <= s[i] && s[i] <= 'z'\n}\n\nspec fn contains_uppercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'A' <= s[i] && s[i] <= 'Z'\n}\n\nspec fn contains_digit(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_password(s: Seq<char>) -> bool {\n    s.len() >= 5 && contains_lowercase(s) && contains_uppercase(s) && contains_digit(s)\n}\n\nspec fn trim_newline(s: Seq<char>) -> Seq<char> {\n    if s.len() > 0 && s[s.len() as int - 1] == '\\n' { \n        s.subrange(0, s.len() as int - 1) \n    } else { \n        s \n    }\n}\n\nspec fn strip_whitespace(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        s\n    } else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' {\n        strip_whitespace(s.subrange(1, s.len() as int))\n    } else if s[s.len() as int - 1] == ' ' || s[s.len() as int - 1] == '\\t' || s[s.len() as int - 1] == '\\n' || s[s.len() as int - 1] == '\\r' {\n        strip_whitespace(s.subrange(0, s.len() as int - 1))\n    } else { \n        s \n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires input@.len() > 0\n    ensures ({\n        let processed_input = trim_newline(input@);\n        let stripped = strip_whitespace(processed_input);\n        if is_valid_password(stripped) {\n            output@ == seq!['C', 'o', 'r', 'r', 'e', 'c', 't', '\\n']\n        } else {\n            output@ == seq!['T', 'o', 'o', ' ', 'w', 'e', 'a', 'k', '\\n']\n        }\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0042", "language": "verus", "source": "apps", "source_id": "apps_test_173", "vc-description": "Given an (n-1) × (m-1) grid of junctions formed by n horizontal streets and m vertical streets,\nwhere each street is one-way, determine if it's possible to reach any junction from any other junction.\nInput: n, m (dimensions), string of horizontal directions ('<' or '>'), string of vertical directions ('^' or 'v').\nOutput: \"YES\" if fully connected, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, horizontal: Seq<char>, vertical: Seq<char>) -> bool {\n    n >= 2 && n <= 20 && m >= 2 && m <= 20 &&\n    horizontal.len() == n && vertical.len() == m &&\n    (forall|c: char| horizontal.contains(c) ==> c == '<' || c == '>') &&\n    (forall|c: char| vertical.contains(c) ==> c == '^' || c == 'v')\n}\n\nspec fn is_disconnected(hor: Seq<char>, ver: Seq<char>) -> bool {\n    (hor.len() > 0 && ver.len() > 0 && hor[0] == '>' && ver[0] == 'v') ||\n    (hor.len() > 0 && ver.len() > 0 && hor[0] == '<' && ver[ver.len()-1] == 'v') ||\n    (hor.len() > 0 && ver.len() > 0 && hor[hor.len()-1] == '>' && ver[0] == '^') ||\n    (hor.len() > 0 && ver.len() > 0 && hor[hor.len()-1] == '<' && ver[ver.len()-1] == '^')\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, horizontal: Vec<char>, vertical: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(n as int, m as int, horizontal@, vertical@)\n    ensures \n        result@ == seq!['Y', 'E', 'S', '\\n'] || result@ == seq!['N', 'O', '\\n'],\n        (result@ == seq!['N', 'O', '\\n']) <==> is_disconnected(horizontal@, vertical@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0043", "language": "verus", "source": "apps", "source_id": "apps_test_176", "vc-description": "Count the number of integers in the range [a, b] that are divisible by k.\nGiven three integers k, a, b where k > 0 and a <= b, return the count of\nintegers x such that a <= x <= b and x % k == 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(k: int, a: int, b: int) -> bool {\n  k > 0 && a <= b\n}\n\nspec fn floor_div(a: int, b: int) -> int {\n  if a >= 0 { a / b }\n  else { (a - b + 1) / b }\n}\n\nspec fn count_divisibles_in_range(k: int, a: int, b: int) -> int {\n  floor_div(b, k) - floor_div(a - 1, k)\n}", "vc-helpers": "", "vc-spec": "fn solve(k: i8, a: i8, b: i8) -> (result: i8)\n  requires\n    valid_input(k as int, a as int, b as int),\n  ensures\n    result >= 0,\n    result as int == count_divisibles_in_range(k as int, a as int, b as int),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0045", "language": "verus", "source": "apps", "source_id": "apps_test_181", "vc-description": "Given a camera rotation angle in degrees, determine the minimum number of 90-degree \nclockwise rotations needed to minimize the image's deviation from vertical orientation.\nWhen a camera rotates by x degrees, the image appears rotated by -x degrees.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn normalize_angle(angle: int) -> int {\n    let n = angle % 360;\n    if n < 0 { n + 360 } else { n }\n}\n\nspec fn deviation_from_vertical(angle: int) -> int\n    recommends 0 <= angle < 360\n{\n    if angle <= 180 { angle } else { 360 - angle }\n}\n\nspec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    normalize_angle(-camera_angle + 90 * rotations)\n}\n\nspec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    deviation_from_vertical(image_angle_after_rotations(camera_angle, rotations))\n}\n\nspec fn is_optimal_rotations(camera_angle: int, result: int) -> bool\n    recommends 0 <= result <= 3\n{\n    forall|k: int| 0 <= k <= 3 ==> #[trigger] image_deviation_after_rotations(camera_angle, k) >= image_deviation_after_rotations(camera_angle, result) && (image_deviation_after_rotations(camera_angle, k) > image_deviation_after_rotations(camera_angle, result) || result <= k)\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8) -> (result: u8)\n    ensures \n        0 <= result <= 3,\n        is_optimal_rotations(x as int, result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0046", "language": "verus", "source": "apps", "source_id": "apps_test_185", "vc-description": "Given n manholes in a line (positions 1 to n), each initially covered by one stone with one coin underneath.\nNastya starts at position k and can: throw stones, move to adjacent positions, or collect coins from uncovered manholes.\nFind the minimum number of moves needed to collect all n coins.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    2 <= n <= 5000 && 1 <= k <= n\n}\n\nspec fn optimal_moves(n: int, k: int) -> int {\n    if k == 1 || k == n {\n        3 * n\n    } else {\n        3 * n + spec_min(k - 1, n - k)\n    }\n}\n\nspec fn spec_min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}", "vc-helpers": "", "vc-spec": "fn minimum_moves(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result as int == optimal_moves(n as int, k as int),\n        result > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0047", "language": "verus", "source": "apps", "source_id": "apps_test_189", "vc-description": "Given n sticks with positive integer lengths, find a positive integer t and modify sticks to minimize \ntotal cost such that all final lengths are almost good for t (within distance 1 of t).\nCost to change a stick's length is the absolute difference.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, sticks: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    sticks.len() == n &&\n    (forall|i: int| 0 <= i < sticks.len() ==> #[trigger] sticks[i] >= 1 && #[trigger] sticks[i] <= 100)\n}\n\nspec fn cost_for_t(sticks: Seq<int>, t: int) -> int {\n    sum_costs(sticks, t, 0)\n}\n\nspec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int\n    decreases sticks.len() - index when 0 <= index <= sticks.len()\n{\n    if index < 0 || index >= sticks.len() {\n        0\n    } else if index == sticks.len() {\n        0\n    } else {\n        max_int(0, abs_int(t - sticks[index as int]) - 1) + sum_costs(sticks, t, index + 1)\n    }\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn max_int(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n    forall|other_t: int| 1 <= other_t <= 99 ==> \n        #[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)\n}", "vc-helpers": "", "vc-spec": "fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))\n    requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))\n    ensures ({\n        let (t, min_cost) = result;\n        1 <= t as int <= 99 &&\n        min_cost as int >= 0 &&\n        min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&\n        is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0048", "language": "verus", "source": "apps", "source_id": "apps_test_194", "vc-description": "Given n groups arriving at a restaurant chronologically, where each group has 1 or 2 people,\nand the restaurant has a one-person tables and b two-person tables, determine how many people\nare denied service following specific seating rules.\n\n/* group == 1 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && groups.len() == n &&\n    forall|i: int| 0 <= i < groups.len() ==> groups[i] == 1 || groups[i] == 2\n}\n\nspec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {\n    count_denied_people_with_half(groups, a, b, 0)\n}\n\nspec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int\n    decreases groups.len()\n{\n    if groups.len() == 0 {\n        0\n    } else {\n        let group = groups[0];\n        let rest = groups.subrange(1, groups.len() as int);\n        if group == 2 {\n            if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied)\n            } else {\n                2 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        } else {\n            if a > 0 {\n                count_denied_people_with_half(rest, a - 1, b, half_occupied)\n            } else if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied + 1)\n            } else if half_occupied > 0 {\n                count_denied_people_with_half(rest, a, b, half_occupied - 1)\n            } else {\n                1 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8, groups: Vec<i8>) -> (denied: i8)\n    requires \n        valid_input(n as int, a as int, b as int, groups@.map_values(|x: i8| x as int))\n    ensures \n        denied >= 0,\n        denied as int == count_denied_people(groups@.map_values(|x: i8| x as int), a as int, b as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0049", "language": "verus", "source": "apps", "source_id": "apps_test_198", "vc-description": "Given a positive integer n, cut a stick of length n into exactly 4 parts with positive integer lengths.\nCount the number of ways to do this such that the parts can form a rectangle (two pairs of equal lengths)\nbut cannot form a square (all four lengths equal). Two cutting methods are distinct if the number of\nparts of any given length differs between them.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_rectangle_parts(a: int, b: int, n: int) -> bool {\n    a > 0 && b > 0 && a != b && 2 * a + 2 * b == n\n}\n\nspec fn count_valid_rectangles(n: int) -> int\n    recommends n > 0\n{\n    if n % 2 == 1 { 0 }\n    else if n % 4 == 2 { n / 4 }\n    else { n / 4 - 1 }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n > 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures \n        result as int == count_valid_rectangles(n as int) &&\n        (n as int % 2 == 1 ==> result as int == 0) &&\n        (n as int % 2 == 0 && n as int % 4 == 2 ==> result as int == n as int / 4) &&\n        (n as int % 2 == 0 && n as int % 4 == 0 ==> result as int == n as int / 4 - 1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0050", "language": "verus", "source": "apps", "source_id": "apps_test_199", "vc-description": "Given n kegs containing v_i liters of kvass each, pour exactly s liters total \nsuch that the minimum amount remaining in any keg is maximized. Each keg can \nonly have kvass removed, not added. Return -1 if impossible to pour s liters,\notherwise return the maximum possible minimum remaining amount in any keg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {\n    n > 0 && v.len() == n && s >= 0 && forall|i: int| 0 <= i < v.len() ==> v[i] >= 0\n}\n\nspec fn sum(v: Seq<int>) -> int\n    decreases v.len()\n{\n    if v.len() == 0 {\n        0\n    } else {\n        v[0] + sum(v.subrange(1, v.len() as int))\n    }\n}\n\nspec fn min_seq(v: Seq<int>) -> int\n    recommends v.len() > 0\n    decreases v.len()\n{\n    if v.len() == 1 {\n        v[0]\n    } else if v.len() > 1 && v[0] <= min_seq(v.subrange(1, v.len() as int)) {\n        v[0]\n    } else if v.len() > 1 {\n        min_seq(v.subrange(1, v.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, s: i8, v: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, v@.map(|i, x| x as int))\n    ensures \n        sum(v@.map(|i, x| x as int)) < s as int ==> result == -1,\n        sum(v@.map(|i, x| x as int)) >= s as int ==> result == min((sum(v@.map(|i, x| x as int)) - s as int) / n as int, min_seq(v@.map(|i, x| x as int))) as i8,\n        result == -1 || result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0051", "language": "verus", "source": "apps", "source_id": "apps_test_201", "vc-description": "Given two types of candies with different weights and joy values, find the maximum joy units\nachievable by selecting whole candies within a weight constraint. Must maximize total joy\nwhile staying within the weight capacity C.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(c: int, hr: int, hb: int, wr: int, wb: int) -> bool {\n    c >= 0 && hr > 0 && hb > 0 && wr > 0 && wb > 0\n}\n\nspec fn valid_candy_combination(red_count: int, blue_count: int, c: int, wr: int, wb: int) -> bool {\n    red_count >= 0 && blue_count >= 0 && red_count * wr + blue_count * wb <= c\n}\n\nspec fn joy(red_count: int, blue_count: int, hr: int, hb: int) -> int {\n    red_count * hr + blue_count * hb\n}", "vc-helpers": "", "vc-spec": "fn solve(c: i8, hr: i8, hb: i8, wr: i8, wb: i8) -> (result: i8)\n    requires\n        valid_input(c as int, hr as int, hb as int, wr as int, wb as int),\n    ensures\n        result >= 0,\n        exists|red_count: int, blue_count: int| \n            valid_candy_combination(red_count, blue_count, c as int, wr as int, wb as int) &&\n            result as int == joy(red_count, blue_count, hr as int, hb as int),\n        forall|red_count: int, blue_count: int|\n            valid_candy_combination(red_count, blue_count, c as int, wr as int, wb as int) ==>\n            joy(red_count, blue_count, hr as int, hb as int) <= result as int,", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0052", "language": "verus", "source": "apps", "source_id": "apps_test_203", "vc-description": "Determine the winner of an elimination-style voting game between two factions.\nEmployees vote in rounds, can eliminate opponents, and play optimally.\nThe faction with the last remaining employee wins.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    1 <= n <= 200000 && s.len() == n &&\n    forall|i: int| 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'\n}\n\nspec fn count_d(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'D' { 1int } else { 0int }) + count_d(s.subrange(1, s.len() as int)) }\n}\n\nspec fn count_r(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'R' { 1int } else { 0int }) + count_r(s.subrange(1, s.len() as int)) }\n}\n\nspec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {\n    if count_d(s) == 0 { seq!['R'] }\n    else if count_r(s) == 0 { seq!['D'] }\n    else if count_d(s) >= count_r(s) { seq!['D'] }\n    else { seq!['R'] }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(n as int, s@)\n    ensures result@ == optimal_elimination_game_winner(s@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0053", "language": "verus", "source": "apps", "source_id": "apps_test_204", "vc-description": "Count pairs of positive integers (w, h) such that:\n- w ≤ a (width constraint)  \n- h ≤ b (height constraint)\n- w/h = x/y (aspect ratio constraint)\nThe solution reduces x/y to lowest terms and finds the maximum multiplier k\nsuch that valid pairs have the form (k×x', k×y') where x' = x/gcd(x,y) and y' = y/gcd(x,y)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, x: int, y: int) -> bool {\n  a > 0 && b > 0 && x > 0 && y > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a >= 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn min(a: int, b: int) -> int {\n  if a <= b { a } else { b }\n}\n\nspec fn expected_result(a: int, b: int, x: int, y: int) -> int\n  recommends valid_input(a, b, x, y)\n{\n  let g = gcd(x, y);\n  let x_reduced = x / g;\n  let y_reduced = y / g;\n  min(a / x_reduced, b / y_reduced)\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, x: i8, y: i8) -> (result: i8)\nrequires \n  valid_input(a as int, b as int, x as int, y as int)\nensures \n  result as int >= 0,\n  result as int == expected_result(a as int, b as int, x as int, y as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0054", "language": "verus", "source": "apps", "source_id": "apps_test_207", "vc-description": "Given an integer sequence, determine if it can be divided into an odd number of \nnon-empty contiguous subsegments, where each subsegment has odd length and \nbegins and ends with odd numbers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>) -> bool {\n    a.len() >= 1\n}\n\nspec fn can_be_divided(a: Seq<int>) -> bool\n    recommends valid_input(a)\n{\n    a.len() % 2 == 1 && a[0] % 2 == 1 && a[a.len() - 1] % 2 == 1\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>) -> (result: String)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        can_be_divided(a@.map(|i, x| x as int)) ==> result@ =~= seq!['Y', 'e', 's'],\n        (!can_be_divided(a@.map(|i, x| x as int))) ==> result@ =~= seq!['N', 'o'],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0055", "language": "verus", "source": "apps", "source_id": "apps_test_208", "vc-description": "Given coordinates of two trees that are vertices of a square (with sides parallel to coordinate axes),\nfind the coordinates of the other two vertices. Valid cases include: same x-coordinate (vertical edge),\nsame y-coordinate (horizontal edge), or diagonal vertices where |x₂-x₁| = |y₂-y₁|.\nReturn -1 if no valid square can be formed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {\n    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100\n}\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) != int_abs(y1 - y2)\n}\n\nspec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) == int_abs(y1 - y2)\n}\n\nspec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 == x2\n}\n\nspec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 == y2\n}\n\nspec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y2, x2, y1]\n}\n\nspec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1 + int_abs(y2 - y1), y1, x1 + int_abs(y2 - y1), y2]\n}\n\nspec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y1 + int_abs(x2 - x1), x2, y1 + int_abs(x2 - x1)]\n}\n\nspec fn valid_output(result: Seq<int>) -> bool {\n    (result.len() == 1 && result[0] == -1) ||\n    (result.len() == 4 && (forall|i: int| #![trigger result[i]] 0 <= i < 4 ==> -1000 <= result[i] <= 1000))\n}", "vc-helpers": "", "vc-spec": "fn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(x1 as int, y1 as int, x2 as int, y2 as int)\n    ensures \n        valid_output(result@.map(|i, v| v as int)),\n        is_invalid_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == seq![-1],\n        is_diagonal_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_diagonal_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_vertical_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_vertical_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_horizontal_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_horizontal_result(x1 as int, y1 as int, x2 as int, y2 as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0056", "language": "verus", "source": "apps", "source_id": "apps_test_216", "vc-description": "Given a sequence of integers, partition it into two subsequences such that\nevery element belongs to exactly one subsequence. Find the maximum possible\nvalue of B - C, where B is the sum of elements in the first subsequence\nand C is the sum of elements in the second subsequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_abs(arr: Seq<int>, i: int) -> int\n    decreases arr.len() - i when 0 <= i <= arr.len()\n{\n    if i == arr.len() {\n        0\n    } else {\n        (if arr[i] >= 0 { arr[i] } else { -arr[i] }) + sum_abs(arr, i + 1)\n    }\n}\n\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    0 <= n == arr.len()\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, arr: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, arr@.map(|i: int, v: i8| v as int))\n    ensures result as int == sum_abs(arr@.map(|i: int, v: i8| v as int), 0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0057", "language": "verus", "source": "apps", "source_id": "apps_test_217", "vc-description": "A bus travels back and forth between points x=0 and x=a, making k total journeys.\nThe bus has fuel capacity b and consumes 1 unit per distance unit. There's a gas station at x=f.\nFind minimum refuels needed to complete k journeys, or return -1 if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, f: int, k: int) -> bool {\n  a > 0 && b > 0 && f > 0 && k > 0 && f < a\n}\n\nspec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b < f ||                                    \n  b < a - f ||                               \n  (k > 1 && b < 2 * a - f) ||               \n  (k == 1 && b < a && b < f)                \n}\n\nspec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b >= f &&                                  \n  b >= a - f &&                             \n  (k <= 1 || b >= 2 * a - f) &&            \n  (k == 1 ==> (b >= a || b >= f))          \n}\n\nspec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k == 1 && result >= 0 ==> (\n    (b >= a && result == 0) ||                \n    (b < a && b >= f && result == 1)          \n  )\n}\n\nspec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k > 1 && result >= 0 ==> (\n    b >= f && b >= a - f && b >= 2 * a - f    \n  )\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, f: i8, k: i8) -> (result: i8)\n  requires\n    valid_input(a as int, b as int, f as int, k as int)\n  ensures\n    result as int >= -1 &&\n    ((result as int == -1) <==> impossible_conditions(a as int, b as int, f as int, k as int)) &&\n    (result as int >= 0 ==> result as int <= k as int) &&\n    (result as int >= 0 ==> feasibility_conditions(a as int, b as int, f as int, k as int)) &&\n    single_journey_result(a as int, b as int, f as int, k as int, result as int) &&\n    multi_journey_feasibility(a as int, b as int, f as int, k as int, result as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0058", "language": "verus", "source": "apps", "source_id": "apps_test_222", "vc-description": "Given a positive integer n as a string, find the minimum number of digit deletions \nrequired to transform n into a perfect square, or return -1 if impossible.\nYou can delete any digit from n as long as the result remains a positive integer \nwithout leading zeros. A perfect square is an integer x = y² for some positive integer y.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn generate_squares() -> Seq<int> {\n    generate_squares_helper(1, 44721)\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n) }\n}\n\nspec fn generate_squares_helper(start: int, end: int) -> Seq<int>\n    decreases end + 1 - start when start <= end\n{\n    if start > end { Seq::empty() }\n    else { seq![start * start].add(generate_squares_helper(start + 1, end)) }\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool\n    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()\n{\n    if pi >= pattern.len() { true }\n    else if ti >= text.len() { false }\n    else if pattern[pi] == text[ti] { \n        is_subsequence_helper(pattern, text, pi + 1, ti + 1)\n    } else {\n        is_subsequence_helper(pattern, text, pi, ti + 1)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 { seq![('0' as u8 + (n % 10) as u8) as char] }\n    else { int_to_string_helper(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char]) }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i32)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s@[i] <= '9',\n        s@[0] != '0' || s.len() == 1,\n    ensures \n        result == -1 || result >= 0,\n        result == -1 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) ==> !is_subsequence(int_to_string(sq), s@),\n        result >= 0 ==> exists|sq: int| #![auto] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) && result == s.len() as i32 - int_to_string(sq).len() as i32,\n        result >= 0 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) ==> s.len() as i32 - int_to_string(sq).len() as i32 >= result,", "vc-code": "{\n    assume(false);\n    -1\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0059", "language": "verus", "source": "apps", "source_id": "apps_test_228", "vc-description": "Given n piles of stones (n even), Alice and Bob alternate turns with Alice first.\nEach turn, a player chooses n/2 nonempty piles and removes positive stones from each.\nA player loses when fewer than n/2 nonempty piles remain. Determine the winner.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn minimum(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] <= minimum(s.subrange(1, s.len() as int)) {\n        s[0]\n    } else {\n        minimum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_occurrences(s: Seq<int>, val: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == val { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), val)\n    }\n}\n\nspec fn valid_input(n: int, piles: Seq<int>) -> bool {\n    n >= 2 && n % 2 == 0 && piles.len() == n && forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 1\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, piles: Vec<i8>) -> (result: &'static str)\n    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))\n    ensures result == \"Alice\" || result == \"Bob\"", "vc-code": "{\n    assume(false);\n    \"Alice\"\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0060", "language": "verus", "source": "apps", "source_id": "apps_test_231", "vc-description": "Vasya needs to drive to house number a on a street with n houses (n is even).\nOdd-numbered houses are on one side from beginning to end, even-numbered houses\nare on the other side from end to beginning. Distance from beginning to houses\n1 and n is 1 unit, and consecutive houses on same side are 1 unit apart.\nFind minimum time to reach house a from street beginning.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: int) -> bool {\n    n > 0 && n % 2 == 0 && 1 <= a <= n\n}\n\nspec fn distance_to_house(n: int, a: int) -> int\n{\n    if a % 2 == 1 {\n        a / 2 + 1\n    } else {\n        (n - a) / 2 + 1\n    }\n}", "vc-helpers": "", "vc-spec": "fn min_distance(n: i8, a: i8) -> (result: i8)\nrequires\n    valid_input(n as int, a as int)\nensures\n    result as int == distance_to_house(n as int, a as int)\n{\n    assume(false);\n    unreached()\n}", "vc-code": "/* placeholder implementation */", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0062", "language": "verus", "source": "apps", "source_id": "apps_test_235", "vc-description": "Given n candies, find the minimum k such that Vasya eats at least half of the original candies.\nDaily process: Vasya eats k candies in morning, Petya eats floor(remaining/10) in evening.\nContinue until no candies remain.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn vasya_eats_with_strategy(n: int, k: int) -> int\n    decreases n\n{\n    if n <= 0 || k < 1 { \n        0 \n    } else {\n        let cur = if n < k { n } else { k };\n        let remaining_after_vasya = n - cur;\n        let remaining_after_petya = remaining_after_vasya - remaining_after_vasya / 10;\n        cur + vasya_eats_with_strategy(remaining_after_petya, k)\n    }\n}\n\nspec fn is_minimal_solution(n: int, k: int) -> bool {\n    valid_input(n) && k >= 1 && \n    vasya_eats_with_strategy(n, k) * 2 >= n &&\n    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures\n        1 <= result as int <= n as int,\n        is_minimal_solution(n as int, result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0063", "language": "verus", "source": "apps", "source_id": "apps_test_244", "vc-description": "Given 3 shells numbered 0, 1, 2, a ball starts under one shell. An operator makes n moves:\nodd moves swap shells 0 and 1, even moves swap shells 1 and 2. Given the final position x\nafter n moves, determine the initial position of the ball.\n\n/* odd move: swap 0 and 1 */\n\n/* even move: swap 1 and 2 */\n\n/* reverse odd move: swap 0 and 1 */\n\n/* reverse even move: swap 1 and 2 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_position(pos: int) -> bool {\n    0 <= pos <= 2\n}\n\nspec fn swap_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n\nspec fn reverse_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}", "vc-helpers": "", "vc-spec": "fn shell_game(n: i32, x: i8) -> (result: i8)\n    requires \n        n >= 1 && n <= 2000000000,\n        valid_position(x as int),\n    ensures valid_position(result as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0064", "language": "verus", "source": "apps", "source_id": "apps_test_246", "vc-description": "Count positive integers x ≤ n where x - (sum of digits of x) ≥ s.\nGiven two integers n and s (1 ≤ n, s ≤ 10^18), return the count of numbers x ≤ n satisfying the condition.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_of_digits(x: int) -> int\n  decreases x when x >= 0\n{\n  if x <= 0 { 0 } else { (x % 10) + sum_of_digits(x / 10) }\n}\n\nspec fn check(x: int, s: int) -> bool {\n  x >= 0 && x - sum_of_digits(x) >= s\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, s: i8) -> (result: i8)\nrequires n as int >= 1 && s as int >= 1\nensures result as int >= 0 && result as int <= n as int", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0065", "language": "verus", "source": "apps", "source_id": "apps_test_253", "vc-description": "Given three positive integers k₁, k₂, k₃ (each ≤ 1500), determine if there exist \nstarting times x₁, x₂, x₃ such that every integer t ≥ max(x₁, x₂, x₃) can be written \nas xᵢ + j·kᵢ for some i ∈ {1,2,3} and non-negative integer j. In other words, \ndetermine if the union of three arithmetic progressions can cover all sufficiently \nlarge positive integers.\n\n/* a == 2 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(nums: Seq<int>) -> bool {\n    nums.len() == 3 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] > 0 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1500\n}\n\nspec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {\n    if x <= y && x <= z {\n        if y <= z { (x, y, z) } else { (x, z, y) }\n    } else if y <= x && y <= z {\n        if x <= z { (y, x, z) } else { (y, z, x) }\n    } else {\n        if x <= y { (z, x, y) } else { (z, y, x) }\n    }\n}\n\nspec fn compute_result(x: int, y: int, z: int) -> Seq<char> {\n    let sorted = sort_three(x, y, z);\n    let a = sorted.0;\n    let b = sorted.1;\n    let c = sorted.2;\n\n    if a > 3 {\n        seq!['N', 'O']\n    } else if a == 3 {\n        if b > 3 {\n            seq!['N', 'O']\n        } else if b == 3 {\n            if c > 3 { seq!['N', 'O'] } else { seq!['Y', 'E', 'S'] }\n        } else {\n            seq!['N', 'O']\n        }\n    } else if a == 1 {\n        seq!['Y', 'E', 'S']\n    } else {\n        if b == 2 {\n            seq!['Y', 'E', 'S']\n        } else if b > 4 {\n            seq!['N', 'O']\n        } else if b == 4 {\n            if c == 4 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }\n        } else {\n            seq!['N', 'O']\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(nums: Vec<i8>) -> (result: Vec<char>)\n    requires\n        valid_input(nums@.map(|i, x| x as int)),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        result@ == compute_result(nums@[0] as int, nums@[1] as int, nums@[2] as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0069", "language": "verus", "source": "apps", "source_id": "apps_test_271", "vc-description": "Given a non-negative integer n, round it to the nearest integer that ends with 0.\nIf n already ends with 0, return n unchanged. When there are two equally distant\noptions (when the last digit is 5), use banker's rounding (round half to even).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_result(n: int, result: int) -> bool\n  recommends n >= 0\n{\n  let quotient = n / 10;\n  let remainder = n % 10;\n  result % 10 == 0 && \n  result >= 0 &&\n  (remainder < 5 ==> result == quotient * 10) &&\n  (remainder > 5 ==> result == (quotient + 1) * 10) &&\n  (remainder == 5 ==> (quotient % 2 == 0 ==> result == quotient * 10) && \n                      (quotient % 2 == 1 ==> result == (quotient + 1) * 10))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n  requires n >= 0\n  ensures valid_result(n as int, result as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0070", "language": "verus", "source": "apps", "source_id": "apps_test_287", "vc-description": "Given n apartments numbered 1 to n arranged in a row, with exactly k apartments already inhabited,\nfind the minimum and maximum possible number of \"good\" apartments. A good apartment is one that is\navailable for sale (not inhabited) and has at least one inhabited apartment adjacent to it.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 0 && k <= n\n}\n\nspec fn valid_output(result: Seq<int>, n: int, k: int) -> bool\n{\n    result.len() == 2 && \n    result[0] >= 0 && \n    result[1] >= 0 && \n    result[0] <= result[1] &&\n    result[0] <= n - k &&\n    result[1] <= n - k\n}\n\nspec fn min_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 } else { 1 }\n}\n\nspec fn max_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 }\n    else if n - k < k * 2 { n - k }\n    else { k * 2 }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires valid_input(n as int, k as int)\n    ensures \n        result.len() == 2 &&\n        valid_output(result@.map(|i: int, x: i8| x as int), n as int, k as int) &&\n        result[0] as int == min_good_apartments(n as int, k as int) &&\n        result[1] as int == max_good_apartments(n as int, k as int)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0071", "language": "verus", "source": "apps", "source_id": "apps_test_291", "vc-description": "Given two initial weights a and b where a ≤ b, determine after how many years \nLimak (starting weight a) becomes strictly heavier than Bob (starting weight b).\nEach year, Limak's weight triples and Bob's weight doubles.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn pow(base: int, exp: int) -> int\n  decreases exp\n{\n  if exp <= 0 { 1 }\n  else { base * pow(base, exp - 1) }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (years: i8)\n  requires \n      1 <= a <= b <= 10,\n      forall|base: int, exp: int| exp >= 0 ==> (\n          (exp == 0 ==> pow(base, exp) == 1) &&\n          (exp > 0 && base > 0 ==> pow(base, exp) > 0) &&\n          (exp > 0 && base == 0 ==> pow(base, exp) == 0)\n      ),\n  ensures \n      years >= 0,\n      (a as int) * pow(3, years as int) > (b as int) * pow(2, years as int),\n      years == 0 || (a as int) * pow(3, (years - 1) as int) <= (b as int) * pow(2, (years - 1) as int),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0072", "language": "verus", "source": "apps", "source_id": "apps_test_298", "vc-description": "Two players take turns removing exactly k consecutive sticks from either end of a row of n sticks.\nThe first player moves first. The game ends when fewer than k sticks remain.\nDetermine if the first player wins by making strictly more moves than the second player.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    k >= 1 && n >= 1 && k <= n\n}\n\nspec fn total_moves(n: int, k: int) -> int {\n    if valid_input(n, k) { n / k } else { 0 }\n}\n\nspec fn first_player_wins(n: int, k: int) -> bool {\n    if valid_input(n, k) { total_moves(n, k) % 2 == 1 } else { false }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: String)\n    requires\n        valid_input(n as int, k as int),\n    ensures\n        first_player_wins(n as int, k as int) ==> result@ == seq!['Y', 'E', 'S'],\n        !first_player_wins(n as int, k as int) ==> result@ == seq!['N', 'O'],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0073", "language": "verus", "source": "apps", "source_id": "apps_test_299", "vc-description": "Given n exercises with repetition counts, determine which muscle group receives the most total repetitions.\nExercises cycle through three types based on position (0-indexed):\n- Position 0, 3, 6, ... : chest exercises\n- Position 1, 4, 7, ... : biceps exercises  \n- Position 2, 5, 8, ... : back exercises\nReturn the muscle group with the highest total repetitions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn chest_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn chest_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn biceps_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn biceps_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn back_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn back_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn valid_input(reps: Seq<int>) -> bool {\n    reps.len() > 0 && forall|i: int| 0 <= i < reps.len() ==> reps[i] > 0\n}\n\nspec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {\n    let chest_total_val = chest_total(reps);\n    let biceps_total_val = biceps_total(reps);\n    let back_total_val = back_total(reps);\n\n    match muscle {\n        \"chest\" => chest_total_val >= biceps_total_val && chest_total_val >= back_total_val,\n        \"biceps\" => biceps_total_val > chest_total_val && biceps_total_val >= back_total_val,\n        \"back\" => back_total_val > chest_total_val && back_total_val > biceps_total_val,\n        _ => false,\n    }\n}", "vc-helpers": "", "vc-spec": "fn find_strongest_muscle_group(reps: Vec<i8>) -> (result: &'static str)\n    requires \n        valid_input(reps@.map(|i: int, x: i8| x as int))\n    ensures \n        result == \"chest\" || result == \"biceps\" || result == \"back\",\n        is_winner(result, reps@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    \"chest\"\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0074", "language": "verus", "source": "apps", "source_id": "apps_test_302", "vc-description": "Given a positive integer n, find the minimum number of digit 1s needed to represent n \nas a sum and/or difference of repunits (numbers containing only 1s: 1, 11, 111, 1111, ...).\n\n/* simplified for larger values */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 } else { base * pow(base, (exp - 1) as nat) }\n}\n\nspec fn repunit(n: nat) -> nat\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n == 2 { 11 }\n    else if n == 3 { 111 }\n    else if n == 4 { 1111 }\n    else if n == 5 { 11111 }\n    else { n }\n}\n\nspec fn valid_input(n: nat) -> bool\n{\n    true\n}\n\nspec fn valid_output(n: nat, result: nat) -> bool\n{\n    (n == 0 ==> result == 0) &&\n    (n > 0 ==> result > 0)\n}", "vc-helpers": "", "vc-spec": "fn min_repunit_sum(n: u8) -> (result: u8)\n    requires valid_input(n as nat)\n    ensures valid_output(n as nat, result as nat)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0075", "language": "verus", "source": "apps", "source_id": "apps_test_307", "vc-description": "Given k_2 digits '2', k_3 digits '3', k_5 digits '5', and k_6 digits '6',\nform integers 32 and 256 to maximize their sum. Each digit can only be used once.\nTo form 256: need one '2', one '5', one '6'\nTo form 32: need one '3', one '2'", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k2: int, k3: int, k5: int, k6: int) -> bool {\n    k2 >= 0 && k3 >= 0 && k5 >= 0 && k6 >= 0 &&\n    k2 <= 5000000 && k3 <= 5000000 && k5 <= 5000000 && k6 <= 5000000\n}\n\nspec fn optimal_sum(k2: int, k3: int, k5: int, k6: int) -> int\n    recommends valid_input(k2, k3, k5, k6)\n{\n    let count256 = if k2 <= k5 { if k2 <= k6 { k2 } else { k6 } } else { if k5 <= k6 { k5 } else { k6 } };\n    let remaining_k2 = k2 - count256;\n    let count32 = if k3 <= remaining_k2 { k3 } else { remaining_k2 };\n    256 * count256 + 32 * count32\n}", "vc-helpers": "", "vc-spec": "fn solve(k2: i8, k3: i8, k5: i8, k6: i8) -> (result: i8)\n    requires \n        valid_input(k2 as int, k3 as int, k5 as int, k6 as int)\n    ensures \n        result >= 0,\n        result as int == optimal_sum(k2 as int, k3 as int, k5 as int, k6 as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0076", "language": "verus", "source": "apps", "source_id": "apps_test_315", "vc-description": "Given n consecutive days and a minimum requirement k, find the minimum additional walks needed\nso that for any two consecutive days, the total walks is at least k. Can only increase walks.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }\n}\n\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool\n{\n    n >= 1 && a.len() == n && k >= 0 && forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0\n}\n\nspec fn valid_output(a: Seq<int>, final_schedule: Seq<int>, additional_walks: int, k: int) -> bool\n{\n    final_schedule.len() == a.len() &&\n    additional_walks >= 0 &&\n    forall|i: int| 0 <= i < a.len() ==> #[trigger] final_schedule[i] >= a[i] &&\n    forall|i: int| 0 <= i < a.len() - 1 ==> #[trigger] final_schedule[i] + final_schedule[i + 1] >= k &&\n    additional_walks == sum(final_schedule) - sum(a)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: (i8, Vec<i8>))\n    requires valid_input(n as int, k as int, a@.map_values(|x: i8| x as int))\n    ensures valid_output(a@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int), result.0 as int, k as int)", "vc-code": "{\n    assume(false);\n    (0i8, Vec::<i8>::new())\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0077", "language": "verus", "source": "apps", "source_id": "apps_test_409", "vc-description": "Given a string s consisting of uppercase Latin letters, determine if it contains \ntwo non-overlapping substrings \"AB\" and \"BA\". Return \"YES\" if both substrings \nexist without overlapping, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        0\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        1 + count_substring(s.subrange(1, s.len() as int), pattern)\n    } else {\n        count_substring(s.subrange(1, s.len() as int), pattern)\n    }\n}\n\nspec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        -1\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        0\n    } else {\n        let rest = find_index(s.subrange(1, s.len() as int), pattern);\n        if rest == -1 { -1 } else { 1 + rest }\n    }\n}\n\nspec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {\n    let ab_pattern = seq!['A', 'B'];\n    let ba_pattern = seq!['B', 'A'];\n    let ab_index = find_index(s, ab_pattern);\n    let ba_index = find_index(s, ba_pattern);\n\n    (ab_index >= 0 && ba_index >= 0) &&\n    (\n        (ab_index >= 0 && ab_index + 2 < s.len() && count_substring(s.subrange(ab_index + 2, s.len() as int), ba_pattern) > 0) ||\n        (ba_index >= 0 && ba_index + 2 < s.len() && count_substring(s.subrange(ba_index + 2, s.len() as int), ab_pattern) > 0)\n    )\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        has_non_overlapping_ab_and_ba(input@) <==> result@ == seq!['Y', 'E', 'S']", "vc-code": "{\n    // impl-start\n    assume(false);\n    vec!['N', 'O']\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0078", "language": "verus", "source": "apps", "source_id": "apps_test_433", "vc-description": "Given a circular building with n entrances numbered 1 to n, determine the final entrance\nnumber after walking from entrance a by b entrances. Positive b means walking forward\n(increasing order), negative b means walking backward (decreasing order), and b=0 means\nstaying at the starting entrance.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, a: int, b: int) -> bool {\n        n >= 1 && 1 <= a <= n && -100 <= b <= 100\n    }\n    \n    spec fn final_entrance(n: int, a: int, b: int) -> int {\n        ((a - 1 + b) % n + n) % n + 1\n    }\n    \n    spec fn valid_output(result: int, n: int) -> bool {\n        1 <= result <= n\n    }", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(n as int, a as int, b as int)\n    ensures \n        valid_output(result as int, n as int),\n        result as int == final_entrance(n as int, a as int, b as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0079", "language": "verus", "source": "apps", "source_id": "apps_test_440", "vc-description": "Given a string of lowercase Latin letters, repeatedly remove consecutive vowels \nby deleting the second vowel in each consecutive pair until no consecutive vowels remain.\nVowels are defined as: a, e, i, o, u, y. Process the string from left to right.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_vowel(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'\n}\n\nspec fn no_consecutive_vowels(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() - 1 ==> !(is_vowel(#[trigger] s[i]) && is_vowel(s[i+1]))\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {\n    output.len() <= input.len() &&\n    no_consecutive_vowels(output) &&\n    (input.len() > 0 ==> output.len() > 0) &&\n    (input.len() > 0 ==> output[0] == input[0])\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    ensures valid_output(s@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0080", "language": "verus", "source": "apps", "source_id": "apps_test_442", "vc-description": "Given a hash function H(x,y) = x² + 2xy + x + 1 where x and y are positive integers,\ndetermine if there exists a pair of positive integers (x,y) such that H(x,y) = r \nfor a given positive integer r. If such a pair exists, return the pair (x,y) with \nthe smallest possible value of x. If no such pair exists, return empty sequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn h(x: int, y: int) -> int {\n    x * x + 2 * x * y + x + 1\n}\n\nspec fn valid_input(r: int) -> bool {\n    r > 0\n}\n\nspec fn valid_solution(result: Seq<int>, r: int) -> bool {\n    if result.len() == 0 {\n        true\n    } else {\n        result.len() == 2 && result[0] > 0 && result[1] > 0 && h(result[0], result[1]) == r\n    }\n}\n\nspec fn has_solution(r: int) -> bool {\n    r > 4 && r % 2 == 1\n}", "vc-helpers": "", "vc-spec": "fn solve(r: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(r as int)\n    ensures \n        valid_solution(result@.map(|i: int, x: i8| x as int), r as int),\n        result@.len() == 0 || result@.len() == 2,\n        result@.len() == 2 ==> result@[0] as int > 0 && result@[1] as int > 0,\n        result@.len() == 2 ==> h(result@[0] as int, result@[1] as int) == r as int,\n        r as int <= 4 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 0 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 1 ==> result@.len() == 2 && result@[0] as int == 1 && result@[1] as int == ((r as int) - 3) / 2,", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0081", "language": "verus", "source": "apps", "source_id": "apps_test_443", "vc-description": "Given n packets of balloons, divide all packets between two people such that:\n1. Each person gets at least one packet\n2. All packets are distributed \n3. The total number of balloons each person receives is different\nFind any valid distribution or return empty sequence if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, packets: Seq<int>) -> bool {\n    n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1\n}\n\nspec fn is_possible(n: int, packets: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    n >= 2 && (n > 2 || packets[0] != packets[1])\n}\n\nspec fn sum_packets(packets: Seq<int>) -> int\n    decreases packets.len()\n{\n    if packets.len() == 0 {\n        0\n    } else {\n        packets[0] + sum_packets(packets.subrange(1, packets.len() as int))\n    }\n}\n\nspec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    if !is_possible(n, packets) {\n        result.len() == 0\n    } else {\n        result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&\n        exists|min_index: int| 0 <= min_index < packets.len() && \n        result[1] == min_index + 1 &&\n        (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&\n        (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, packets: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))\n    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0082", "language": "verus", "source": "apps", "source_id": "apps_test_448", "vc-description": "Given n children numbered 1 to n, where child i needs at least a_i candies.\nChildren initially line up in order 1, 2, ..., n.\nDistribution algorithm:\n1. Give m candies to the first child in line\n2. If the child has received enough candies (≥ a_i), they go home\n3. Otherwise, the child goes to the end of the line\n4. Repeat until all children go home\nFind which child goes home last.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n > 0 && m > 0 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] > 0\n}\n\nspec fn valid_result(result: int, n: int) -> bool {\n    1 <= result <= n\n}\n\nspec fn sum_candies_still_needed(queue: Seq<Seq<int>>) -> nat\n    decreases queue.len()\n{\n    if queue.len() == 0 {\n        0nat\n    } else {\n        let child = queue[0];\n        let still_needed = if child.len() >= 2 && child[1] <= child[0] { 0nat } else if child.len() >= 2 { (child[1] - child[0]) as nat } else { 0nat };\n        still_needed + sum_candies_still_needed(queue.subrange(1, queue.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, m as int, a@.map_values(|x: i8| x as int))\n    ensures valid_result(result as int, n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0083", "language": "verus", "source": "apps", "source_id": "apps_test_449", "vc-description": "Given an integer n representing dollars, find the minimum number of bills \nneeded to represent this amount using denominations of $1, $5, $10, $20, and $100.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int) -> bool {\n        n >= 1\n    }\n    \n    spec fn min_bills(n: int) -> int\n        recommends n >= 1\n    {\n        n / 100 + (n % 100) / 20 + ((n % 100) % 20) / 10 + (((n % 100) % 20) % 10) / 5 + ((((n % 100) % 20) % 10) % 5)\n    }", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int)\n    ensures \n        result >= 0,\n        result as int == min_bills(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\n\nfn main() {}"}
{"id": "VA0084", "language": "verus", "source": "apps", "source_id": "apps_test_461", "vc-description": "Find the minimum distance Winnie-the-Pooh must travel to have n meals.\nWinnie starts at Rabbit's house and has his first meal there.\nThere are 3 houses: Rabbit, Owl, and Eeyore, forming a triangle.\nDistances: Rabbit↔Owl = a meters, Rabbit↔Eeyore = b meters, Owl↔Eeyore = c meters.\nAfter each meal, Winnie must leave the current house and go to one of the two adjacent houses.\nHe needs n meals total, so he makes (n-1) moves.\nFind the minimum total distance for all moves.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, c: int) -> bool {\n    1 <= n <= 100 && 1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nspec fn min_distance(n: int, a: int, b: int, c: int) -> int\n    recommends valid_input(n, a, b, c)\n{\n    if n == 1 { 0 } else { (n - 1) * min(a, b) }\n}\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn max(x: int, y: int) -> int {\n    if x >= y { x } else { y }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(n as int, a as int, b as int, c as int)\n    ensures \n        result >= 0,\n        n == 1 ==> result == 0,\n        result as int <= (n as int - 1) * max(a as int, max(b as int, c as int)),\n        result as int == min_distance(n as int, a as int, b as int, c as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0085", "language": "verus", "source": "apps", "source_id": "apps_test_462", "vc-description": "Given three distinct integers representing positions of three friends on a number line,\nfind the minimum total distance they need to travel to meet at a single point.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(x1: int, x2: int, x3: int) -> bool {\n    1 <= x1 <= 100 && 1 <= x2 <= 100 && 1 <= x3 <= 100 &&\n    x1 != x2 && x1 != x3 && x2 != x3\n}\n\nspec fn min_total_distance(x1: int, x2: int, x3: int) -> int\n    recommends valid_input(x1, x2, x3)\n{\n    let max_pos = if x1 >= x2 && x1 >= x3 { x1 }\n                  else if x2 >= x1 && x2 >= x3 { x2 }\n                  else { x3 };\n    let min_pos = if x1 <= x2 && x1 <= x3 { x1 }\n                  else if x2 <= x1 && x2 <= x3 { x2 }\n                  else { x3 };\n    max_pos - min_pos\n}", "vc-helpers": "", "vc-spec": "fn find_minimum_total_distance(x1: i8, x2: i8, x3: i8) -> (result: i8)\n    requires \n        valid_input(x1 as int, x2 as int, x3 as int)\n    ensures \n        result as int == min_total_distance(x1 as int, x2 as int, x3 as int),\n        result >= 1 && result <= 99", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0086", "language": "verus", "source": "apps", "source_id": "apps_test_470", "vc-description": "Given 5 cards with positive integers, find the minimum sum of remaining cards \nafter optionally discarding exactly 2 or 3 cards that have the same number \n(at most one such discard operation allowed).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() == 5 && forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0\n}\n\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int \n    decreases index when index >= 0\n{\n    if index <= 0 {\n        sum(cards)\n    } else {\n        min_possible_sum_up_to_index(cards, index - 1)\n    }\n}\n\nspec fn min_possible_sum(cards: Seq<int>) -> int {\n    min_possible_sum_up_to_index(cards, 5)\n}", "vc-helpers": "", "vc-spec": "fn solve(cards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(cards@.map(|_index, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int <= sum(cards@.map(|_index, x: i8| x as int)),\n        result as int == min_possible_sum(cards@.map(|_index, x: i8| x as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0087", "language": "verus", "source": "apps", "source_id": "apps_test_472", "vc-description": "Given a positive integer n, find the smallest positive integer x such that\nx² + s(x)·x - n = 0, where s(x) is the sum of digits of x in decimal notation.\nIf no such positive integer x exists, return -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn digit_sum(n: int) -> int\n  decreases n when n >= 0\n{\n  if n <= 0 { \n    0 \n  } else { \n    (n % 10) + digit_sum(n / 10) \n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n  requires \n    n >= 1,\n  ensures \n    n == 1 ==> result == -1,\n    n > 1 && result > 0 ==> (result as int) * (result as int) + digit_sum(result as int) * (result as int) == n as int,\n    n > 1 && result > 0 ==> forall|y: int| y > 0 && y < result as int ==> y * y + digit_sum(y) * y != n as int,\n    n > 1 && result == -1 ==> forall|x: int| x > 0 ==> x * x + digit_sum(x) * x != n as int,\n    result == -1 || result > 0,", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0088", "language": "verus", "source": "apps", "source_id": "apps_test_473", "vc-description": "Given a wake-up time and sleep duration, both in \"hh:mm\" 24-hour format,\ncalculate the bedtime by subtracting the sleep duration from the wake-up time.\nHandle day wrap-around when the bedtime falls on the previous day.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_time_format(time_str: Seq<char>) -> bool {\n    time_str.len() == 5 &&\n    time_str[2] == ':' &&\n    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&\n    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&\n    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&\n    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int {\n    choose|i: int| 0 <= i < s.len() && s[i] == '\\n'\n}\n\nspec fn find_second_newline(s: Seq<char>, first: int) -> int {\n    choose|i: int| first < i < s.len() && s[i] == '\\n'\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n' &&\n    exists|i: int, j: int| 0 <= i < j < stdin_input.len() && stdin_input[i] == '\\n' && stdin_input[j] == '\\n' &&\n    {\n        let first_nl = find_first_newline(stdin_input);\n        let second_nl = find_second_newline(stdin_input, first_nl);\n        let s = stdin_input.subrange(0, first_nl);\n        let t = stdin_input.subrange(first_nl + 1, second_nl);\n        valid_time_format(s) && valid_time_format(t)\n    }\n}\n\nspec fn parse_time(time_str: Seq<char>) -> (int, int) {\n    let h = (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);\n    let m = (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);\n    (h, m)\n}\n\nspec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {\n    let wake_total_min = wake_hour * 60 + wake_min;\n    let sleep_total_min = sleep_hour * 60 + sleep_min;\n    let diff = wake_total_min - sleep_total_min;\n    let bed_total_min = if diff >= 0 { diff } else { diff + 24 * 60 };\n    (bed_total_min / 60, bed_total_min % 60)\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() == 6 &&\n    result[result.len() - 1] == '\\n' &&\n    result[2] == ':' &&\n    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&\n    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&\n    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&\n    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59\n}\n\nspec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let first_nl = find_first_newline(stdin_input);\n    let second_nl = find_second_newline(stdin_input, first_nl);\n    let s = stdin_input.subrange(0, first_nl);\n    let t = stdin_input.subrange(first_nl + 1, second_nl);\n    let (wake_hour, wake_min) = parse_time(s);\n    let (sleep_hour, sleep_min) = parse_time(t);\n    let (bed_hour, bed_min) = calculate_bedtime(wake_hour, wake_min, sleep_hour, sleep_min);\n    let result_hour = (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);\n    let result_min = (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);\n    result_hour == bed_hour && result_min == bed_min\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        valid_output(result@) &&\n        correct_bedtime(stdin_input@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0089", "language": "verus", "source": "apps", "source_id": "apps_test_475", "vc-description": "Count the number of ways to paint n bricks in a row using m colors such that exactly k bricks \nhave a different color than the brick immediately to their left. The first brick is not counted \nin this comparison. Result should be modulo 998,244,353.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat, m: nat, k: nat) -> bool {\n    n >= 1 && m >= 1 && k >= 0 && k <= n - 1\n}\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 }\n    else { n * factorial((n - 1) as nat) }\n}\n\nspec fn binomial(n: nat, k: nat) -> nat\n    decreases n\n{\n    if k > n { 0 }\n    else if factorial(k) == 0 || factorial((n - k) as nat) == 0 { 0 }\n    else { factorial(n) / (factorial(k) * factorial((n - k) as nat)) }\n}\n\nspec fn power(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 }\n    else { base * power(base, (exp - 1) as nat) }\n}\n\nspec fn expected_result(n: nat, m: nat, k: nat) -> nat {\n    if valid_input(n, m, k) {\n        (m * power((m - 1) as nat, k) * binomial((n - 1) as nat, k)) % 998244353\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u64, m: u64, k: u64) -> (result: u64)\n    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1\n    ensures result < 998244353", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0090", "language": "verus", "source": "apps", "source_id": "apps_test_483", "vc-description": "Given n particles on a line at distinct even-integer positions, where each particle moves \nleft (L) or right (R) at speed 1 unit per microsecond, find the time of the first collision \nbetween any two particles, or return -1 if no collision occurs.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {\n    n >= 1 &&\n    directions.len() == n &&\n    positions.len() == n &&\n    (forall|i: int| 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&\n    (forall|i: int| 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> positions[i] < positions[j])\n}\n\nspec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {\n    0 <= i < directions.len()-1 && \n    directions[i] == 'R' && directions[i+1] == 'L'\n}\n\nspec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool \n    recommends directions.len() == positions.len()\n{\n    exists|i: int| #[trigger] has_collision_pair(i, directions)\n}\n\nspec fn collision_time(i: int, positions: Seq<int>) -> int\n    recommends 0 <= i < positions.len()-1\n{\n    (positions[i+1] - positions[i]) / 2\n}\n\nspec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool\n    recommends directions.len() == positions.len()\n{\n    (forall|i: int| has_collision_pair(i, directions) ==> \n        collision_time(i, positions) >= result) &&\n    (exists|i: int| #[trigger] has_collision_pair(i, directions) && \n        collision_time(i, positions) == result)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, directions: Vec<char>, positions: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n    ensures \n        result == -1 || result >= 0,\n        result != -1 ==> has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result == -1 ==> !has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result != -1 ==> is_minimal_collision_time(result as int, directions@, positions@.map(|i: int, v: i8| v as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0091", "language": "verus", "source": "apps", "source_id": "apps_test_484", "vc-description": "Given a rectangular piece of paper of dimensions a × b and n rectangular seals with dimensions x_i × y_i,\nfind the maximum total area that can be covered by placing exactly two different seals on the paper.\nEach seal can be rotated 90 degrees, and the impressions must not overlap (but can touch).\nIf no two seals can fit on the paper, return 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int\n{\n    let orientations = seq![(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];\n\n    let area0 = if can_fit(orientations[0].0, orientations[0].1, a, b) {\n        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1\n    } else {\n        0\n    };\n\n    let area1 = if can_fit(orientations[1].0, orientations[1].1, a, b) {\n        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1\n    } else {\n        0\n    };\n\n    let area2 = if can_fit(orientations[2].0, orientations[2].1, a, b) {\n        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1\n    } else {\n        0\n    };\n\n    let area3 = if can_fit(orientations[3].0, orientations[3].1, a, b) {\n        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1\n    } else {\n        0\n    };\n\n    max_spec(max_spec(area0, area1), max_spec(area2, area3))\n}\n\nspec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool\n{\n    (r1.0 + r2.0 <= a && max_spec(r1.1, r2.1) <= b) || (max_spec(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)\n}\n\nspec fn max_spec(x: int, y: int) -> int\n{\n    if x >= y { x } else { y }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8, seals: Vec<(i8, i8)>) -> (result: i8)\n    requires n >= 0,\n            a >= 1 && b >= 1,\n            seals.len() == n as nat,\n            forall|i: int| 0 <= i < n as int ==> seals@[i].0 as int >= 1 && seals@[i].1 as int >= 1,\n    ensures result as int >= 0,\n            result as int == 0 ==> (forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == 0),\n            result as int > 0 ==> (exists|i: int, j: int| 0 <= i < n as int && i < j < n as int && check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == result as int),\n            forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) <= result as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0092", "language": "verus", "source": "apps", "source_id": "apps_test_486", "vc-description": "Given a positive integer n, find the maximum product of digits among all integers from 1 to n inclusive.\nThe product of digits is calculated by multiplying all individual digits together.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn product_of_digits(x: int) -> int\n  recommends x >= 0\n  decreases x\n{\n  if x == 0 { 1 }\n  else if x < 10 { x }\n  else { (x % 10) * product_of_digits(x / 10) }\n}\n\nspec fn max_product_of_digits_in_range(n: int) -> int\n  recommends n >= 1\n  decreases n\n  when n >= 1\n{\n  if n == 1 { 1 }\n  else {\n    let current = product_of_digits(n);\n    let rest = max_product_of_digits_in_range(n - 1);\n    if current > rest { current } else { rest }\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n  requires \n    n >= 1\n  ensures \n    result as int == max_product_of_digits_in_range(n as int),\n    result >= 1,\n    forall|k: int| 1 <= k <= n as int ==> product_of_digits(k) <= result as int,\n    exists|k: int| 1 <= k <= n as int && product_of_digits(k) == result as int", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0093", "language": "verus", "source": "apps", "source_id": "apps_test_491", "vc-description": "Given an integer n representing a bank account balance, perform at most one operation:\ndelete the last digit, delete the digit before the last digit, or do nothing.\nFind the maximum possible balance after performing the operation.\nConstraint: absolute value of n is at least 10.\n\n/* delete last digit */\n\n/* delete digit before last */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 10 || n <= -10\n}\n\nspec fn max_balance_after_operation(n: int) -> int\n    recommends valid_input(n)\n{\n    if n >= 0 {\n        n\n    } else {\n        /* For negative numbers, we need to delete either the last digit\n           or the digit before the last digit to maximize the balance.\n           Since this involves string operations that are not easily\n           expressible in pure logic, we use a simplified specification. */\n        let option1 = n / 10;\n        let option2 = (n / 100) * 10 + (n % 10);\n        if option1 > option2 { option1 } else { option2 }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures result as int == max_balance_after_operation(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0094", "language": "verus", "source": "apps", "source_id": "apps_test_492", "vc-description": "A spinner has 4 positions encoded as v, >, ^, < (representing positions 0, 1, 2, 3 respectively).\nThe spinner rotates by changing position every second, either clockwise or counter-clockwise.\nGiven the starting position, ending position, and rotation duration n seconds, determine the rotation direction.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn char_to_pos_spec(c: Seq<char>) -> int {\n    if c.len() == 1 && c[0] == 'v' { 0 }\n    else if c.len() == 1 && c[0] == '>' { 1 }\n    else if c.len() == 1 && c[0] == '^' { 2 }\n    else if c.len() == 1 && c[0] == '<' { 3 }\n    else { 0 }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result == seq!['c', 'w'] || result == seq!['c', 'c', 'w'] || result == seq!['u', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd']\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures valid_output(result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"undefined\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0095", "language": "verus", "source": "apps", "source_id": "apps_test_498", "vc-description": "Given a classroom with n lanes and m desks per lane, where each desk has 2 seats (left and right),\nfind the lane, desk, and side for seat number k. Seats are numbered 1 to 2nm in order:\nby lane first, then by desk within each lane, then left seat before right seat within each desk.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n    1 <= n <= 10000 && 1 <= m <= 10000 && 1 <= k <= 2 * n * m\n}\n\nspec fn valid_output(n: int, m: int, lane: int, desk: int, side: char) -> bool {\n    1 <= lane <= n && 1 <= desk <= m && (side == 'L' || side == 'R')\n}\n\nspec fn correct_solution(n: int, m: int, k: int, lane: int, desk: int, side: char) -> bool\n    recommends valid_input(n, m, k)\n{\n    lane == (k - 1) / (2 * m) + 1 &&\n    desk == (k - 1) % (2 * m) / 2 + 1 &&\n    (side == 'L' <==> (k - 1) % (2 * m) % 2 == 0)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i32, m: i32, k: i32) -> (result: (i32, i32, char))\n    requires valid_input(n as int, m as int, k as int)\n    ensures ({\n        let (lane, desk, side) = result;\n        valid_output(n as int, m as int, lane as int, desk as int, side) &&\n        correct_solution(n as int, m as int, k as int, lane as int, desk as int, side)\n    })", "vc-code": "{\n    assume(false);\n    (0, 0, 'L')\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0098", "language": "verus", "source": "apps", "source_id": "apps_test_506", "vc-description": "Given a rectangular sheet of paper with dimensions a × b millimeters (where a > b),\ndetermine how many square pieces can be cut from it using the following process:\n1. From the current rectangle, cut the largest possible square\n2. Continue with the remaining rectangular strip (if any exists)  \n3. Repeat until only a square remains\n4. Count the total number of squares cut", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 0 && b > 0\n}\n\nspec fn count_squares(a: int, b: int) -> int\n    recommends a >= 0 && b >= 0\n    decreases a + b when a > 0 && b > 0\n{\n    if a == 0 || b == 0 {\n        0\n    } else if a > b {\n        if b == 0 { 0 } else {\n            a / b + count_squares(a % b, b)\n        }\n    } else if b > a {\n        if a == 0 { 0 } else {\n            b / a + count_squares(a, b % a)\n        }\n    } else {\n        1\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures \n        result >= 0,\n        a == b ==> result == 1,\n        a > b ==> result >= 1,\n        result as int == count_squares(a as int, b as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0100", "language": "verus", "source": "apps", "source_id": "apps_test_511", "vc-description": "Given a function f(a, b) defined as f(a, 0) = 0 and f(a, b) = 1 + f(a, b - gcd(a, b)) for b > 0,\ncalculate f(x, y) for given integers x and y. The input is a string containing two integers\nseparated by a space, and the output is a string containing the result.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == ' ') &&\n    (forall|j: int| 0 <= j < input.len() ==> \n        ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\\n'))\n}\n\nspec fn gcd(a: nat, b: nat) -> nat \n    decreases a + b\n{\n    if a == 0 { b }\n    else if b == 0 { a }\n    else if a > b { gcd((a - b) as nat, b) }\n    else { gcd(a, (b - a) as nat) }\n}\n\n#[verifier::opaque]\nspec fn f_mathematical(x: nat, y: nat) -> nat\n    decreases y\n{\n    y / 2\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (forall|i: int| 0 <= i < result.len() ==> \n        ('0' <= result[i] <= '9' || result[i] == '\\n')) &&\n    result[result.len() - 1] == '\\n'\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0101", "language": "verus", "source": "apps", "source_id": "apps_test_520", "vc-description": "Given a list of university entrance years for groups that student Igor joined,\ndetermine Igor's entrance year. Igor joins his own group and all groups\nwhere the entrance year differs by at most x years from his entrance year.\nThe solution computes Igor's entrance year as the average of all group years.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_range(s: Seq<int>, start: int, end: int) -> int\n    decreases end - start when 0 <= start <= end <= s.len()\n{\n    if start == end {\n        0\n    } else {\n        s[start] + sum_range(s, start + 1, end)\n    }\n}\n\nspec fn valid_input(n: int, years: Seq<int>) -> bool\n{\n    n > 0 && years.len() == n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, years: Vec<i8>) -> (result: i8)\n    requires n > 0 && years.len() == n as nat\n    ensures result as int == sum_range(years@.map(|i, x| x as int), 0, years.len() as int) / (n as int)", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0102", "language": "verus", "source": "apps", "source_id": "apps_test_529", "vc-description": "Given a string and an integer n (0 ≤ n ≤ 26), transform the string by:\n1. Converting the entire string to lowercase\n2. For each character, if it is lexicographically smaller than the nth letter \n   of the alphabet (0-indexed), convert it to uppercase; otherwise, keep it lowercase\n3. When n = 26, use '|' as the comparison character (which comes after 'z')", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>, n: int) -> bool {\n  0 <= n <= 26\n}\n\nspec fn get_comparison_char(n: int) -> char {\n  if n == 0 { 'a' }\n  else if n == 1 { 'b' }\n  else if n == 2 { 'c' }\n  else if n == 3 { 'd' }\n  else if n == 4 { 'e' }\n  else if n == 5 { 'f' }\n  else if n == 6 { 'g' }\n  else if n == 7 { 'h' }\n  else if n == 8 { 'i' }\n  else if n == 9 { 'j' }\n  else if n == 10 { 'k' }\n  else if n == 11 { 'l' }\n  else if n == 12 { 'm' }\n  else if n == 13 { 'n' }\n  else if n == 14 { 'o' }\n  else if n == 15 { 'p' }\n  else if n == 16 { 'q' }\n  else if n == 17 { 'r' }\n  else if n == 18 { 's' }\n  else if n == 19 { 't' }\n  else if n == 20 { 'u' }\n  else if n == 21 { 'v' }\n  else if n == 22 { 'w' }\n  else if n == 23 { 'x' }\n  else if n == 24 { 'y' }\n  else if n == 25 { 'z' }\n  else { '|' }\n}\n\nspec fn is_lowercase(c: char) -> bool {\n  'a' <= c && c <= 'z'\n}\n\nspec fn is_uppercase(c: char) -> bool {\n  'A' <= c && c <= 'Z'\n}\n\nspec fn to_lowercase(c: char) -> char {\n  if is_uppercase(c) {\n    ((c as u8) - ('A' as u8) + ('a' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn to_uppercase(c: char) -> char {\n  if is_lowercase(c) {\n    ((c as u8) - ('a' as u8) + ('A' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {\n  let comp_char = get_comparison_char(n);\n  transform_with_comp_char(to_lowercase_string(s), comp_char)\n}\n\nspec fn to_lowercase_string(s: Seq<char>) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else {\n    s.subrange(0, 1).map(|_i: int, c: char| to_lowercase(c)) + to_lowercase_string(s.skip(1))\n  }\n}\n\nspec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else if s[0] < comp_char {\n    s.subrange(0, 1).map(|_i: int, c: char| to_uppercase(c)) + transform_with_comp_char(s.skip(1), comp_char)\n  } else {\n    s.subrange(0, 1) + transform_with_comp_char(s.skip(1), comp_char)\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>, n: i8) -> (result: Vec<char>)\n  requires valid_input(s@, n as int)\n  ensures result@ == transform_string(s@, n as int)", "vc-code": "{\n  // impl-start\n  assume(false);\n  s\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0103", "language": "verus", "source": "apps", "source_id": "apps_test_530", "vc-description": "Two players play a game with binary strings. They alternate turns choosing positions\nfrom strings of length 2n, collecting characters to form the largest possible binary\nnumbers. Determine the winner with optimal play.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {\n    n > 0 && a.len() == 2 * n && b.len() == 2 * n &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] == '0' || a[i] == '1') &&\n    (forall|i: int| 0 <= i < b.len() ==> b[i] == '0' || b[i] == '1')\n}\n\nspec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int\n    recommends len >= 0 && len <= a.len() && len <= b.len(),\n               ac == '0' || ac == '1',\n               bc == '0' || bc == '1'\n{\n    Set::new(|i: int| 0 <= i < len && a[i] == ac && b[i] == bc).len() as int\n}\n\nspec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {\n    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2\n}\n\nspec fn correct_outcome(result: &str, d: int) -> bool {\n    (d > 0 ==> result == \"First\") &&\n    (d < 0 ==> result == \"Second\") &&\n    (d == 0 ==> result == \"Draw\")\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<char>, b: Vec<char>) -> (result: &'static str)\n    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&\n             (forall|i: int| 0 <= i < a@.len() ==> a@[i] == '0' || a@[i] == '1') &&\n             (forall|i: int| 0 <= i < b@.len() ==> b@[i] == '0' || b@[i] == '1')\n    ensures result == \"First\" || result == \"Second\" || result == \"Draw\"", "vc-code": "{\n    assume(false);\n    \"Draw\"\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0104", "language": "verus", "source": "apps", "source_id": "apps_test_533", "vc-description": "Given two football teams with a1 and a2 players respectively, where players from team 1\nare sent off after k1 yellow cards and players from team 2 are sent off after k2 yellow cards.\nA total of n yellow cards were shown during the match. Find the minimum and maximum number\nof players that could have been sent off.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {\n    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1\n}\n\nspec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    let max_non_sendoff_cards = (k1 - 1) * a1 + (k2 - 1) * a2;\n    if n - max_non_sendoff_cards > 0 { n - max_non_sendoff_cards } else { 0 }\n}\n\nspec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    if k1 < k2 {\n        let team1_sent = if n / k1 < a1 { n / k1 } else { a1 };\n        let remaining_cards = n - team1_sent * k1;\n        team1_sent + remaining_cards / k2\n    } else {\n        let team2_sent = if n / k2 < a2 { n / k2 } else { a2 };\n        let remaining_cards = n - team2_sent * k2;\n        team2_sent + remaining_cards / k1\n    }\n}\n\nspec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    minimum >= 0 && maximum >= 0 &&\n    minimum <= maximum &&\n    maximum <= a1 + a2 &&\n    minimum <= n &&\n    maximum <= n &&\n    minimum == minimum_sent_off(a1, a2, k1, k2, n) &&\n    maximum == maximum_sent_off(a1, a2, k1, k2, n)\n}", "vc-helpers": "", "vc-spec": "fn solve(a1: i8, a2: i8, k1: i8, k2: i8, n: i8) -> (ret: (i8, i8))\n    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)\n    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0105", "language": "verus", "source": "apps", "source_id": "apps_test_537", "vc-description": "Given n students and a ratio k, distribute awards (diplomas and certificates) to maximize \nthe number of winners while following constraints: certificates = k × diplomas, \ntotal winners ≤ n/2. Output the number of diplomas, certificates, and non-winners.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 0 && k >= 0 && k + 1 > 0\n}\n\nspec fn valid_output(result: Seq<int>, n: int, k: int) -> bool {\n    result.len() == 3 &&\n    result[0] >= 0 && result[1] >= 0 && result[2] >= 0 &&\n    result[1] == result[0] * k &&\n    result[0] + result[1] <= n / 2 &&\n    result[2] == n - result[0] - result[1]\n}\n\nspec fn optimal_diplomas(n: int, k: int) -> int\n    recommends valid_input(n, k)\n{\n    (n / 2) / (k + 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires valid_input(n as int, k as int)\n    ensures \n        valid_output(result@.map(|i, x| x as int), n as int, k as int) &&\n        result@[0] as int == optimal_diplomas(n as int, k as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0108", "language": "verus", "source": "apps", "source_id": "apps_test_548", "vc-description": "Two players play a game on an array of integers, alternating turns.\nFirst player removes subsegments with odd sum, second player removes subsegments with even sum.\nAfter removal, remaining parts are concatenated. Player who cannot move loses.\nDetermine the winner assuming optimal play.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn all_even(a: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] % 2 == 0\n}\n\nspec fn has_odd(a: Seq<int>) -> bool {\n    exists|i: int| 0 <= i < a.len() && a[i] % 2 == 1\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>) -> (result: &'static str)\n    ensures \n        (result == \"Second\") <==> all_even(a@.map(|i: int, x: i8| x as int)),\n        (result == \"First\") <==> has_odd(a@.map(|i: int, x: i8| x as int)),\n        result == \"First\" || result == \"Second\",", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0109", "language": "verus", "source": "apps", "source_id": "apps_test_553", "vc-description": "Given n promotional codes (each exactly 6 digits), find the maximum number k such that \nany promotional code can be uniquely identified even when typed with at most k digit errors.\nThis requires finding the minimum Hamming distance between any pair of promotional codes,\nthen computing k = floor((min_distance - 1) / 2).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    6\n}\n\nspec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {\n    if s1 == s2 { 0 } else { 6 }\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {\n    output.len() >= 2 &&\n    output[output.len() - 1] == '\\n' &&\n    ({\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        ({\n            let n: int = 6;\n            n >= 1 && \n            n == 6 &&\n            lines.len() >= 1 &&\n            ({\n                let k: int = 6;\n                0 <= k <= 6 &&\n                k == 6 &&\n                parse_integer(output.subrange(0, output.len() - 1)) == k\n            })\n        })\n    })\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires valid_input(stdin_input@.map_values(|x: u8| x as char))\n    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0110", "language": "verus", "source": "apps", "source_id": "apps_test_566", "vc-description": "Given r red balloons, g green balloons, and b blue balloons, determine the maximum number of tables that can be decorated.\nEach table requires exactly 3 balloons, and no table can have all 3 balloons of the same color.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(r: int, g: int, b: int) -> bool {\n    r >= 0 && g >= 0 && b >= 0\n}\n\nspec fn max_tables(r: int, g: int, b: int) -> int\n    recommends valid_input(r, g, b)\n{\n    min(min(min((r + g + b) / 3, r + g), r + b), g + b)\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}", "vc-helpers": "", "vc-spec": "fn solve(r: i8, g: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(r as int, g as int, b as int)\n    ensures \n        result as int == max_tables(r as int, g as int, b as int),\n        result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0111", "language": "verus", "source": "apps", "source_id": "apps_test_569", "vc-description": "Given a string of lowercase English letters, find the minimum number of character \nchanges needed to make all substrings distinct. If the string length exceeds 26,\nit's impossible since we only have 26 distinct lowercase letters available.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n == s.len() && n >= 1\n}\n\nspec fn count_distinct_chars(s: Seq<char>) -> int {\n    s.to_set().len() as int\n}", "vc-helpers": "", "vc-spec": "fn solve(n: usize, s: Vec<char>) -> (result: i32)\n    requires \n        valid_input(n as int, s@)\n    ensures \n        n > 26 ==> result == -1,\n        n <= 26 ==> result >= 0 && result < n as i32,\n        n <= 26 ==> result == s@.len() as i32 - count_distinct_chars(s@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0112", "language": "verus", "source": "apps", "source_id": "apps_test_584", "vc-description": "Given a string containing letters, underscores, and properly matched parentheses,\nfind the length of the longest word outside parentheses and count words inside parentheses.\nWords are maximal sequences of consecutive letters separated by underscores or parentheses.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_letter(c: char) -> bool {\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\nspec fn valid_parentheses(input: Seq<char>) -> bool {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        true\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        is_valid_parentheses_sequence(s, 0, 0)\n    }\n}\n\nspec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool\n    recommends 0 <= pos <= s.len(), balance >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        balance == 0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            balance - 1 \n        } else { \n            balance \n        };\n        new_balance >= 0 && is_valid_parentheses_sequence(s, pos + 1, new_balance)\n    }\n}\n\nspec fn longest_word_outside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_longest_outside(s, 0, 0, 0, 0)\n    }\n}\n\nspec fn count_words_inside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_count_inside(s, 0, 0, 0)\n    }\n}\n\nspec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {\n    len_out >= 0 && count_in >= 0 &&\n    len_out == longest_word_outside(input) &&\n    count_in == count_words_inside(input)\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    find_newline_helper(input, 0)\n}\n\nspec fn find_newline_helper(input: Seq<char>, pos: int) -> int\n    recommends 0 <= pos <= input.len()\n    decreases input.len() - pos\n{\n    if pos >= input.len() {\n        pos\n    } else if input[pos] == '\\n' {\n        pos\n    } else {\n        find_newline_helper(input, pos + 1)\n    }\n}\n\nspec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        if cur > best && balance == 0 { cur } else { best }\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let new_best = if !is_letter(c) && cur > 0 && balance == 0 {\n            if cur > best { cur } else { best }\n        } else { \n            best \n        };\n        compute_longest_outside(s, pos + 1, new_balance, new_cur, new_best)\n    }\n}\n\nspec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let word_ended = !is_letter(c) && cur > 0;\n        let count_increment: int = if word_ended && balance > 0 { 1 } else { 0 };\n        count_increment + compute_count_inside(s, pos + 1, new_balance, new_cur)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: (usize, usize))\n    requires\n        input@.len() > 0,\n        exists|i: int| 0 <= i < input@.len() && input@[i] == '\\n',\n        forall|i: int| 0 <= i < input@.len() ==> (is_letter(input@[i]) || input@[i] == '_' || input@[i] == '(' || input@[i] == ')' || input@[i] == '\\n' || input@[i] == '\\r' || ('0' <= input@[i] <= '9')),\n        valid_parentheses(input@)\n    ensures\n        result.0 >= 0 && result.1 >= 0,\n        result.0 as int == longest_word_outside(input@),\n        result.1 as int == count_words_inside(input@),\n        valid_output(input@, result.0 as int, result.1 as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0113", "language": "verus", "source": "apps", "source_id": "apps_test_600", "vc-description": "Two friends at integer positions a and b on a number line need to meet at the same position.\nEach move costs increasing tiredness: 1st move costs 1, 2nd move costs 2, etc.\nFind the minimum total tiredness for both friends to meet.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a >= 1 && a <= 1000 && b >= 1 && b <= 1000 && a != b\n}\n\nspec fn optimal_meeting_point(a: int, b: int) -> int {\n    (a + b) / 2\n}\n\nspec fn tiredness_for_steps(steps: int) -> int\n    decreases steps\n{\n    if steps <= 0 { 0 } else { steps + tiredness_for_steps(steps - 1) }\n}\n\nspec fn minimum_total_tiredness(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n    let c = optimal_meeting_point(a, b);\n    tiredness_for_steps(if c >= a { c - a } else { a - c }) + \n    tiredness_for_steps(if b >= c { b - c } else { c - b })\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int),\n    ensures \n        result >= 0,\n        result as int == minimum_total_tiredness(a as int, b as int),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0115", "language": "verus", "source": "apps", "source_id": "apps_test_602", "vc-description": "Given an integer a (1 ≤ a ≤ 40), output the last name of the a-th President of the United States.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int) -> bool {\n    1 <= a <= 40\n}\n\nspec fn presidents() -> Seq<&'static str> {\n    seq![\n        \"Washington\", \"Adams\", \"Jefferson\", \"Madison\", \"Monroe\", \"Adams\", \"Jackson\", \n        \"Van Buren\", \"Harrison\", \"Tyler\", \"Polk\", \"Taylor\", \"Fillmore\", \"Pierce\", \n        \"Buchanan\", \"Lincoln\", \"Johnson\", \"Grant\", \"Hayes\", \"Garfield\", \"Arthur\", \n        \"Cleveland\", \"Harrison\", \"Cleveland\", \"McKinley\", \"Roosevelt\", \"Taft\", \n        \"Wilson\", \"Harding\", \"Coolidge\", \"Hoover\", \"Roosevelt\", \"Truman\", \n        \"Eisenhower\", \"Kennedy\", \"Johnson\", \"Nixon\", \"Ford\", \"Carter\", \"Reagan\"\n    ]\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8) -> (result: &'static str)\n    requires valid_input(a as int)\n    ensures result == presidents()[(a as int) - 1]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0116", "language": "verus", "source": "apps", "source_id": "apps_test_604", "vc-description": "Given an array of integers, find the minimum number of seconds needed to make all elements zero.\nIn each second, you can add an arbitrary integer to all non-zero elements in the array.\nThe key insight is that the answer equals the number of distinct non-zero values in the array.\n\n/* No specific constraints on input beyond being a sequence of integers */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(arr: Seq<int>) -> bool {\n    true\n}\n\nspec fn distinct_non_zero_count(arr: Seq<int>) -> int {\n    Set::<int>::new(|x: int| arr.contains(x) && x != 0).len() as int\n}", "vc-helpers": "spec fn vec_to_seq_int(arr: Vec<i8>) -> Seq<int> {\n    arr@.map(|i, x| x as int)\n}\n", "vc-spec": "fn solve(arr: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(vec_to_seq_int(arr))\n    ensures \n        result >= 0,\n        result as int <= arr@.len(),\n        result as int == distinct_non_zero_count(vec_to_seq_int(arr))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0117", "language": "verus", "source": "apps", "source_id": "apps_test_605", "vc-description": "Compare scores of two contestants Misha and Vasya in a programming contest.\nMisha solved a problem worth 'a' points and submitted it 'c' minutes after start.\nVasya solved a problem worth 'b' points and submitted it 'd' minutes after start.\nScoring formula: max(3p/10, p - p*t/250) where p is original points, t is time.\nReturn \"Misha\", \"Vasya\", or \"Tie\" based on who scored higher.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    250 <= a <= 3500 && a % 250 == 0 &&\n    250 <= b <= 3500 && b % 250 == 0 &&\n    0 <= c <= 180 &&\n    0 <= d <= 180\n}\n\nspec fn calculate_score(points: int, time: int) -> int {\n    let min_score = 3 * points / 10;\n    let time_adjusted = points - points * time / 250;\n    if min_score >= time_adjusted { min_score } else { time_adjusted }\n}\n\nspec fn correct_result(a: int, b: int, c: int, d: int, result: Seq<char>) -> bool {\n    let misha_score = calculate_score(a, c);\n    let vasya_score = calculate_score(b, d);\n    (result == seq!['M','i','s','h','a'] <==> misha_score > vasya_score) &&\n    (result == seq!['V','a','s','y','a'] <==> vasya_score > misha_score) &&\n    (result == seq!['T','i','e'] <==> misha_score == vasya_score)\n}", "vc-helpers": "", "vc-spec": "fn determine_winner(a: i8, b: i8, c: i8, d: i8) -> (result: String)\n    requires \n        valid_input(a as int, b as int, c as int, d as int)\n    ensures \n        result@ == seq!['M','i','s','h','a'] || result@ == seq!['V','a','s','y','a'] || result@ == seq!['T','i','e'],\n        correct_result(a as int, b as int, c as int, d as int, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0119", "language": "verus", "source": "apps", "source_id": "apps_test_610", "vc-description": "Given n red cubes and m blue cubes, two players take turns placing cubes in a line.\nPetya moves first and wants to maximize same-color adjacent pairs.\nVasya moves second and wants to maximize different-color adjacent pairs.\nBoth players play optimally. Calculate final scores for both players.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 1 && m >= 1\n}\n\nspec fn optimal_vasya_score(n: int, m: int) -> int {\n    if n < m { n } else { m }\n}\n\nspec fn optimal_petya_score(n: int, m: int) -> int {\n    n + m - 1 - optimal_vasya_score(n, m)\n}\n\nspec fn total_adjacent_pairs(n: int, m: int) -> int {\n    n + m - 1\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: (i8, i8))\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        result.0 as int == optimal_petya_score(n as int, m as int) &&\n        result.1 as int == optimal_vasya_score(n as int, m as int) &&\n        result.0 as int + result.1 as int == total_adjacent_pairs(n as int, m as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0120", "language": "verus", "source": "apps", "source_id": "apps_test_613", "vc-description": "Find the number of polynomials P(x) with non-negative integer coefficients \nsuch that P(t) = a and P(P(t)) = b, where t, a, and b are given positive integers.\nSince P(t) = a, the second condition becomes P(a) = b.\nOutput \"inf\" if infinitely many such polynomials exist, otherwise output the count.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(t: int, a: int, b: int) -> bool {\n    t > 0 && a > 0 && b > 0\n}\n\nspec fn valid_output(res: String) -> bool {\n    res@ == \"0\"@ || res@ == \"1\"@ || res@ == \"2\"@ || res@ == \"inf\"@\n}\n\nspec fn infinite_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a == 1\n}\n\nspec fn two_solutions_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a != 1\n}\n\nspec fn zero_solutions_case(t: int, a: int, b: int) -> bool {\n    (t == 2 && a == 3 && b > 10000) ||\n    (a == t && a != b) ||\n    (a != t && (a - b) % (t - a) == 0) ||\n    (a != t && (a - b) % (t - a) != 0 && t == b)\n}\n\nspec fn one_solution_case(t: int, a: int, b: int) -> bool {\n    a != t && (a - b) % (t - a) != 0 && t != b\n}", "vc-helpers": "", "vc-spec": "fn solve(t: i8, a: i8, b: i8) -> (res: String)\n    requires \n        valid_input(t as int, a as int, b as int),\n    ensures \n        valid_output(res),\n        infinite_case(t as int, a as int, b as int) ==> res@ == \"inf\"@,\n        two_solutions_case(t as int, a as int, b as int) ==> res@ == \"2\"@,\n        zero_solutions_case(t as int, a as int, b as int) ==> res@ == \"0\"@,\n        one_solution_case(t as int, a as int, b as int) ==> res@ == \"1\"@", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0122", "language": "verus", "source": "apps", "source_id": "apps_test_623", "vc-description": "Given two joysticks with initial charge levels a1 and a2 percent, determine the maximum number of minutes a game can last.\nEach minute, exactly one joystick must be connected to a charger (gains 1% charge) while the other loses 2% charge.\nGame continues while both joysticks have positive charge (> 0%). If a joystick has exactly 1% charge at the start of a minute,\nit must be charged to avoid reaching 0%. Find the maximum number of minutes before at least one joystick reaches 0% charge.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_valid_minutes(a: int, b: int) -> int\n    recommends a >= 0 && b >= 0\n    decreases a + b\n{\n    if a <= 0 || b <= 0 {\n        0\n    } else if a == 1 && b == 1 {\n        0\n    } else {\n        (if a > 1 || b > 1 { 1 as int } else { 0 as int }) + \n        count_valid_minutes(\n            if a < b { a + 1 } else { a - 2 }, \n            if a < b { b - 2 } else { b + 1 }\n        )\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(a1: i8, a2: i8) -> (result: i8)\n    requires \n        a1 >= 1 && a2 >= 1,\n    ensures \n        result >= 0,\n        result as int == count_valid_minutes(a1 as int, a2 as int),\n        (a1 == 1 && a2 == 1) ==> result == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0123", "language": "verus", "source": "apps", "source_id": "apps_test_625", "vc-description": "Given a positive integer n, calculate the value of the alternating sum:\nf(n) = -1 + 2 - 3 + 4 - 5 + ... + (-1)^n × n", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn alternating_sum(n: int) -> int\n    recommends n > 0\n    decreases n\n{\n    if n <= 0 { 0 }\n    else if n == 1 { -1 }\n    else { alternating_sum(n - 1) + (if n % 2 == 0 { n } else { -n }) }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n > 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures \n        result as int == alternating_sum(n as int) &&\n        (n as int % 2 == 0 ==> result as int == n as int / 2) &&\n        (n as int % 2 != 0 ==> result as int == n as int / 2 - n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0125", "language": "verus", "source": "apps", "source_id": "apps_test_641", "vc-description": "Calculate how many candies will be saved in the year 2016 based on a savings plan.\nInput format: \"x of week\" (x=1-7, Monday-Sunday) or \"x of month\" (x=1-31).\nSave one candy on the specified day each week/month.\n2016 is a leap year starting on Friday, week starts on Monday.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    ({\n        let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n        let parts = split_on_space(trimmed);\n        parts.len() >= 1\n    })\n}\n\nspec fn get_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n    let parts = split_on_space(trimmed);\n    if parts[parts.len() as int - 1] == seq!['m', 'o', 'n', 't', 'h'] {\n        if parts[0] == seq!['3', '1'] { seq!['7', '\\n'] }\n        else if parts[0] == seq!['3', '0'] { seq!['1', '1', '\\n'] }\n        else { seq!['1', '2', '\\n'] }\n    } else {\n        if parts[0] == seq!['5'] || parts[0] == seq!['6'] { seq!['5', '3', '\\n'] }\n        else { seq!['5', '2', '\\n'] }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == get_expected_result(input@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0126", "language": "verus", "source": "apps", "source_id": "apps_test_644", "vc-description": "Execute a sequence of commands (for n, end, add) that manipulate an integer variable x starting at 0.\nCommands form valid nested loops. Check if x exceeds 2^32 - 1 at any point during execution.\nReturn \"OVERFLOW!!!\" if overflow occurs, otherwise return the final value of x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(lines: Seq<String>) -> bool {\n    lines.len() > 0\n}\n\nspec fn max_value() -> int { 4294967295 }\n\nspec fn is_overflow(x: int) -> bool {\n    x > max_value()\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    requires valid_input(seq![input])\n    ensures result@ =~= \"OVERFLOW!!!\"@ || !(result@ =~= \"OVERFLOW!!!\"@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0127", "language": "verus", "source": "apps", "source_id": "apps_test_645", "vc-description": "Given n cards with letters/digits, determine minimum cards to flip to verify:\n\"If a card has a vowel on one side, then it has an even digit on the other side.\"\nInput: string representing visible sides. Output: minimum flips needed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_vowel(c: char) -> bool {\n  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n}\n\nspec fn is_odd_digit(c: char) -> bool {\n  c == '1' || c == '3' || c == '5' || c == '7' || c == '9'\n}\n\nspec fn needs_flipping(c: char) -> bool {\n  is_vowel(c) || is_odd_digit(c)\n}\n\nspec fn count_flips(s: Seq<char>) -> int {\n  s.filter(|c: char| needs_flipping(c)).len() as int\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n  requires s@.len() >= 1 && s@.len() <= 50\n  ensures result@.len() > 0", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0128", "language": "verus", "source": "apps", "source_id": "apps_test_648", "vc-description": "Given integers m and b, find the maximum sum of bananas that can be collected from an optimally placed rectangle.\nEach lattice point (x,y) where x,y >= 0 contains x+y bananas.\nA line is defined by y = -x/m + b.\nA rectangle with axis-aligned sides can be placed anywhere such that all points are on or under the line.\nThe rectangle can be degenerate (a line segment or single point).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(m: int, b: int) -> bool {\n  1 <= m <= 1000 && 1 <= b <= 10000\n}\n\nspec fn f(x: int, y: int) -> int {\n  (x * (x + 1) * (y + 1) + y * (y + 1) * (x + 1)) / 2\n}\n\nspec fn valid_rectangle_corner(k: int, m: int, b: int) -> bool {\n  0 <= k && b - k >= 0\n}\n\nspec fn rectangle_value(k: int, m: int, b: int) -> int {\n  f(k * m, b - k)\n}", "vc-helpers": "", "vc-spec": "fn solve(m: i8, b: i8) -> (result: i8)\n  requires \n    valid_input(m as int, b as int)\n  ensures \n    result as int >= -1,\n    forall|k: int| valid_rectangle_corner(k, m as int, b as int) ==> result as int >= rectangle_value(k, m as int, b as int),\n    exists|k: int| valid_rectangle_corner(k, m as int, b as int) && result as int == rectangle_value(k, m as int, b as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0129", "language": "verus", "source": "apps", "source_id": "apps_test_650", "vc-description": "Given a string of uppercase letters A-Z with length 1-10, determine if all letters\nbelong to the same predefined group. Group 1: A,E,F,H,I,K,L,M,N,T,V,W,X,Y,Z.\nGroup 2: B,C,D,G,J,O,P,Q,R,S,U. Output \"YES\" if all letters in same group, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(word: Seq<char>) -> bool {\n    1 <= word.len() <= 10 && forall|i: int| 0 <= i < word.len() ==> 'A' <= #[trigger] word[i] <= 'Z'\n}\n\nspec fn group1() -> Seq<char> { \n    seq!['A','E','F','H','I','K','L','M','N','T','V','W','X','Y','Z']\n}\n\nspec fn group2() -> Seq<char> { \n    seq!['B','C','D','G','J','O','P','Q','R','S','U']\n}\n\nspec fn all_in_group1(word: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < word.len() ==> group1().contains(#[trigger] word[i])\n}\n\nspec fn all_in_group2(word: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < word.len() ==> group2().contains(#[trigger] word[i])\n}\n\nspec fn all_in_same_group(word: Seq<char>) -> bool {\n    all_in_group1(word) || all_in_group2(word)\n}", "vc-helpers": "", "vc-spec": "fn solve(word: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(word@)\n    ensures (all_in_same_group(word@) <==> result@ == seq!['Y','E','S']) && (result@ == seq!['Y','E','S'] || result@ == seq!['N','O'])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0132", "language": "verus", "source": "apps", "source_id": "apps_test_657", "vc-description": "Given initial counts of yellow and blue crystals, determine the minimum additional crystals needed to produce a specified number of colored balls.\nYellow ball requires 2 yellow crystals, green ball requires 1 yellow + 1 blue crystal, blue ball requires 3 blue crystals.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn max(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn valid_input(a: int, b: int, x: int, y: int, z: int) -> bool {\n    a >= 0 && b >= 0 && x >= 0 && y >= 0 && z >= 0\n}\n\nspec fn yellow_crystals_needed(x: int, y: int) -> int {\n    x * 2 + y\n}\n\nspec fn blue_crystals_needed(y: int, z: int) -> int {\n    y + z * 3\n}\n\nspec fn min_additional_crystals(a: int, b: int, x: int, y: int, z: int) -> int {\n    max(0, yellow_crystals_needed(x, y) - a) + max(0, blue_crystals_needed(y, z) - b)\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, x: i8, y: i8, z: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, x as int, y as int, z as int)\n    ensures \n        result >= 0,\n        result as int == min_additional_crystals(a as int, b as int, x as int, y as int, z as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0133", "language": "verus", "source": "apps", "source_id": "apps_test_666", "vc-description": "Find the n-th element (1-indexed) in an infinite sequence constructed as blocks:\nBlock 1: [1], Block 2: [1,2], Block 3: [1,2,3], etc.\nThe complete sequence is: 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, ...", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn triangular_number(m: int) -> int\n    recommends m >= 0\n{\n    m * (m + 1) / 2\n}\n\nspec fn valid_input(n: int) -> bool\n{\n    n >= 1\n}\n\nspec fn valid_result(n: int, result: int) -> bool\n    recommends valid_input(n)\n{\n    result >= 1 && result <= n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures valid_result(n as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0134", "language": "verus", "source": "apps", "source_id": "apps_test_673", "vc-description": "Given two integers n and k, find the smallest integer x such that x > n and x is divisible by k.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k > 0\n}\n\nspec fn is_correct_result(n: int, k: int, result: int) -> bool \n    recommends k > 0\n{\n    result > n && result % k == 0 && forall|x: int| n < x < result ==> #[trigger] (x % k) != 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires valid_input(n as int, k as int)\n    ensures is_correct_result(n as int, k as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0135", "language": "verus", "source": "apps", "source_id": "apps_test_679", "vc-description": "Given a string representing a row of cells with flowers (A, B, C) or empty cells (.),\ndetermine if it's possible for at least one cell to contain all three colors after\nsome flowers wither and spread petals to adjacent cells.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'B' || s[i] == 'C' || s[i] == '.'\n}\n\nspec fn has_all_three_colors(s: Seq<char>, start: int) -> bool\n    recommends 0 <= start <= s.len() - 3\n{\n    s.subrange(start, start + 3).contains('A') && \n    s.subrange(start, start + 3).contains('B') && \n    s.subrange(start, start + 3).contains('C')\n}\n\nspec fn possible_to_get_all_colors(s: Seq<char>) -> bool {\n    s.len() >= 3 && exists|i: int| 0 <= i <= s.len() - 3 && has_all_three_colors(s, i)\n}", "vc-helpers": "", "vc-spec": "fn solve(s: &[char]) -> (result: Vec<char>)\n    requires \n        s@.len() >= 0 && forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'A' || s@[i] == 'B' || s@[i] == 'C' || s@[i] == '.'\n    ensures \n        result@ == seq!['Y', 'e', 's'] ==> possible_to_get_all_colors(s@),\n        result@ == seq!['N', 'o'] ==> !possible_to_get_all_colors(s@),\n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']", "vc-code": "{\n    /* impl-start */\n    assume(false);\n    vec!['N', 'o']\n    /* impl-end */\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0136", "language": "verus", "source": "apps", "source_id": "apps_test_682", "vc-description": "Given starting position (r1, c1) and ending position (r2, c2) on an 8×8 chessboard,\nfind the minimum number of moves required for a rook, bishop, and king to move from\nthe starting position to the ending position. Return 0 if a piece cannot reach the destination.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_position(r: int, c: int) -> bool {\n    1 <= r <= 8 && 1 <= c <= 8\n}\n\nspec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else if r1 == r2 || c1 == c2 {\n        1\n    } else {\n        2\n    }\n}\n\nspec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else {\n        let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n        let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n        if row_diff == col_diff {\n            1\n        } else if (r1 + c1) % 2 == (r2 + c2) % 2 {\n            2\n        } else {\n            0\n        }\n    }\n}\n\nspec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n    let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n    if row_diff >= col_diff { row_diff } else { col_diff }\n}\n\nspec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    result.len() == 3 &&\n    result[0] == rook_moves(r1, c1, r2, c2) &&\n    result[1] == bishop_moves(r1, c1, r2, c2) &&\n    result[2] == king_moves(r1, c1, r2, c2)\n}", "vc-helpers": "", "vc-spec": "fn solve(r1: i8, c1: i8, r2: i8, c2: i8) -> (result: Vec<i8>)\n    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)\n    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0137", "language": "verus", "source": "apps", "source_id": "apps_test_696", "vc-description": "Given a prime number p, find the count of primitive roots modulo p.\nA primitive root modulo prime p is an integer x where 1 ≤ x < p such that\nx^k ≢ 1 (mod p) for all positive integers k < p-1, but x^(p-1) ≡ 1 (mod p).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(p: int) -> bool {\n    2 <= p < 2000\n}\n\nspec fn count_primitive_roots(p: int) -> int\n    recommends valid_input(p)\n{\n    if p == 2 { \n        1 \n    } else { \n        /* Count of integers i where 1 <= i < p-1 and \n           for all j where 2 <= j <= i, not ((p-1) % j == 0 && i % j == 0) */\n        Set::new(|i: int| 1 <= i < p-1 && (forall|j: int| 2 <= j <= i ==> !((p-1) % j == 0 && #[trigger] (i % j) == 0))).len() as int\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(p: i8) -> (result: i8)\n    requires valid_input(p as int)\n    ensures \n        result >= 0 &&\n        result as int == count_primitive_roots(p as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0139", "language": "verus", "source": "apps", "source_id": "apps_test_703", "vc-description": "Store `a` nuts in boxes using `b` available divisors. Each box can have at most `k` sections.\nA box with `x` divisors has `x+1` sections. Each section holds at most `v` nuts.\nFind minimum number of boxes needed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn valid_input(k: int, a: int, b: int, v: int) -> bool {\n    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000\n}\n\nspec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int\n    recommends num_boxes >= 0\n{\n    v * (num_boxes + min(b, (k - 1) * num_boxes))\n}\n\nspec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool\n    recommends num_boxes >= 0\n{\n    a <= box_capacity(num_boxes, k, b, v)\n}\n\nspec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool\n    recommends result >= 1\n{\n    can_store_nuts(result, k, a, b, v) &&\n    (result == 1 || !can_store_nuts(result - 1, k, a, b, v))\n}", "vc-helpers": "", "vc-spec": "fn solve(k: i8, a: i8, b: i8, v: i8) -> (result: i8)\n    requires\n        valid_input(k as int, a as int, b as int, v as int)\n    ensures\n        result >= 1,\n        result <= 127,\n        is_minimal_solution(result as int, k as int, a as int, b as int, v as int),\n        exists|i: int| 1 <= i <= 127 && can_store_nuts(i, k as int, a as int, b as int, v as int) && result as int == i && \n            (forall|j: int| 1 <= j < i ==> !can_store_nuts(j, k as int, a as int, b as int, v as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0140", "language": "verus", "source": "apps", "source_id": "apps_test_709", "vc-description": "Find the minimum number of bacteria to add to an initially empty box to achieve exactly x bacteria at some point in time.\nEach morning we can add bacteria, each night bacteria double.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_ones_in_binary(n: int) -> int\n    recommends n >= 1\n    decreases n\n    when n >= 1\n{\n    if n == 1 {\n        1\n    } else if n % 2 == 1 {\n        1 + count_ones_in_binary(n / 2)\n    } else {\n        count_ones_in_binary(n / 2)\n    }\n}\n\nspec fn valid_input(x: int) -> bool {\n    x >= 1\n}\n\nspec fn valid_output(x: int, result: int) -> bool {\n    valid_input(x) && result == count_ones_in_binary(x)\n}", "vc-helpers": "", "vc-spec": "fn min_bacteria(x: i8) -> (result: i8)\n    requires valid_input(x as int)\n    ensures valid_output(x as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0142", "language": "verus", "source": "apps", "source_id": "apps_test_719", "vc-description": "Find the k-th smallest perfect positive integer, where a perfect integer \nis one whose digits sum to exactly 10.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn int_to_string(n: int) -> Seq<char> {\n    unimplemented!()\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|k: int| k >= 1 && k <= 10000 && stdin_input == int_to_string(k).push('\\n')\n}\n\nspec fn kth_perfect_number(k: int) -> int\n    recommends k >= 1 && k <= 10000\n{\n    if k == 1 { 19 }\n    else if k == 2 { 28 }\n    else if k == 3 { 37 }\n    else if k == 4 { 46 }\n    else if k == 5 { 55 }\n    else if k == 6 { 64 }\n    else if k == 7 { 73 }\n    else if k == 8 { 82 }\n    else if k == 9 { 91 }\n    else if k == 10 { 109 }\n    else { 10 * (k - 9) + 99 }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: String) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures (exists|k: int| k >= 1 && k <= 10000 && \n        stdin_input@ == int_to_string(k).push('\\n') &&\n        result@ == int_to_string(kth_perfect_number(k)).push('\\n')) &&\n        result@.len() > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0144", "language": "verus", "source": "apps", "source_id": "apps_test_736", "vc-description": "Given a staircase with n steps, find the minimum number of moves to reach the top\nwhere each move climbs 1 or 2 steps, and total moves must be a multiple of m.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    n > 0 && n <= 10000 && m > 1 && m <= 10\n}\n\nspec fn min_moves(n: int) -> int\n    recommends n > 0\n{\n    if n % 2 == 0 { n / 2 } else { n / 2 + 1 }\n}\n\nspec fn valid_move_count(n: int, k: int) -> bool\n    recommends n > 0\n{\n    min_moves(n) <= k <= n\n}\n\nspec fn is_valid_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 || (result > 0 && result % m == 0 && valid_move_count(n, result))\n}\n\nspec fn no_smaller_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 ==> forall|k: int| min_moves(n) <= k <= n ==> #[trigger] (k % m) != 0\n}\n\nspec fn is_minimal_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result != -1 ==> forall|k: int| (min_moves(n) <= k <= n && k < result) ==> #[trigger] (k % m) != 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        is_valid_solution(n as int, m as int, result as int) &&\n        no_smaller_solution(n as int, m as int, result as int) &&\n        is_minimal_solution(n as int, m as int, result as int)", "vc-code": "{\n    assume(false);\n    -1\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0146", "language": "verus", "source": "apps", "source_id": "apps_test_744", "vc-description": "Given a sequence of n days where you were either in Seattle (S) or San Francisco (F),\ndetermine if you made more flights from Seattle to San Francisco than from San Francisco\nto Seattle during this period. You fly at night between consecutive days when you change cities.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_sf_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'F' && s[s.len()-2] != 'F' { 1int } else { 0int }) + count_sf_flights(s.subrange(0, s.len()-1))\n    }\n}\n\nspec fn count_fs_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'S' && s[s.len()-2] != 'S' { 1int } else { 0int }) + count_fs_flights(s.subrange(0, s.len()-1))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 2,\n        s@.len() == n,\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'S' || s@[i] == 'F',\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> count_sf_flights(s@) > count_fs_flights(s@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0147", "language": "verus", "source": "apps", "source_id": "apps_test_748", "vc-description": "Given a sequence of n positive integers (n divisible by 3), each ≤ 7,\npartition into groups of 3 elements (a,b,c) where a < b < c and a|b, b|c.\nReturn the partition or empty sequence if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, numbers: Seq<int>) -> bool {\n    n >= 3 && n % 3 == 0 &&\n    numbers.len() == n &&\n    forall|i: int| 0 <= i < numbers.len() ==> 1 <= #[trigger] numbers[i] && #[trigger] numbers[i] <= 7\n}\n\nspec fn valid_triplet(triplet: Seq<int>) -> bool {\n    triplet.len() == 3 &&\n    triplet[0] < triplet[1] && triplet[1] < triplet[2] &&\n    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&\n    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0\n}\n\nspec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>\n    decreases result.len()\n{\n    if result.len() == 0 { \n        seq![]\n    } else {\n        result[0].add(flatten_partition(result.subrange(1, result.len() as int)))\n    }\n}\n\nspec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {\n    result.len() == numbers.len() / 3 &&\n    (forall|i: int| 0 <= i < result.len() ==> valid_triplet(#[trigger] result[i])) &&\n    numbers.to_multiset() == flatten_partition(result).to_multiset()\n}\n\nspec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {\n    result.len() == 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, numbers: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0148", "language": "verus", "source": "apps", "source_id": "apps_test_750", "vc-description": "Given n friends to invite and notebooks with k sheets each (one color per notebook),\nfind the minimum number of notebooks needed. Each invitation requires exactly 2 red \nsheets, 5 green sheets, and 8 blue sheets.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1\n}\n\nspec fn sheets_needed(n: int) -> (int, int, int) {\n    (2 * n, 5 * n, 8 * n)\n}\n\nspec fn total_sheets_needed(n: int) -> int {\n    2 * n + 5 * n + 8 * n\n}\n\nspec fn ceil_div(a: int, b: int) -> int\n    recommends b > 0\n{\n    (a + b - 1) / b\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result as int == ceil_div(2 * (n as int), k as int) + ceil_div(5 * (n as int), k as int) + ceil_div(8 * (n as int), k as int),\n        result >= 0,\n        result as int >= (total_sheets_needed(n as int) + (k as int) - 1) / (k as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0151", "language": "verus", "source": "apps", "source_id": "apps_test_754", "vc-description": "Given n stones in a row colored R, G, or B, find the minimum number of stones\nto remove so that no two adjacent stones have the same color.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool\n{\n    n >= 1 && s.len() == n\n}\n\nspec fn count_adjacent_same_pairs(s: Seq<char>, n: int) -> int\n{\n    count_adjacent_same_pairs_up_to(s, n)\n}\n\nspec fn count_adjacent_same_pairs_up_to(s: Seq<char>, i: int) -> int\n    decreases i\n{\n    if i <= 1 { 0int }\n    else { (if s[i-1] == s[i-2] { 1int } else { 0int }) + count_adjacent_same_pairs_up_to(s, i-1) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(n as int, s@),\n    ensures \n        result >= 0,\n        result <= n - 1,\n        result as int == count_adjacent_same_pairs(s@, n as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0152", "language": "verus", "source": "apps", "source_id": "apps_test_755", "vc-description": "Find the minimum number of steps to move from position 0 to position x on a number line,\nwhere each step can move forward by 1, 2, 3, 4, or 5 positions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int) -> bool {\n    x >= 1\n}\n\nspec fn is_minimal_steps(x: int, steps: int) -> bool {\n    x >= 1 ==> (steps >= 1 &&\n    steps * 5 >= x &&\n    (steps - 1) * 5 < x)\n}", "vc-helpers": "", "vc-spec": "fn min_steps(x: i8) -> (result: i8)\n    requires valid_input(x as int)\n    ensures is_minimal_steps(x as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0154", "language": "verus", "source": "apps", "source_id": "apps_test_760", "vc-description": "Given a string s and integer k, find the maximum possible length of a tandem repeat substring\nthat can appear after appending k characters to s. A tandem repeat of length 2n has its first\nhalf exactly matching its second half.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_tandem_repeat(s: Seq<char>) -> bool {\n    if s.len() % 2 != 0 {\n        false\n    } else {\n        let half_len = s.len() / 2;\n        let first_half = s.subrange(0, half_len as int);\n        let second_half = s.subrange(half_len as int, s.len() as int);\n        forall|i: int| 0 <= i < half_len ==> \n            (first_half[i] == '*' || second_half[i] == '*' || first_half[i] == second_half[i])\n    }\n}\n\nspec fn extended_string(s: Seq<char>, k: int) -> Seq<char> {\n    s + Seq::new(k as nat, |j| '*')\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>, k: i8) -> (result: i8)\n    requires \n        k >= 1,\n        s.len() >= 1,\n    ensures \n        result >= 0,\n        result % 2 == 0,\n        result as int <= s@.len() + k as int,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0155", "language": "verus", "source": "apps", "source_id": "apps_test_777", "vc-description": "Given a string of lowercase letters, determine how many distinct strings can be created by\ninserting exactly one additional lowercase letter (a-z) at any position in the string.\nFor a string of length n, we can insert at n+1 positions with 26 character choices,\ngiving 26×(n+1) total combinations. However, n duplicates occur, resulting in\n26×(n+1) - n = 25×n + 26 distinct strings.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 20 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn distinct_strings_count(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    s.len() as int * 25 + 26\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { seq!['0'] } // Simplified for termination\n}\n\nspec fn char_of_digit_spec(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: &str) -> (result: String)\n    requires valid_input(s@)\n    ensures result@ == int_to_string_spec(distinct_strings_count(s@))", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0156", "language": "verus", "source": "apps", "source_id": "apps_test_781", "vc-description": "Given an 8×8 board where each cell is colored black (B) or white (W), determine if it's possible to transform it \ninto a proper chessboard using only cyclic right shifts on individual rows. A proper chessboard has no adjacent \ncells (horizontally or vertically) with the same color and the upper-left cell is white.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() == 8 &&\n    (forall|i: int| 0 <= i < 8 ==> #[trigger] input[i].len() == 8) &&\n    (forall|i: int, j: int| 0 <= i < 8 && 0 <= j < 8 ==> (#[trigger] input[i][j] == 'W' || #[trigger] input[i][j] == 'B'))\n}\n\nspec fn has_alternating_row(row: Seq<char>) -> bool {\n    row.len() == 8 &&\n    (forall|j: int| 0 <= j < 8 ==> (#[trigger] row[j] == 'W' || #[trigger] row[j] == 'B')) &&\n    row[0] == 'W' &&\n    row[1] == 'B' &&\n    row[2] == 'W' &&\n    row[3] == 'B' &&\n    row[4] == 'W' &&\n    row[5] == 'B' &&\n    row[6] == 'W' &&\n    row[7] == 'B'\n}\n\nspec fn all_rows_have_alternating_pattern(input: Seq<Seq<char>>) -> bool {\n    valid_input(input) &&\n    (forall|i: int| 0 <= i < 8 ==> has_alternating_row(#[trigger] input[i]))\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires valid_input(input@.map(|i, row: Vec<char>| row@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0157", "language": "verus", "source": "apps", "source_id": "apps_test_785", "vc-description": "Given a rectangular room with dimensions a × b meters, accommodate exactly n students \nsuch that each student has at least 6 square meters of space. You can increase either \nor both dimensions by any positive integer amount. Find the minimum possible area and \ncorresponding dimensions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int) -> bool {\n    n > 0 && a > 0 && b > 0\n}\n\nspec fn valid_output(result: Seq<int>, n: int, a: int, b: int) -> bool {\n    result.len() == 3 &&\n    result[0] >= 6 * n &&\n    result[1] > 0 && result[2] > 0 &&\n    result[0] == result[1] * result[2] &&\n    ((result[1] >= a && result[2] >= b) || (result[1] >= b && result[2] >= a))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8) -> (result: Vec<i8>)\n    requires valid_input(n as int, a as int, b as int)\n    ensures valid_output(result@.map(|i, x| x as int), n as int, a as int, b as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0159", "language": "verus", "source": "apps", "source_id": "apps_test_788", "vc-description": "Calculate a score from a string starting with 'A' followed by exactly 6 digits.\nScore formula: sum of all 6 digits + 9 * count of zero digits + 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 7 && s[0] == 'A' && forall|i: int| 1 <= i < 7 ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn digit_sum(s: Seq<char>, start: int, end: int) -> int\n    decreases end - start when 0 <= start <= end <= s.len()\n{\n    if start >= end {\n        0\n    } else {\n        (s[start] as int - '0' as int) + digit_sum(s, start + 1, end)\n    }\n}\n\nspec fn zero_count(s: Seq<char>, start: int, end: int) -> int\n    decreases end - start when 0 <= start <= end <= s.len()\n{\n    if start >= end {\n        0\n    } else {\n        (if s[start] == '0' { 1nat } else { 0nat }) as int + zero_count(s, start + 1, end)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures result as int == digit_sum(s@, 1, 7) + 9 * zero_count(s@, 1, 7) + 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0160", "language": "verus", "source": "apps", "source_id": "apps_test_789", "vc-description": "Given a lucky number n (containing only digits 4 and 7), find its 1-based index\nwhen all lucky numbers are sorted in increasing order. Lucky numbers are positive\nintegers containing only the digits 4 and 7.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_lucky_number(n: Seq<char>) -> bool {\n    n.len() > 0 && forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n}\n\nspec fn convert_to_binary(n: Seq<char>) -> Seq<char>\n    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n    decreases n.len()\n{\n    if n.len() == 0 {\n        Seq::empty()\n    } else if n[0] == '4' {\n        seq!['0'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    } else {\n        seq!['1'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    }\n}\n\nspec fn pow2(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 2 * pow2((n - 1) as nat) }\n}\n\nspec fn binary_to_int(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        pow2((s.len() - 1) as nat) + binary_to_int(s.subrange(1, s.len() as int))\n    } else {\n        binary_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_result(n: Seq<char>, result: int) -> bool\n    recommends valid_lucky_number(n)\n{\n    result > 0 && result == 2 * (pow2((n.len() - 1) as nat) - 1) + binary_to_int(convert_to_binary(n)) + 1\n}", "vc-helpers": "", "vc-spec": "fn solve(n: Vec<char>) -> (result: i8)\n    requires valid_lucky_number(n@)\n    ensures valid_result(n@, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0161", "language": "verus", "source": "apps", "source_id": "apps_test_792", "vc-description": "Given a credit card account starting with 0 money and n consecutive days of transactions,\ndetermine the minimum number of days deposits are needed to satisfy all constraints.\nEach day deposits can be made in the morning, then transactions occur in the evening.\nIf any evening transaction causes the balance to exceed limit d, return -1.\nOn days when evening transaction is 0 (balance check days), the balance after the\ntransaction must be non-negative. Morning deposits can be any positive integer amount.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {\n  n >= 1 && d >= 1 &&\n  transactions.len() == n &&\n  forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000\n}\n\nspec fn prefix_sum(transactions: Seq<int>, index: int) -> int\n  decreases index\n{\n  if index < 0 || index >= transactions.len() { 0int }\n  else if index == 0 { transactions[0] }\n  else { prefix_sum(transactions, index - 1) + transactions[index] }\n}\n\nspec fn count_zero_transactions(transactions: Seq<int>) -> int\n  decreases transactions.len()\n{\n  if transactions.len() == 0 { 0int }\n  else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }\n}\n\nspec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int\n  decreases day\n{\n  if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }\n  else if day == 0 { deposits[0] + transactions[0] }\n  else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }\n}\n\nspec fn count_positive_deposits(deposits: Seq<int>) -> int\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { 0int }\n  else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }\n}\n\nspec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {\n  deposits_schedule.len() == transactions.len() &&\n  (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&\n  num_deposits == count_positive_deposits(deposits_schedule) &&\n  forall|i: int| 0 <= i < transactions.len() ==> \n    (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)\n}\n\nspec fn filter_positive(deposits: Seq<int>) -> Seq<int>\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { Seq::empty() }\n  else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }\n  else { filter_positive(deposits.drop_first()) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, d: i8, transactions: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))\n  ensures result == -1 || result >= 0", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0162", "language": "verus", "source": "apps", "source_id": "apps_test_795", "vc-description": "Count the number of integer right triangles (a, b, c) where:\n- a² + b² = c² (Pythagorean theorem)\n- 1 ≤ a ≤ b ≤ c ≤ n\n- All sides are positive integers", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_n(n: int) -> bool {\n    n >= 1 && n <= 10000\n}\n\nspec fn integer_square_root(n: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn extract_integer(input: Seq<char>) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]  /* placeholder implementation */\n}\n\nspec fn count_pythagorean_triples_via_primitives(n: int) -> int {\n    let m = integer_square_root(n);\n    count_from_primitives(n, m, 1, 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        result@.len() > 0,\n        result@ == int_to_string(count_pythagorean_triples_via_primitives(extract_integer(stdin_input@)))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0163", "language": "verus", "source": "apps", "source_id": "apps_test_804", "vc-description": "Given a string of lowercase Latin letters and an integer k, find the minimum number of \ncharacter changes needed to make the string contain at least k different letters.\nReturn \"impossible\" if the string length is less than k.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>, k: int) -> bool {\n    1 <= k <= 26 && 1 <= s.len() <= 1000 && \n    forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] <= 'z'\n}\n\nspec fn unique_chars(s: Seq<char>) -> Set<char> {\n    s.to_set()\n}\n\nspec fn min_changes(s: Seq<char>, k: int) -> int {\n    let unique = unique_chars(s);\n    if k <= unique.len() { 0 } else { k - unique.len() }\n}\n\nspec fn is_impossible(s: Seq<char>, k: int) -> bool {\n    s.len() < k\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>, k: i8) -> (result: String)\n    requires valid_input(s@, k as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0165", "language": "verus", "source": "apps", "source_id": "apps_test_811", "vc-description": "Given `a` initial candles and the ability to create 1 new candle from `b` burnt-out candles,\ndetermine the maximum number of hours the room can be lit. Each candle burns for exactly 1 hour.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int) -> bool {\n  a >= 1 && a <= 1000 && b >= 2 && b <= 1000\n}\n\nspec fn total_burning_hours(a: int, b: int) -> int\n  decreases a via a_decreases\n{\n  if a <= 0 { 0 }\n  else if a < b { a }\n  else { a + total_burning_hours(a / b, b) }\n}\n\n#[verifier::decreases_by]\nproof fn a_decreases(a: int, b: int) {\n  assume(false);\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n  requires \n    valid_input(a as int, b as int)\n  ensures \n    result as int >= a as int,\n    result as int == total_burning_hours(a as int, b as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0167", "language": "verus", "source": "apps", "source_id": "apps_test_821", "vc-description": "Two participants compete in a typing race. Each participant has a ping delay and typing speed.\nThe total time for participant i is 2*t_i + s*v_i where t_i is ping, v_i is typing speed per character, s is text length.\nDetermine winner based on who completes first, or declare friendship if tied.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool\n{\n    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000\n}\n\nspec fn participant_time(s: int, v: int, t: int) -> int\n{\n    2 * t + s * v\n}\n\nspec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>\n{\n    let time1 = participant_time(s, v1, t1);\n    let time2 = participant_time(s, v2, t2);\n    if time1 < time2 { seq!['F','i','r','s','t'] }\n    else if time1 > time2 { seq!['S','e','c','o','n','d'] }\n    else { seq!['F','r','i','e','n','d','s','h','i','p'] }\n}\n\nspec fn valid_result(result: Seq<char>) -> bool\n{\n    result == seq!['F','i','r','s','t'] || result == seq!['S','e','c','o','n','d'] || result == seq!['F','r','i','e','n','d','s','h','i','p']\n}", "vc-helpers": "", "vc-spec": "fn solve(s: i8, v1: i8, v2: i8, t1: i8, t2: i8) -> (result: Vec<char>)\n    requires \n        valid_input(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n    ensures \n        valid_result(result@) &&\n        result@ == correct_result(s as int, v1 as int, v2 as int, t1 as int, t2 as int)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0168", "language": "verus", "source": "apps", "source_id": "apps_test_823", "vc-description": "Given an infinite spiral starting at (0,0) that visits every integer point,\ndetermine the number of turns required to reach point (x,y) from origin.\nThe spiral follows: (0,0) → (1,0) → (1,1) → (-1,1) → (-1,-1) → (2,-1) → ...\nA turn occurs when direction changes (right→up, up→left, left→down, down→right).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, y: int) -> bool {\n    -100 <= x <= 100 && -100 <= y <= 100\n}\n\nspec fn is_origin_or_first_point(x: int, y: int) -> bool {\n    (x == 0 && y == 0) || (x == 1 && y == 0)\n}\n\nspec fn is_right_edge(x: int, y: int) -> bool {\n    x >= 1 && -x + 1 < y <= x\n}\n\nspec fn is_left_edge(x: int, y: int) -> bool {\n    x < 0 && x <= y < -x\n}\n\nspec fn is_top_edge(x: int, y: int) -> bool {\n    y > 0 && -y <= x < y\n}\n\nspec fn compute_turns(x: int, y: int) -> int\n    recommends valid_input(x, y)\n{\n    if is_origin_or_first_point(x, y) { \n        0\n    } else if is_right_edge(x, y) { \n        1 + 4 * (x - 1)\n    } else if is_left_edge(x, y) { \n        3 + 4 * (-x - 1)\n    } else if is_top_edge(x, y) { \n        2 + 4 * (y - 1)\n    } else { \n        -4 * y\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8, y: i8) -> (result: i8)\n    requires \n        valid_input(x as int, y as int)\n    ensures \n        result as int >= 0,\n        result as int == compute_turns(x as int, y as int),\n        is_origin_or_first_point(x as int, y as int) ==> result as int == 0,\n        is_right_edge(x as int, y as int) ==> result as int == 1 + 4 * (x as int - 1),\n        is_left_edge(x as int, y as int) ==> result as int == 3 + 4 * (-(x as int) - 1),\n        is_top_edge(x as int, y as int) ==> result as int == 2 + 4 * (y as int - 1),\n        !(is_origin_or_first_point(x as int, y as int) || is_right_edge(x as int, y as int) || is_left_edge(x as int, y as int) || is_top_edge(x as int, y as int)) ==> result as int == -4 * y as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0169", "language": "verus", "source": "apps", "source_id": "apps_test_826", "vc-description": "Find the minimum cost to obtain logs of lengths 1, 2, 3, ..., n.\nWe can purchase logs of lengths 1, 2, 3, ..., n+1 (each costing 1 unit),\ncut them into smaller pieces, and discard unwanted pieces.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn is_optimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        savings >= 0 &&\n        (2 + savings) * (savings + 1) / 2 > n + 1 &&\n        (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)\n    )\n}\n\nspec fn is_minimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        is_optimal_savings(n, savings) &&\n        (forall|j: int| j >= 0 && j < savings ==> #[trigger] ((2 + j) * (j + 1) / 2) <= n + 1)\n    )\n}\n\nspec fn optimal_cost(n: int, savings: int) -> int {\n    if n >= 1 && is_optimal_savings(n, savings) {\n        n - savings + 1\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int)\n    ensures \n        result as int >= 1,\n        result as int <= n as int,\n        exists|savings: int| is_minimal_savings(n as int, savings) && result as int == optimal_cost(n as int, savings),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0170", "language": "verus", "source": "apps", "source_id": "apps_test_838", "vc-description": "Count non-empty sets of cells in a binary grid where all cells have the same color (0 or 1)\nand every pair of cells in the set shares either a row or a column.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {\n    grid.len() * grid[0].len() + \n    sum_row_contributions(grid) + \n    sum_col_contributions(grid)\n}\n\nspec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_row_contributions_helper(grid, 0)\n}\n\nspec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }\n}\n\nspec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {\n    let cnt0 = count_in_row(grid, row, 0);\n    let cnt1 = count_in_row(grid, row, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_col_contributions_helper(grid, 0)\n}\n\nspec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int\n    decreases grid[0].len() - col\n{\n    if col >= grid[0].len() { 0 }\n    else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }\n}\n\nspec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {\n    let cnt0 = count_in_col(grid, col, 0);\n    let cnt1 = count_in_col(grid, col, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {\n    count_in_row_helper(grid, row, value, 0)\n}\n\nspec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int\n    decreases grid[row].len() - col\n{\n    if col >= grid[row].len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }\n}\n\nspec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {\n    if grid.len() == 0 { 0 }\n    else { count_col_helper(grid, col, value, 0) }\n}\n\nspec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 }\n    else { base * power(base, exp - 1) }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0'] /* placeholder implementation */\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@),\n    ensures result@.len() > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0171", "language": "verus", "source": "apps", "source_id": "apps_test_842", "vc-description": "Given a string input, extract the first line and create an even-length palindrome\nby concatenating the line with its reverse, followed by a newline.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn extract_first_line(s: Seq<char>) -> Seq<char>\n    recommends s.len() > 0\n{\n    let newline_pos = find_first_newline(s);\n    if newline_pos == -1 { s } else { s.subrange(0, newline_pos) }\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == '\\n' {\n        0\n    } else {\n        let rest_result = find_first_newline(s.subrange(1, s.len() as int));\n        if rest_result == -1 { -1 } else { rest_result + 1 }\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        Seq::empty() \n    } else { \n        reverse_string(s.subrange(1, s.len() as int)).push(s[0]) \n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    result.len() >= 1 &&\n    result[result.len() - 1] == '\\n' &&\n    exists|n: Seq<char>| \n        n == extract_first_line(input) &&\n        result == n.add(reverse_string(n)).push('\\n')\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0172", "language": "verus", "source": "apps", "source_id": "apps_test_847", "vc-description": "Given n cards with integers (absolute value ≤ x), find the minimum number of additional cards\nneeded to make the total sum equal to zero. Additional cards can have integer values from -x to x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn valid_input(cards: Seq<int>, x: int) -> bool {\n    x > 0 && cards.len() >= 1 && forall|i: int| 0 <= i < cards.len() ==> #[trigger] cards[i] >= -x && #[trigger] cards[i] <= x\n}\n\nspec fn solve_result(cards: Seq<int>, x: int) -> int {\n    if sum(cards) == 0 { 0 } else { (abs(sum(cards)) + x - 1) / x }\n}", "vc-helpers": "", "vc-spec": "fn solve(cards: Vec<i8>, x: i8) -> (result: i8)\n    requires \n        valid_input(cards@.map(|i: int, v: i8| v as int), x as int),\n    ensures \n        result as int >= 0,\n        result as int == solve_result(cards@.map(|i: int, v: i8| v as int), x as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0173", "language": "verus", "source": "apps", "source_id": "apps_test_858", "vc-description": "Given N attendees at a brain dinner (including Heidi), determine the minimum number of brains needed\nin a chest for Heidi to survive. Heidi makes the first proposal for brain distribution, which must be \naccepted by at least half of all attendees (including herself) for her to survive.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_power_of_two(n: int) -> bool\n    decreases n\n{\n    if n <= 0 {\n        false\n    } else if n == 1 {\n        true\n    } else if n % 2 == 1 {\n        false\n    } else {\n        is_power_of_two(n / 2)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn correct_result(n: int, result: int) -> bool {\n    if n % 2 == 1 {\n        result == (n - 1) / 2\n    } else {\n        exists|z: int| 1 <= z <= n && is_power_of_two(z) && z <= n && z * 2 > n && result == (n - z) / 2\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures correct_result(n as int, result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0174", "language": "verus", "source": "apps", "source_id": "apps_test_862", "vc-description": "Allen starts at the end of queue 1 and moves cyclically through n queues.\nEach minute, one person from each non-empty queue enters the fan zone.\nIf Allen is at the front of his current queue, he enters; otherwise he moves to the next queue.\nFind which entrance Allen will use to enter the fan zone.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n  n >= 2 && a.len() == n && (forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0)\n}\n\nspec fn compute_b(a: Seq<int>, i: int) -> int\n  recommends 0 <= i < a.len()\n{\n  a[i] - i\n}\n\nspec fn compute_c(n: int, b: int) -> int\n  recommends n >= 2\n{\n  if b < 0 { b / n } else { (b + n - 1) / n }\n}\n\nspec fn compute_cc(n: int, a: Seq<int>, i: int) -> int\n  recommends valid_input(n, a) && 0 <= i < n\n{\n  let b = compute_b(a, i);\n  let c = compute_c(n, b);\n  n * c\n}\n\nspec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool\n  recommends valid_input(n, a) && 1 <= entrance <= n\n{\n  let i = entrance - 1;\n  forall|j: int| 0 <= j < n ==> {\n    let cci = compute_cc(n, a, i);\n    let ccj = #[trigger] compute_cc(n, a, j);\n    cci <= ccj && (cci < ccj || i <= j)\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    valid_input(n as int, a@.map(|i, x: i8| x as int)),\n  ensures\n    1 <= result as int <= n as int,\n    is_optimal_entrance(n as int, a@.map(|i, x: i8| x as int), result as int),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0176", "language": "verus", "source": "apps", "source_id": "apps_test_869", "vc-description": "Given a red socks and b blue socks, determine the maximum number of days to wear\ndifferent colored socks (one red, one blue per day), then the number of days to\nwear same colored socks afterwards (two socks of same color per day). Each day,\nworn socks are discarded.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int) -> bool\n{\n  a >= 1 && b >= 1\n}\n\nspec fn max_different_days(a: int, b: int) -> int\n{\n  if a < b { a } else { b }\n}\n\nspec fn remaining_after_different(a: int, b: int) -> int\n{\n  if a > b { a - max_different_days(a, b) } else { b - max_different_days(a, b) }\n}\n\nspec fn same_days(a: int, b: int) -> int\n{\n  remaining_after_different(a, b) / 2\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: (i8, i8))\n  requires valid_input(a as int, b as int)\n  ensures ({\n      let (days_different, days_same) = result;\n      days_different as int == max_different_days(a as int, b as int) &&\n      days_same as int == same_days(a as int, b as int) &&\n      days_different >= 0 &&\n      days_same >= 0 &&\n      days_different <= a && days_different <= b\n  })", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0178", "language": "verus", "source": "apps", "source_id": "apps_test_883", "vc-description": "There are n+1 people (Dima and n friends) standing in a circle. Each person shows 1-5 fingers.\nStarting from Dima, they count around the circle a total number equal to the sum of all fingers.\nThe person where counting stops must clean the apartment.\nGiven the fingers shown by Dima's n friends, determine how many different ways Dima can show\nhis fingers (1-5) such that he does NOT have to clean the apartment.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, friends: Seq<int>) -> bool {\n  n >= 1 && friends.len() == n && forall|i: int| 0 <= i < friends.len() ==> #[trigger] friends[i] >= 1 && #[trigger] friends[i] <= 5\n}\n\nspec fn sum_sequence(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 } else { s[0] + sum_sequence(s.subrange(1, s.len() as int)) }\n}\n\nspec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {\n  &&& valid_input(n, friends)\n  &&& 1 <= dima_fingers <= 5\n  &&& {\n    let total_sum = sum_sequence(friends) + dima_fingers;\n    let total_people = n + 1;\n    total_sum % total_people == 1\n  }\n}\n\nspec fn count_valid_choices(n: int, friends: Seq<int>) -> int {\n  if valid_input(n, friends) {\n    count_valid_choices_helper(n, friends, 1)\n  } else {\n    0\n  }\n}\n\nspec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int\n  decreases 6 - finger_count\n{\n  if !(valid_input(n, friends) && 1 <= finger_count <= 6) {\n    0\n  } else if finger_count > 5 {\n    0\n  } else if !dima_cleans(n, friends, finger_count) {\n    1 + count_valid_choices_helper(n, friends, finger_count + 1)\n  } else {\n    count_valid_choices_helper(n, friends, finger_count + 1)\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, friends: Vec<i8>) -> (result: i8)\n  requires \n    valid_input(n as int, friends@.map_values(|x: i8| x as int))\n  ensures \n    0 <= result <= 5,\n    result as int == count_valid_choices(n as int, friends@.map_values(|x: i8| x as int))", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0180", "language": "verus", "source": "apps", "source_id": "apps_test_894", "vc-description": "Given a rectangle with vertices at (0,0) and (x,y), find two points A=(x₁,y₁) and C=(x₂,y₂) \nsuch that triangle ABC with B=(0,0) is right-angled and isosceles at B, contains the entire \nrectangle, has minimum area, and all coordinates are integers with x₁ < x₂.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, y: int) -> bool {\n    x != 0 && y != 0\n}\n\nspec fn valid_output(result: Seq<int>, x: int, y: int) -> bool {\n    result.len() == 4 &&\n    result[0] < result[2] &&\n    (x * y > 0 && x < 0 ==> result =~= seq![x + y, 0, 0, x + y]) &&\n    (x * y > 0 && x >= 0 ==> result =~= seq![0, x + y, x + y, 0]) &&\n    (x * y <= 0 && x < 0 ==> result =~= seq![x - y, 0, 0, y - x]) &&\n    (x * y <= 0 && x >= 0 ==> result =~= seq![0, y - x, x - y, 0])\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8, y: i8) -> (result: Vec<i8>)\n    requires valid_input(x as int, y as int)\n    ensures valid_output(result@.map(|i: int, v: i8| v as int), x as int, y as int)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0181", "language": "verus", "source": "apps", "source_id": "apps_test_895", "vc-description": "Given n students who perform rituals at times t_i, find the maximum number of students \nthat can be visited by a \"freebie\" present for exactly T consecutive seconds.\nAll visited students must have ritual times within the same T-second interval.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {\n    n >= 1 && times.len() == n && T >= 1 && \n    forall|i: int| 0 <= i < times.len() ==> 1 <= #[trigger] times[i] <= 1000\n}\n\nspec fn max_students_in_window(times: Seq<int>, T: int) -> int {\n    max_students_in_window_up_to(times, T, 1000)\n}\n\nspec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int\n    decreases max_start\n{\n    if max_start < 1 { \n        0\n    } else {\n        let count = count_students_in_window(times, max_start, T);\n        let rest_max = max_students_in_window_up_to(times, T, max_start - 1);\n        if count > rest_max { count } else { rest_max }\n    }\n}\n\nspec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {\n    if times.len() == 0 { \n        0 \n    } else { \n        count_students_in_window_helper(times, start, T, 0) \n    }\n}\n\nspec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int\n    decreases times.len() - index\n{\n    if index >= times.len() { \n        0\n    } else {\n        let count_rest = count_students_in_window_helper(times, start, T, index + 1);\n        if start <= times[index] <= start + T - 1 { \n            count_rest + 1 \n        } else { \n            count_rest \n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, times: Vec<i8>, T: i8) -> (result: i8)\n    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)\n    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    n\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0183", "language": "verus", "source": "apps", "source_id": "apps_test_909", "vc-description": "Given three positive integers a, b, and c, find the maximum possible value \nof an arithmetic expression formed by inserting operation signs ('+' or '*') \nbetween the numbers and optionally adding brackets. The numbers must remain \nin order a, b, c. All six possible expressions must be considered:\na + b + c, a + b * c, a * b + c, a * b * c, (a + b) * c, a * (b + c)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10\n}\n\nspec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {\n    seq![a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]\n}\n\nspec fn max_expression(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] { exprs[0] }\n    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] { exprs[1] }\n    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] { exprs[2] }\n    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] { exprs[3] }\n    else if exprs[4] >= exprs[5] { exprs[4] }\n    else { exprs[5] }\n}\n\nspec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    exprs.contains(result) && forall|i: int| 0 <= i < exprs.len() ==> result >= exprs[i]\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int),\n    ensures \n        is_max_of_all_expressions(result as int, a as int, b as int, c as int),\n        result as int == max_expression(a as int, b as int, c as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0185", "language": "verus", "source": "apps", "source_id": "apps_test_913", "vc-description": "Given n problems and two robots, determine the minimum possible maximum point value\nneeded to ensure the first robot scores strictly more points than the second robot.\nReturn -1 if the first robot cannot outperform the second robot.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, r: Seq<int>, b: Seq<int>) -> bool {\n    n > 0 && r.len() == n && b.len() == n &&\n    (forall|i: int| 0 <= i < n ==> (r[i] == 0 || r[i] == 1)) &&\n    (forall|i: int| 0 <= i < n ==> (b[i] == 0 || b[i] == 1))\n}\n\nspec fn robot_advantage_count(n: int, r: Seq<int>, b: Seq<int>) -> int {\n    Set::new(|i: int| 0 <= i < n && r[i] == 1 && b[i] == 0).len() as int\n}\n\nspec fn opponent_advantage_count(n: int, r: Seq<int>, b: Seq<int>) -> int {\n    Set::new(|i: int| 0 <= i < n && r[i] == 0 && b[i] == 1).len() as int\n}\n\nspec fn can_win(n: int, r: Seq<int>, b: Seq<int>) -> bool {\n    robot_advantage_count(n, r, b) > 0\n}\n\nspec fn min_max_point_value(n: int, r: Seq<int>, b: Seq<int>) -> int {\n    opponent_advantage_count(n, r, b) / robot_advantage_count(n, r, b) + 1\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, r: Vec<i8>, b: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, r@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))\n    ensures if can_win(n as int, r@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)) { result as int == min_max_point_value(n as int, r@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)) } else { result == -1 }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0186", "language": "verus", "source": "apps", "source_id": "apps_test_925", "vc-description": "Given a 2-digit number displayed on a 7-segment digital counter, count how many \n2-digit numbers (00-99) could have been the intended display before some light \nsegments potentially broke (turned off). Segments can only break by turning OFF.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 2 && \n    '0' <= input[0] <= '9' && \n    '0' <= input[1] <= '9' &&\n    (input[input.len() - 1] == '\\n' || (input[0] != '\\n' && input[1] != '\\n'))\n}\n\nspec fn good_digit_count(digit: char) -> int \n    recommends '0' <= digit <= '9'\n{\n    if digit == '0' { 2 }\n    else if digit == '1' { 7 }\n    else if digit == '2' { 2 }\n    else if digit == '3' { 3 }\n    else if digit == '4' { 3 }\n    else if digit == '5' { 4 }\n    else if digit == '6' { 2 }\n    else if digit == '7' { 5 }\n    else if digit == '8' { 1 }\n    else { 2 }\n}\n\nspec fn compute_total_good_count(input: Seq<char>) -> int \n    recommends valid_input(input)\n{\n    good_digit_count(input[0]) * good_digit_count(input[1])\n}\n\nspec fn valid_output(result: Seq<char>, expected_count: int) -> bool {\n    result.len() >= 2 && \n    result[result.len() - 1] == '\\n' &&\n    (forall|c: char| result.contains(c) ==> c == '\\n' || ('0' <= c <= '9')) &&\n    expected_count >= 1 && expected_count <= 49\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@, compute_total_good_count(input@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0187", "language": "verus", "source": "apps", "source_id": "apps_test_935", "vc-description": "Given a grid with n horizontal and m vertical sticks, two players take turns\nremoving intersection points. When an intersection is removed, all sticks \npassing through it are removed. The player who cannot make a move loses.\nAkshat goes first. Determine the winner when both players play optimally.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    1 <= n <= 100 && 1 <= m <= 100\n}\n\nspec fn game_moves(n: int, m: int) -> int {\n    if n < m { n } else { m }\n}\n\nspec fn winner(n: int, m: int) -> bool {\n    let moves = game_moves(n, m);\n    moves % 2 == 1\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: bool)\n    requires valid_input(n as int, m as int)\n    ensures result == winner(n as int, m as int)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0188", "language": "verus", "source": "apps", "source_id": "apps_test_940", "vc-description": "Given three stick lengths, find the minimum number of operations to form a triangle\nwith positive area, where each operation increases any stick's length by 1 centimeter.\nA triangle has positive area if it satisfies the triangle inequality: the sum of any\ntwo sides must be greater than the third side.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nspec fn is_triangle(a: int, b: int, c: int) -> bool {\n    a + b > c && a + c > b && b + c > a\n}\n\nspec fn min_operations_needed(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let max_val = if a >= b && a >= c { a } else if b >= c { b } else { c };\n    let sum_of_other_two = a + b + c - max_val;\n    if max_val - sum_of_other_two + 1 > 0 { max_val - sum_of_other_two + 1 } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int)\n    ensures \n        result >= 0,\n        result as int == min_operations_needed(a as int, b as int, c as int),\n        (result as int == 0) <==> is_triangle(a as int, b as int, c as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0189", "language": "verus", "source": "apps", "source_id": "apps_test_948", "vc-description": "Given an n×m grid of lowercase Latin letters, count the number of 2×2 squares \nwhere the four letters can form the word \"face\" (i.e., the four letters are \nexactly 'f', 'a', 'c', 'e' in any arrangement). Overlapping squares are counted separately.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    n >= 1 && m >= 1 && grid.len() == n &&\n    forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == m\n}\n\nspec fn count_face_squares(input: Seq<char>) -> int\n    decreases input.len()\n{\n    if input.len() == 0 {\n        0\n    } else {\n        /* Parse input and count valid face squares */\n        0  /* Placeholder - actual implementation would parse lines and count squares */\n    }\n}\n\nspec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {\n    /* Convert count to string representation */\n    seq!['0', '\\n']  /* Placeholder */\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    requires \n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        result@ == count_face_squares_as_string(input@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0190", "language": "verus", "source": "apps", "source_id": "apps_test_949", "vc-description": "Find the greatest common divisor of all integers in the range [a, b] inclusive,\nwhere 1 ≤ a ≤ b. If a = b, the GCD is a. If a < b, the GCD is 1 since\nconsecutive integers are coprime.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    1 <= a <= b\n}\n\nspec fn gcd_of_range(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n    if a == b { a } else { 1 }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int)\n    ensures \n        result as int == gcd_of_range(a as int, b as int),\n        a == b ==> result as int == a as int,\n        a < b ==> result as int == 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0191", "language": "verus", "source": "apps", "source_id": "apps_test_954", "vc-description": "Given a string, determine how many distinct strings can be obtained by repeatedly \napplying a cyclic shift operation. A cyclic shift moves the last character of the \nstring to the beginning.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>\n{\n    if s.len() > 0 { s.subrange(1, s.len() as int).add(seq![s[0]]) } else { s }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool\n{\n    s.len() > 0\n}\n\nspec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>\n    decreases steps\n{\n    if s.len() > 0 && steps > 0 { cyclic_shift_forward(apply_shifts(s, (steps - 1) as nat)) }\n    else if s.len() > 0 { s }\n    else { s }\n}\n\nspec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat\n{\n    if s.len() > 0 { s.len() } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        1 <= result <= s.len(),\n        result == all_distinct_cyclic_shifts(s@),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0192", "language": "verus", "source": "apps", "source_id": "apps_test_960", "vc-description": "Find the smallest positive integer x such that (x div k) × (x mod k) = n,\nwhere x div k is integer division and x mod k is the remainder.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 2\n}\n\nspec fn satisfies_constraint(x: int, n: int, k: int) -> bool {\n    x > 0 && k > 0 && (x / k) * (x % k) == n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result > 0,\n        satisfies_constraint(result as int, n as int, k as int),\n        forall|x: int| #[trigger] satisfies_constraint(x, n as int, k as int) ==> result as int <= x", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0193", "language": "verus", "source": "apps", "source_id": "apps_test_963", "vc-description": "Given N cells numbered 1 to N, find the number of ways to move from cell 1 to cell N.\nYou have K non-intersecting integer segments [L₁,R₁], [L₂,R₂], ..., [Lₖ,Rₖ].\nLet S be the union of all integers in these segments.\nFrom cell i, you can move to cell i+d where d ∈ S, provided i+d ≤ N.\nReturn the count modulo 998244353.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {\n    n >= 2 &&\n    k >= 1 &&\n    segments.len() == k &&\n    (forall|i: int| 0 <= i < k ==> segments[i].0 >= 1 && segments[i].1 <= n && segments[i].0 <= segments[i].1) &&\n    (forall|i: int, j: int| 0 <= i < j < k ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)\n}\n\nspec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {\n    let dp = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    let prefix_sum = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    compute_ways_dp_helper(n, k, segments, dp, prefix_sum, 2)\n}\n\nspec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int\n    decreases n - pos + 1\n{\n    if pos > n {\n        dp[n] % 998244353\n    } else {\n        let new_dp_val = compute_segment_contributions(pos, k, segments, prefix_sum, 0, 0);\n        let new_prefix_sum_val = (prefix_sum[pos-1] + new_dp_val) % 998244353;\n        let updated_dp = dp.insert(pos, new_dp_val);\n        let updated_prefix_sum = prefix_sum.insert(pos, new_prefix_sum_val);\n        compute_ways_dp_helper(n, k, segments, updated_dp, updated_prefix_sum, pos + 1)\n    }\n}\n\nspec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int\n    decreases k - seg_index\n{\n    if seg_index >= k {\n        acc\n    } else {\n        let start = segments[seg_index].0;\n        let end = segments[seg_index].1;\n        let i_s = if pos - start >= 0 { pos - start } else { 0 };\n        let i_e = if pos - end - 1 >= 0 { pos - end - 1 } else { 0 };\n        let contribution = (prefix_sum[i_s] - prefix_sum[i_e] + 998244353) % 998244353;\n        let new_acc = (acc + contribution) % 998244353;\n        compute_segment_contributions(pos, k, segments, prefix_sum, seg_index + 1, new_acc)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, segments: Vec<(i8, i8)>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n    ensures \n        result < 998244353 &&\n        result == compute_ways_dp(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0194", "language": "verus", "source": "apps", "source_id": "apps_test_965", "vc-description": "Given n players in a poker game with statuses \"ALLIN\" (A), \"IN\" (I), or \"FOLDED\" (F),\ndetermine how many players can show their hands. A player can show if their status\nis not \"FOLDED\" and all other players have status \"ALLIN\" or \"FOLDED\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, statuses: Seq<char>) -> bool {\n    n >= 2 && statuses.len() == n && \n    forall|i: int| 0 <= i < statuses.len() ==> (statuses[i] == 'A' || statuses[i] == 'I' || statuses[i] == 'F')\n}\n\nspec fn count_status(statuses: Seq<char>, status: char) -> int {\n    seq_count(statuses, status)\n}\n\nspec fn seq_count(s: Seq<char>, target: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let rest_count = seq_count(s.drop_first(), target);\n        if s[0] == target {\n            rest_count + 1\n        } else {\n            rest_count\n        }\n    }\n}\n\nspec fn expected_result(statuses: Seq<char>) -> int {\n    let cnt_i = count_status(statuses, 'I');\n    let cnt_a = count_status(statuses, 'A');\n    if cnt_i == 0 { cnt_a }\n    else if cnt_i == 1 { 1 }\n    else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, statuses: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, statuses@)\n    ensures result as int == expected_result(statuses@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0196", "language": "verus", "source": "apps", "source_id": "apps_test_967", "vc-description": "Given n threads initially ordered 1, 2, ..., n, after some messages are posted, \nthe threads are reordered such that the thread now at position i was originally \nat position a_i. When a message is posted in a thread, that thread moves to the \ntop of the list. Find the number of threads that must have received new messages.\nA thread \"surely has a new message\" if there is no possible sequence of message \nposts that could result in the given reordering without that thread receiving a message.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    0 <= result <= n\n}\n\nspec fn reversed_array(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    Seq::new(a.len(), |i: int| a[a.len() - 1 - i])\n}\n\nspec fn has_increasing_pair(ar: Seq<int>) -> bool {\n    exists|i: int| 1 <= i < ar.len() && #[trigger] ar[i] > ar[i-1]\n}\n\nspec fn min_index(ar: Seq<int>, n: int) -> int {\n    0\n}\n\nspec fn correct_result(n: int, a: Seq<int>) -> int\n    recommends valid_input(n, a)\n{\n    let ar = reversed_array(a);\n    if has_increasing_pair(ar) {\n        let min_i = min_index(ar, n);\n        n - min_i\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map_values(|x: i8| x as int))\n    ensures \n        valid_output(n as int, result as int) &&\n        result as int == correct_result(n as int, a@.map_values(|x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0197", "language": "verus", "source": "apps", "source_id": "apps_test_968", "vc-description": "Given n people, each with a first name and last name, determine if each person can choose \neither their first or last name as a handle such that when the handles are sorted \nlexicographically, they appear in the exact order specified by permutation p.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n  recommends input.len() > 0\n{\n  let parsed = parse_input(input);\n  parsed.valid && \n  parsed.n >= 1 && \n  parsed.names.len() == parsed.n &&\n  parsed.permutation.len() == parsed.n &&\n  permutation_values_in_range(parsed.permutation, parsed.n) &&\n  permutation_is_unique(parsed.permutation, parsed.n) &&\n  names_are_non_empty(parsed.names, parsed.n) &&\n  all_names_distinct(parsed.names)\n}\n\nspec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool {\n  forall|i: int| 0 <= i < n ==> {\n    let val = #[trigger] permutation[i];\n    1 <= val <= n\n  }\n}\n\nspec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool {\n  forall|i: int, j: int| 0 <= i < j < n ==> {\n    #[trigger] permutation[i] != #[trigger] permutation[j]\n  }\n}\n\nspec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool {\n  forall|i: int| 0 <= i < n ==> {\n    let name_pair = #[trigger] names[i];\n    name_pair.0.len() > 0 && name_pair.1.len() > 0\n  }\n}\n\nspec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool\n{\n  forall|i: int, j: int| 0 <= i < names.len() && 0 <= j < names.len() ==>\n    (i != j ==> {\n      let name_i = #[trigger] names[i];\n      let name_j = #[trigger] names[j];\n      name_i.0 != name_j.0 && name_i.0 != name_j.1 && \n      name_i.1 != name_j.0 && name_i.1 != name_j.1\n    })\n}\n\nspec fn can_assign_handles_greedy(input: Seq<char>) -> bool\n  recommends input.len() > 0 && valid_input(input)\n{\n  let parsed = parse_input(input);\n  let all_handles = create_all_handle_pairs(parsed.names);\n  let sorted_handles = sort_handle_pairs(all_handles);\n  greedy_assignment_works(sorted_handles, parsed.permutation, parsed.n)\n}\n\nstruct ParseResult {\n  valid: bool,\n  n: int,\n  names: Seq<(Seq<char>, Seq<char>)>,\n  permutation: Seq<int>,\n}\n\nstruct IntResult {\n  valid: bool,\n  value: int,\n}\n\nstruct IntSequenceResult {\n  valid: bool,\n  sequence: Seq<int>,\n}\n\nspec fn parse_input(input: Seq<char>) -> ParseResult\n  recommends input.len() > 0\n{\n  let lines = split_lines(input);\n  if lines.len() < 2 {\n    ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n  } else {\n    let n_result = parse_int(lines[0]);\n    if !n_result.valid || n_result.value <= 0 || lines.len() != n_result.value + 2 {\n      ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n    } else {\n      let names = parse_names(lines.subrange(1, n_result.value + 1));\n      let perm = parse_int_sequence(lines[n_result.value + 1]);\n      if names.len() == n_result.value && perm.valid && perm.sequence.len() == n_result.value {\n        ParseResult { valid: true, n: n_result.value, names: names, permutation: perm.sequence }\n      } else {\n        ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n      }\n    }\n  }\n}\n\nspec fn lex_less(a: Seq<char>, b: Seq<char>) -> bool\n  decreases a.len()\n{\n  if a.len() == 0 {\n    b.len() > 0\n  } else if b.len() == 0 {\n    false\n  } else if a[0] < b[0] {\n    true\n  } else if a[0] > b[0] {\n    false\n  } else {\n    lex_less(a.subrange(1, a.len() as int), b.subrange(1, b.len() as int))\n  }\n}\n\nspec fn lex_less_or_equal(a: Seq<char>, b: Seq<char>) -> bool\n{\n  lex_less(a, b) || a == b\n}\n\n/* Placeholder spec functions for missing dependencies */\nspec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n  seq![]\n}\n\nspec(checked) fn parse_int(line: Seq<char>) -> IntResult {\n  IntResult { valid: false, value: 0 }\n}\n\nspec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> {\n  seq![]\n}\n\nspec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult {\n  IntSequenceResult { valid: false, sequence: seq![] }\n}\n\nspec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> {\n  seq![]\n}\n\nspec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> {\n  handles\n}\n\nspec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool {\n  false\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n  requires\n    stdin_input@.len() > 0,\n    valid_input(stdin_input@),\n  ensures\n    result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n    (result@ == seq!['Y', 'E', 'S']) <==> can_assign_handles_greedy(stdin_input@),", "vc-code": "{\n  // impl-start\n  assume(false);\n  vec!['N', 'O']\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0198", "language": "verus", "source": "apps", "source_id": "apps_test_983", "vc-description": "Given an array of n integers and coefficients p, q, r, find the maximum value of \np·a_i + q·a_j + r·a_k where indices i, j, k satisfy 1 ≤ i ≤ j ≤ k ≤ n.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn max_prefix(s: Seq<int>, i: nat) -> int\n    recommends i < s.len()\n    decreases i\n{\n    if i == 0 { s[0] }\n    else if s[i as int] > max_prefix(s, (i-1) as nat) { s[i as int] }\n    else { max_prefix(s, (i-1) as nat) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { s[0] }\n    else {\n        let sub_seq = s.subrange(0, (s.len()-1) as int);\n        if s[(s.len()-1) as int] > max_seq(sub_seq) { s[(s.len()-1) as int] }\n        else { max_seq(sub_seq) }\n    }\n}\n\nspec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int\n    recommends n > 0 && a.len() == n\n{\n    let s1 = Seq::new(n as nat, |i: int| a[i] * p);\n    let s2 = Seq::new(n as nat, |i: int| max_prefix(s1, i as nat) + a[i] * q);\n    let s3 = Seq::new(n as nat, |i: int| max_prefix(s2, i as nat) + a[i] * r);\n    max_seq(s3)\n}\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool\n{\n    n > 0 && a.len() == n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, p: i8, q: i8, r: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|i, x| x as int))\n    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0199", "language": "verus", "source": "apps", "source_id": "apps_test_985", "vc-description": "Given n bishops on a 1000×1000 grid, count the number of pairs that attack each other.\nTwo bishops attack each other if and only if they are on the same diagonal (either main diagonal or anti-diagonal).\nMain diagonal: x - y is constant, Anti-diagonal: x + y is constant.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(positions: Seq<(int, int)>) -> bool {\n    positions.len() >= 1 && positions.len() <= 200000 &&\n    (forall|i: int| 0 <= i < positions.len() ==> \n        1 <= #[trigger] positions[i].0 <= 1000 && 1 <= positions[i].1 <= 1000) &&\n    (forall|i: int, j: int| 0 <= i < j < positions.len() ==> \n        #[trigger] positions[i] != #[trigger] positions[j])\n}\n\nspec fn count_attacking_pairs(positions: Seq<(int, int)>) -> int\n    recommends valid_input(positions)\n{\n    /* Count pairs (i,j) where i < j and bishops at positions[i] and positions[j] attack each other */\n    positions.len() * (positions.len() - 1) / 2 /* placeholder - actual implementation would count diagonal pairs */\n}\n\nspec fn valid_output(positions: Seq<(int, int)>, result: int) -> bool\n    recommends valid_input(positions)\n{\n    result == count_attacking_pairs(positions) && result >= 0\n}", "vc-helpers": "", "vc-spec": "fn solve_bishops(positions: Vec<(i8, i8)>) -> (result: u64)\n    requires\n        valid_input(positions@.map(|i, p: (i8, i8)| (p.0 as int, p.1 as int))),\n    ensures\n        valid_output(positions@.map(|i, p: (i8, i8)| (p.0 as int, p.1 as int)), result as int),\n        result >= 0,", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0200", "language": "verus", "source": "apps", "source_id": "apps_test_986", "vc-description": "Given n books numbered 1 to n and a library with capacity k, over n consecutive days\na person requests book a_i on day i. The library starts empty and each book costs 1 CHF.\nWhen at capacity, one existing book must be removed before adding a new one.\nFind the minimum cost to satisfy all requests using optimal cache replacement strategy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, requests: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && requests.len() == n &&\n    forall|i: int| 0 <= i < requests.len() ==> #[trigger] requests[i] >= 1 && #[trigger] requests[i] <= n\n}\n\nspec fn valid_solution(n: int, k: int, requests: Seq<int>, cost: int) -> bool {\n    valid_input(n, k, requests) && cost >= 0 && cost <= n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, requests: Vec<i8>) -> (cost: i8)\n    requires valid_input(n as int, k as int, requests@.map(|i: int, x: i8| x as int))\n    ensures valid_solution(n as int, k as int, requests@.map(|i: int, x: i8| x as int), cost as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0201", "language": "verus", "source": "apps", "source_id": "apps_test_989", "vc-description": "Given a sequence of n integers, perform at most k operations where each operation\nincreases or decreases any element by 1. Find the minimum possible difference\nbetween the maximum and minimum elements after performing these operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 5 && has_valid_format(input)\n}\n\nspec fn has_valid_format(input: Seq<char>) -> bool {\n    exists|first_newline: int| \n        0 <= first_newline < input.len() \n        && #[trigger] input[first_newline] == '\\n'\n        && (input.len() == first_newline + 1 || input[input.len() - 1] == '\\n')\n}\n\nspec fn is_valid_result_string(result: Seq<char>) -> bool {\n    result.len() > 0 && \n    (result == seq!['0'] || (result[0] != '0' && forall|i: int| 0 <= i < result.len() ==> #[trigger] is_digit(result[i])))\n}\n\nspec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) && \n    is_valid_result_string(result) &&\n    result == seq!['0']\n}\n\nspec fn max(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_max = max(a.subrange(1, a.len() as int));\n        if a[0] >= tail_max { a[0] } else { tail_max }\n    }\n}\n\nspec fn min(a: Seq<int>) -> int  \n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_min = min(a.subrange(1, a.len() as int));\n        if a[0] <= tail_min { a[0] } else { tail_min }\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_helper(n)\n    } else {\n        seq!['-'].add(int_to_string_helper(-n))\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![(n + 48) as char]\n    } else {\n        int_to_string_helper(n / 10).add(seq![(n % 10 + 48) as char])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        is_valid_result_string(result@),\n        represents_minimum_difference(stdin_input@, result@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0203", "language": "verus", "source": "apps", "source_id": "apps_test_1000", "vc-description": "Find minimum cost to travel from city 1 to city n on a straight line where adjacent cities are 1 km apart,\nroads are directional (can only go from lower to higher numbered cities), car has fuel tank capacity v liters\nconsuming 1 liter per km, and each city i sells fuel at i dollars per liter.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, v: int) -> bool {\n    2 <= n <= 100 && 1 <= v <= 100\n}\n\nspec fn min_cost(n: int, v: int) -> int {\n    let req = n - 1;\n    if req <= v {\n        req\n    } else {\n        let remaining = req - v;\n        v + remaining * (remaining + 3) / 2\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, v: i8) -> (result: i8)\n    requires valid_input(n as int, v as int)\n    ensures result as int == min_cost(n as int, v as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0204", "language": "verus", "source": "apps", "source_id": "apps_test_1002", "vc-description": "Schedule an optimal event with singer Devu and comedian Churu within a time limit.\nDevu must sing all n songs in order with 10-minute rest periods between songs.\nChuru tells 5-minute jokes during rest periods and any remaining time.\nFind the maximum number of jokes possible, or return -1 if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {\n    1 <= n <= 100 && 1 <= d <= 10000 &&\n    t.len() == n &&\n    forall|i: int| 0 <= i < t.len() ==> #[trigger] t[i] >= 1 && #[trigger] t[i] <= 100\n}\n\nspec fn min_time_needed(n: int, t: Seq<int>) -> int {\n    sum_seq(t) + 10 * (n - 1)\n}\n\nspec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {\n    let song_sum = sum_seq(t);\n    let min_time = min_time_needed(n, t);\n    if min_time > d {\n        result == -1\n    } else {\n        result == (d - song_sum) / 5 && result >= 0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, d: i8, t: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))\n    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0205", "language": "verus", "source": "apps", "source_id": "apps_test_1003", "vc-description": "Vasya starts with n pairs of socks. Each day he uses one pair and discards it.\nEvery m-th day (days m, 2m, 3m, ...), his mother buys him one new pair in the evening.\nFind the number of days Vasya can wear socks before running out.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 1 && m >= 2\n}\n\nspec fn socks_after_day(n: int, m: int, day: int) -> int {\n    if m > 0 {\n        n + day / m - day\n    } else {\n        0\n    }\n}\n\nspec fn can_wear_socks_on_day(n: int, m: int, day: int) -> bool {\n    if m > 0 {\n        day >= 1 ==> socks_after_day(n, m, day - 1) > 0\n    } else {\n        false\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: i8)\n  requires \n      valid_input(n as int, m as int)\n  ensures \n      result as int >= n as int,\n      result as int > 0,\n      socks_after_day(n as int, m as int, result as int) <= 0,\n      forall|k: int| 1 <= k < result as int ==> socks_after_day(n as int, m as int, k) > 0", "vc-code": "{\n    assume(false);\n    n\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0206", "language": "verus", "source": "apps", "source_id": "apps_test_1007", "vc-description": "Find the sum of the k smallest zcy numbers modulo p.\nA zcy number is a palindrome with even length in decimal representation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]])\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn sum_of_palindromes(k: int) -> int\n    decreases k\n{\n    if k <= 0 {\n        0\n    } else if k == 1 {\n        let s = int_to_string(1);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome)\n    } else {\n        let s = int_to_string(k);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome) + sum_of_palindromes(k - 1)\n    }\n}\n\nspec fn valid_input(k: int, p: int) -> bool {\n    k >= 1 && p >= 1\n}", "vc-helpers": "", "vc-spec": "fn solve(k: i8, p: i8) -> (result: i8)\n    requires\n        valid_input(k as int, p as int),\n    ensures\n        0 <= result < p,\n        result as int == (sum_of_palindromes(k as int) % (p as int)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "VA0208", "language": "verus", "source": "apps", "source_id": "apps_test_1009", "vc-description": "Given n cowbells with integer sizes s₁ ≤ s₂ ≤ ... ≤ sₙ and k boxes, find the minimum box size s \nsuch that all cowbells can be packed into the k boxes, where each box can hold at most 2 cowbells,\nthe sum of cowbell sizes in each box cannot exceed the box size s, and all boxes have the same size s.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && n <= 2*k &&\n    l.len() == n &&\n    forall|i: int, j: int| 0 <= i < l.len()-1 && j == i+1 ==> #[trigger] l[i] <= #[trigger] l[j] &&\n    (forall|i: int| 0 <= i < l.len() ==> #[trigger] l[i] >= 0)\n}\n\nspec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {\n    boxes.len() >= 1 &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] <= box_size) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] >= 0)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        s[0] \n    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) { \n        s[0] \n    } else { \n        max_seq(s.subrange(1, s.len() as int)) \n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))\n    ensures result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0210", "language": "verus", "source": "apps", "source_id": "apps_test_1014", "vc-description": "Given an n×n chessboard where white queen starts at (1,1), black queen at (1,n),\nand all other squares contain green pawns. Players alternate turns capturing pieces\nwith standard queen movement. Determine the winner under optimal play.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 2\n}\n\nspec fn is_win_for_white(n: int) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_win_for_black(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn optimal_white_move(n: int) -> (int, int)\n    recommends valid_input(n) && is_win_for_white(n)\n{\n    (1, 2)\n}\n\nspec fn valid_result(n: int, result: String) -> bool\n    recommends valid_input(n)\n{\n    if is_win_for_black(n) {\n        result@ == \"black\\n\"@\n    } else {\n        result@ == \"white\\n1 2\\n\"@\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: String)\n    requires valid_input(n as int)\n    ensures valid_result(n as int, result)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0211", "language": "verus", "source": "apps", "source_id": "apps_test_1017", "vc-description": "Given n stones, find the maximum number of distributions such that no two\nconsecutive distributions contain the same number of stones. Each distribution\nmust contain at least 1 stone.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn max_distributions(n: int) -> int\n    recommends valid_input(n)\n{\n    if n % 3 == 0 { 2 * (n / 3) } else { 2 * (n / 3) + 1 }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int)\n    ensures \n        result >= 1,\n        result as int == max_distributions(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0212", "language": "verus", "source": "apps", "source_id": "apps_test_1020", "vc-description": "Given a rectangular plate with dimensions w × h cells, calculate the total number of cells\nto be gilded when adding k concentric rings. Ring 1 is the border of the full w × h rectangle,\nRing 2 is the border of the inner (w-4) × (h-4) rectangle, and so on. Each ring consists of\nall cells on the perimeter of its respective rectangle.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(w: int, h: int, k: int) -> bool {\n    w >= 3 && h >= 3 && w <= 100 && h <= 100 && \n    k >= 1 && k <= ((if w <= h { w } else { h }) + 1) / 4 &&\n    w - 4 * k >= 3 && h - 4 * k >= 3\n}\n\nspec fn perimeter(w: int, h: int) -> int {\n    w * 2 + (h - 2) * 2\n}\n\nspec fn compute_sum(w: int, h: int, k: int) -> int\n    decreases k when k > 0\n{\n    if k <= 0 { 0 }\n    else { \n        perimeter(w, h) + compute_sum(w - 4, h - 4, k - 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn gild_cells(w: i8, h: i8, k: i8) -> (result: i8)\n    requires valid_input(w as int, h as int, k as int)\n    ensures result as int == compute_sum(w as int, h as int, k as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0214", "language": "verus", "source": "apps", "source_id": "apps_test_1028", "vc-description": "Given n participants split into m teams where each team has at least one participant,\nfind the minimum and maximum possible number of friendship pairs that can form.\nFriendship pairs are formed between all participants within the same team.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn comb2(n: int) -> int\n  recommends n >= 0\n{\n  n * (n - 1) / 2\n}\n\nspec fn valid_input(n: int, m: int) -> bool\n{\n  1 <= m <= n\n}\n\nspec fn min_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  let k = n / m;\n  let p = n % m;\n  p * comb2(k + 1) + (m - p) * comb2(k)\n}\n\nspec fn max_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  comb2(n - m + 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: (i8, i8))\n  requires valid_input(n as int, m as int)\n  ensures \n      result.0 >= 0 &&\n      result.1 >= 0 &&\n      result.0 <= result.1 &&\n      result.0 == min_friendship_pairs(n as int, m as int) &&\n      result.1 == max_friendship_pairs(n as int, m as int)", "vc-code": "{\n  // impl-start\n  assume(false);\n  (0, 0)\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0216", "language": "verus", "source": "apps", "source_id": "apps_test_1036", "vc-description": "Given integers n and k, simulate a Rock-Paper-Scissors tournament among 2^k players.\nEach player i has favorite hand from string s at position ((i mod n) + 1).\nTournament uses recursive bracket structure where Rock beats Scissors, \nPaper beats Rock, Scissors beats Paper, and ties go to the first player.\nReturn the favorite hand of the tournament winner.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn winner(a: char, b: char) -> char {\n    if (a, b) == ('R', 'P') || (a, b) == ('P', 'S') || (a, b) == ('S', 'R') {\n        b\n    } else {\n        a\n    }\n}\n\nspec fn valid_rps_char(c: char) -> bool {\n    c == 'R' || c == 'P' || c == 'S'\n}\n\nspec fn valid_rps_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> valid_rps_char(s[i])\n}\n\nspec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {\n    n > 0 && k >= 0 && s.len() == n && valid_rps_string(s)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, s: Vec<char>) -> (result: char)\n    requires valid_input(n as int, k as int, s@)\n    ensures valid_rps_char(result)", "vc-code": "{\n    assume(false);\n    'R'\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0217", "language": "verus", "source": "apps", "source_id": "apps_test_1038", "vc-description": "Given two integers A and B, compute f(A, B) which is the exclusive OR (XOR) of all integers \nin the range [A, B] inclusive. The XOR operation combines all bits where the result bit is 1 \nif an odd number of input integers have 1 in that bit position, and 0 if an even number do.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(a: int, b: int) -> bool {\n        0 <= a <= b\n    }\n    \n    spec fn xor_int(x: int, y: int) -> int\n        decreases x + y\n    {\n        if x >= 0 && y >= 0 {\n            if x == 0 && y == 0 { 0 }\n            else if x == 0 { y }\n            else if y == 0 { x }\n            else {\n                let bit_x = x % 2;\n                let bit_y = y % 2;\n                let xor_bit: int = if bit_x != bit_y { 1 } else { 0 };\n                xor_bit + 2 * xor_int(x / 2, y / 2)\n            }\n        } else {\n            0\n        }\n    }\n    \n    spec fn xor_range(a: int, b: int) -> int\n        decreases b - a\n    {\n        if 0 <= a <= b {\n            if a == b { a }\n            else { xor_int(a, xor_range(a + 1, b)) }\n        } else {\n            0\n        }\n    }", "vc-helpers": "", "vc-spec": "fn solve(a: i32, b: i32) -> (result: i32)\n    requires \n        a >= 0,\n        b >= 0,\n        a <= b\n    ensures \n        result >= 0,\n        result as int == xor_range(a as int, b as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\n\nfn main() {}"}
{"id": "VA0219", "language": "verus", "source": "apps", "source_id": "apps_test_1045", "vc-description": "Find the maximum height of a pyramid that can be built with n cubes, where\nlevel i requires exactly i*(i+1)/2 cubes. The pyramid is built from top to\nbottom with levels 1, 2, 3, ..., h.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn cubes_for_level(level: int) -> int\n    recommends level >= 1\n{\n    level * (level + 1) / 2\n}\n\nspec fn total_cubes_for_height(h: int) -> int\n    recommends h >= 1\n{\n    h * (h + 1) * (h + 2) / 6\n}\n\nspec fn valid_pyramid_height(n: int, h: int) -> bool {\n    valid_input(n) && h >= 1 && \n    total_cubes_for_height(h) <= n &&\n    total_cubes_for_height(h + 1) > n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures \n        result >= 1 &&\n        valid_pyramid_height(n as int, result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0221", "language": "verus", "source": "apps", "source_id": "apps_test_1048", "vc-description": "Given a sequence of movement commands for a robot on an infinite grid, find the maximum number of commands \nthat could be executed such that the robot returns to its starting position (0, 0). The robot can move \nU (up), D (down), L (left), or R (right). To return to origin, we need equal numbers of L/R movements \nand equal numbers of U/D movements.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_commands(commands: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'\n}", "vc-helpers": "", "vc-spec": "fn solve(n: usize, commands: Vec<char>) -> (result: usize)\n    requires \n        n >= 0,\n        commands@.len() == n,\n        valid_commands(commands@)\n    ensures \n        result >= 0,\n        result <= n,\n        result % 2 == 0,\n        result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + \n                         2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0223", "language": "verus", "source": "apps", "source_id": "apps_test_1052", "vc-description": "Count the number of permutations of [1, 2, ..., n] where at least n-k positions\nhave the correct value (i.e., p[i] = i for at least n-k indices i).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    4 <= n <= 1000 && 1 <= k <= 4 && k < n\n}\n\nspec fn factorial(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\nspec fn derangement(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 0 }\n    else if n == 2 { 1 }\n    else { (n - 1) * (derangement(n - 1) + derangement(n - 2)) }\n}\n\nspec fn binomial(n: int, k: int) -> int {\n    if k > n { 0 }\n    else if k == 0 || k == n { 1 }\n    else { factorial(n) / (factorial(k) * factorial(n - k)) }\n}\n\nspec fn sum_binomial_derangement(n: int, k: int, i: int) -> int\n    decreases n - k - i\n{\n    if i >= n - k { 0 }\n    else { binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires valid_input(n as int, k as int)\n    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0224", "language": "verus", "source": "apps", "source_id": "apps_test_1055", "vc-description": "Given an array of integers, apply the Thanos sort algorithm to find the maximum length \nof a sorted subarray. The algorithm works by: if the array is sorted, stop; otherwise \nchoose either the first half or second half and repeat the process.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>) -> bool {\n    a.len() > 0\n}\n\nspec fn is_sorted(x: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < x.len() ==> x[i] <= x[j]\n}\n\nspec fn thanos_sort(x: Seq<int>) -> int\n    recommends x.len() > 0\n    decreases x.len()\n{\n    let len = x.len() as int;\n    if is_sorted(x) {\n        len\n    } else {\n        let first_half = x.subrange(0, len / 2);\n        let second_half = x.subrange(len / 2, len);\n        let left_result = thanos_sort(first_half);\n        let right_result = thanos_sort(second_half);\n        if left_result > right_result { left_result } else { right_result }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>) -> (result: usize)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result as int == thanos_sort(a@.map(|i, x| x as int)),\n        1 <= result <= a.len(),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0226", "language": "verus", "source": "apps", "source_id": "apps_test_1065", "vc-description": "Given n candies and k people (numbered 1 to k), find the maximum number of candies person 1 can receive.\nPerson 1 chooses an integer x and distributes candies cyclically: first x candies to person 1, next x to person 2, \n..., next x to person k, then repeat the cycle. Remaining candies are discarded.\nConstraints: 1 ≤ x ≤ M, no person can receive candies more than D times.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, m: int, d: int) -> bool {\n    2 <= n && 2 <= k <= n && 1 <= m <= n && 1 <= d <= n && m * d * k >= n\n}\n\nspec fn candies_used(x: int, d: int, k: int) -> int {\n    x * ((d - 1) * k + 1)\n}\n\nspec fn valid_distribution(x: int, d: int, n: int, k: int, m: int, d_max: int) -> bool {\n    1 <= x <= m && 1 <= d <= d_max && candies_used(x, d, k) <= n\n}\n\nspec fn person1_candies(x: int, d: int) -> int {\n    x * d\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, m: i8, d: i8) -> (result: i8)\n    requires valid_input(n as int, k as int, m as int, d as int)\n    ensures\n        result >= 0 &&\n        result as int <= m as int * d as int &&\n        (forall|x: int, d_val: int| valid_distribution(x, d_val, n as int, k as int, m as int, d as int) ==> person1_candies(x, d_val) <= result as int) &&\n        (exists|x: int, d_val: int| valid_distribution(x, d_val, n as int, k as int, m as int, d as int) && person1_candies(x, d_val) == result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0227", "language": "verus", "source": "apps", "source_id": "apps_test_1069", "vc-description": "Calculate the value of (1^n + 2^n + 3^n + 4^n) mod 5 for a given integer n.\nThe input n is given as a string representation of a non-negative integer.\nThe result is either 4 (when n ≡ 0 mod 4) or 0 (otherwise).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn string_to_nat(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0\n  } else if s.len() == 1 {\n    (s[0] as int - '0' as int) as nat\n  } else {\n    string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) as nat\n  }\n}\n\nspec fn valid_input(n: Seq<char>) -> bool {\n  n.len() > 0 && \n  (forall|i: int| 0 <= i < n.len() ==> '0' <= #[trigger] n[i] <= '9') &&\n  (n[0] != '0' || n.len() == 1)\n}\n\nspec fn valid_output(result: String) -> bool {\n  result@ =~= seq!['4', '\\n'] || result@ =~= seq!['0', '\\n']\n}", "vc-helpers": "", "vc-spec": "fn solve(n: String) -> (result: String)\n  requires valid_input(n@)\n  ensures valid_output(result)", "vc-code": "{\n  assume(false);\n  \"0\\n\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0228", "language": "verus", "source": "apps", "source_id": "apps_test_1071", "vc-description": "Given a cupboard with n shelves, determine if all cups and medals can be placed\nfollowing constraints: cups and medals cannot be on the same shelf, each shelf\ncan hold at most 5 cups, and each shelf can hold at most 10 medals.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {\n    a.len() >= 0 && b.len() >= 0 &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 0) &&\n    (forall|j: int| 0 <= j < b.len() ==> b[j] >= 0) &&\n    n >= 1\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.drop_first()) }\n}\n\nspec fn shelves_needed(total: int, capacity: int) -> int\n    recommends capacity > 0\n{\n    if total == 0 { 0 } else { (total - 1) / capacity + 1 }\n}\n\nspec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool\n    recommends valid_input(a, b, n)\n{\n    let total_cups = sum_seq(a);\n    let total_medals = sum_seq(b);\n    let shelves_for_cups = shelves_needed(total_cups, 5);\n    let shelves_for_medals = shelves_needed(total_medals, 10);\n    shelves_for_cups + shelves_for_medals <= n\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>, b: Vec<i8>, n: i8) -> (result: String)\n    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)\n    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { \"YES\"@ } else { \"NO\"@ })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0229", "language": "verus", "source": "apps", "source_id": "apps_test_1074", "vc-description": "Given an integer a, count the number of times the digit '1' appears in its octal (base-8) representation.\nInput: A single integer a where 0 ≤ a ≤ 1,000,000\nOutput: A single integer representing the count of digit '1' in the octal representation of a", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_ones_in_octal(a: int) -> int\n    decreases a when a >= 0\n{\n    if a == 0 {\n        0int\n    } else {\n        (if a % 8 == 1 { 1int } else { 0int }) + count_ones_in_octal(a / 8)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8) -> (count: i8)\n    requires \n        a >= 0,\n    ensures \n        count >= 0,\n        count as int == count_ones_in_octal(a as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0230", "language": "verus", "source": "apps", "source_id": "apps_test_1081", "vc-description": "Given an integer a (1 ≤ a ≤ 99), determine whether it satisfies a specific condition\nand output \"YES\" or \"NO\". The condition is derived from the pattern in given examples.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 99\n}\n\nspec fn expected_result(n: int) -> bool\n    recommends valid_input(n)\n{\n    if n < 12 {\n        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 {\n            false\n        } else {\n            true\n        }\n    } else if 12 < n < 30 {\n        false\n    } else if 69 < n < 80 {\n        false\n    } else if 89 < n {\n        false\n    } else {\n        let last_digit = n % 10;\n        if last_digit != 1 && last_digit != 7 && last_digit != 9 {\n            true\n        } else {\n            false\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: bool)\nrequires \n    valid_input(n as int),\nensures \n    result == expected_result(n as int),", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0232", "language": "verus", "source": "apps", "source_id": "apps_test_1085", "vc-description": "Given a positive integer N, find how many values of K (where 2 ≤ K ≤ N) will cause N to become 1\nthrough repeated operations: if K divides N, replace N with N/K; otherwise replace N with N-K;\ncontinue until N < K. Count the number of valid K values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn reduce_by_divisor(n: nat, d: nat) -> nat {\n    if n > 0 && d > 1 && n % d == 0 && n >= d {\n        n / d\n    } else {\n        n\n    }\n}\n\nspec fn count_divisors(n: int) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 1 <= d <= n && n % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_special_divisors(n: nat) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_valid_k_values(n: nat) -> int {\n    if n > 0 {\n        if n == 1 {\n            -1\n        } else {\n            count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1\n        }\n    } else {\n        -1\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8) -> (result: i8)\n    requires \n        valid_input(n as nat)\n    ensures \n        result as int == count_valid_k_values(n as nat),\n        n == 1 ==> result as int == -1,\n        n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,\n        result as int >= -1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0233", "language": "verus", "source": "apps", "source_id": "apps_test_1096", "vc-description": "Given a king's position on a standard 8×8 chess board, determine the number of valid moves \nthe king can make. The position is given as a two-character string \"cd\" where 'c' is the \ncolumn ('a' to 'h') and 'd' is the row ('1' to '8'). A king can move exactly one square \nin any direction but cannot move outside the board boundaries.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(position: Seq<char>) -> bool {\n  position.len() == 2 && \n  'a' <= position[0] && position[0] <= 'h' && \n  '1' <= position[1] && position[1] <= '8'\n}\n\nspec fn is_corner(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h') && \n  (position[1] == '1' || position[1] == '8')\n}\n\nspec fn is_edge(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h' || \n   position[1] == '1' || position[1] == '8') && \n  !is_corner(position)\n}\n\nspec fn is_interior(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  !is_corner(position) && !is_edge(position)\n}\n\nspec fn valid_moves(position: Seq<char>) -> int\n  recommends valid_input(position)\n{\n  if is_corner(position) { 3 }\n  else if is_edge(position) { 5 }\n  else { 8 }\n}", "vc-helpers": "", "vc-spec": "fn solve(position: Vec<char>) -> (moves: i8)\n  requires \n    valid_input(position@),\n  ensures \n    moves as int == valid_moves(position@),\n    is_corner(position@) ==> moves == 3,\n    is_edge(position@) ==> moves == 5,\n    is_interior(position@) ==> moves == 8,\n    moves == 3 || moves == 5 || moves == 8,", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0234", "language": "verus", "source": "apps", "source_id": "apps_test_1100", "vc-description": "Given a regular convex polygon with n vertices, draw rays from each vertex to all others.\nRays stop when hitting vertices or intersecting previously drawn rays, creating regions.\nA squirrel starts outside and jumps between adjacent regions to collect all walnuts.\nFind the minimum number of jumps needed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 3\n}\n\nspec fn min_jumps(n: int) -> int\n    recommends valid_input(n)\n{\n    (n - 2) * (n - 2)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures result as int == min_jumps(n as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0235", "language": "verus", "source": "apps", "source_id": "apps_test_1101", "vc-description": "Given n rooms in a row (some occupied, some free) and k cows, find k+1 free rooms to book \nsuch that when one room is assigned to Farmer John and k rooms to his cows, the maximum \ndistance from Farmer John's room to any cow's room is minimized.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_placement(rooms: Seq<char>, k: int, placement: Seq<int>) -> bool {\n    placement.len() == k + 1 &&\n    (forall|i: int| 0 <= i < placement.len() ==> 0 <= #[trigger] placement[i] < rooms.len()) &&\n    (forall|i: int| 0 <= i < placement.len() ==> #[trigger] rooms[placement[i]] == '0') &&\n    (forall|i: int, j: int| 0 <= i < j < placement.len() ==> #[trigger] placement[i] != #[trigger] placement[j]) &&\n    (forall|i: int| 0 <= i < placement.len() - 1 ==> #[trigger] placement[i] < placement[i+1])\n}\n\nspec fn optimal_max_distance(placement: Seq<int>) -> int {\n    if placement.len() == 0 {\n        0\n    } else {\n        placement[0]\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: usize, k: usize, rooms: Vec<char>) -> (result: usize)\n    requires \n        n > 0 &&\n        k > 0 &&\n        k < n &&\n        rooms@.len() == n &&\n        (forall|i: int| 0 <= i < n ==> #[trigger] rooms@[i] == '0' || #[trigger] rooms@[i] == '1') &&\n        Set::new(|i: int| 0 <= i < n && rooms@[i] == '0').len() >= k + 1\n    ensures \n        result >= 0", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0236", "language": "verus", "source": "apps", "source_id": "apps_test_1102", "vc-description": "Given n cities in a row, Limak lives in city a and uses a Bear Criminal Detector (BCD) \nthat reports total criminals at each distance. He can only catch criminals where he can \ndefinitively determine their presence: at distance d with 1 city and 1 criminal reported, \nor at distance d with 2 cities and 2 criminals reported. Return total criminals caught.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {\n    n > 0 && 1 <= a <= n && x.len() == n && \n    forall|i: int| 0 <= i < n ==> (x[i] == 0 || x[i] == 1)\n}\n\nspec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int\n    decreases n + 1 - distance\n{\n    if distance > n { \n        0\n    } else {\n        let le = a_idx - distance;\n        let rg = a_idx + distance;\n        let le_valid = le >= 0 && le < n;\n        let rg_valid = rg >= 0 && rg < n;\n        let current_caught = if !le_valid && !rg_valid {\n            0\n        } else if le_valid && !rg_valid {\n            x[le]\n        } else if !le_valid && rg_valid {\n            x[rg]\n        } else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 {\n            2\n        } else {\n            0\n        };\n        if !le_valid && !rg_valid {\n            current_caught\n        } else {\n            current_caught + sum_criminals_caught(n, a_idx, x, distance + 1)\n        }\n    }\n}\n\nspec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {\n    x[a-1] + sum_criminals_caught(n, a-1, x, 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, x: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n    ensures \n        result >= 0 &&\n        result as int == total_criminals_caught(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0237", "language": "verus", "source": "apps", "source_id": "apps_test_1106", "vc-description": "Given a complete binary tree of depth n, find the minimum number of additional\nstreet lights needed so that all paths from entrance (node 1) to exits have\nthe same total number of lights.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, lights: Seq<int>) -> bool {\n    1 <= n <= 10 &&\n    lights.len() == power2(n+1) - 2 &&\n    forall|i: int| 0 <= i < lights.len() ==> #[trigger] lights[i] >= 1 && #[trigger] lights[i] <= 100\n}\n\nspec fn power2(n: int) -> int\n    decreases n\n{\n    if n <= 0 { 1 }\n    else { 2 * power2(n - 1) }\n}\n\nspec fn dfs_result(i: int, n: int, a: Seq<int>) -> (int, int) {\n    /* Placeholder implementation for complex recursive specification */\n    (0, 0)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, lights: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, lights@.map(|_i: int, x: i8| x as int))\n    ensures result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0238", "language": "verus", "source": "apps", "source_id": "apps_test_1109", "vc-description": "Given an array of length n containing only 1s and 2s, find the minimum number of elements\nto change to make the array k-periodic. An array is k-periodic if it can be represented \nas a pattern of length k repeated exactly n/k times consecutively. The constraint is that \nn is divisible by k.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    1 <= k <= n <= 100 &&\n    n % k == 0 &&\n    a.len() == n &&\n    forall|i: int| 0 <= i < a.len() ==> a[i] == 1 || a[i] == 2\n}\n\nspec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 1).len() as int\n}\n\nspec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 2).len() as int\n}\n\nspec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    let count1 = count_ones_in_column(a, n, k, col);\n    let count2 = count_twos_in_column(a, n, k, col);\n    if count1 < count2 { count1 } else { count2 }\n}\n\nspec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int\n    decreases k - col when col <= k\n{\n    if col >= k {\n        0\n    } else {\n        min_changes_for_column(a, n, k, col) + sum_min_changes_helper(a, n, k, col + 1)\n    }\n}\n\nspec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {\n    sum_min_changes_helper(a, n, k, 0)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, a@.map(|i, v| v as int))\n    ensures \n        0 <= result as int <= n as int,\n        result as int == sum_min_changes_for_all_columns(a@.map(|i, v| v as int), n as int, k as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0239", "language": "verus", "source": "apps", "source_id": "apps_test_1110", "vc-description": "Find the worst-case number of button presses needed to open a lock with n buttons.\nThe lock has a specific unknown sequence. When a button is pressed:\n- If it's the next correct button, it stays pressed\n- If it's incorrect, all pressed buttons reset\n- The lock opens when all n buttons are pressed simultaneously (sequence complete)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int) -> bool {\n        n >= 1\n    }\n    \n    spec fn worst_case_presses(n: int) -> int\n        recommends valid_input(n)\n    {\n        n * (n * n + 5) / 6\n    }", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures result as int == worst_case_presses(n as int) && result as int >= 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0240", "language": "verus", "source": "apps", "source_id": "apps_test_1116", "vc-description": "Given three integers r, b, and k, determine if it's possible to paint planks on a fence\naccording to specific rules without creating k consecutive planks of the same color.\nPaint plank i red if i is divisible by r, blue if divisible by b, either color if \ndivisible by both, and don't paint otherwise. Return \"OBEY\" if possible to avoid\nk consecutive same-color planks, \"REBEL\" if unavoidable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn gcd(a: int, b: int) -> int\n  decreases b when a > 0 && b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn valid_input(r: int, b: int, k: int) -> bool {\n  r > 0 && b > 0 && k > 0\n}\n\nspec fn max_consecutive_same_color(r: int, b: int) -> int {\n  let a = if r <= b { r } else { b };\n  let b_val = if r <= b { b } else { r };\n  let n = gcd(a, b_val);\n  -((n - b_val) / a)\n}\n\nspec fn can_avoid_consecutive(r: int, b: int, k: int) -> bool {\n  valid_input(r, b, k) && max_consecutive_same_color(r, b) < k\n}", "vc-helpers": "", "vc-spec": "fn solve(r: i8, b: i8, k: i8) -> (result: String)\n  requires valid_input(r as int, b as int, k as int)\n  ensures result@ == (if can_avoid_consecutive(r as int, b as int, k as int) { \"OBEY\"@ } else { \"REBEL\"@ })", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0241", "language": "verus", "source": "apps", "source_id": "apps_test_1117", "vc-description": "Given n rectangles in a fixed order, each rectangle can be rotated 90 degrees (swapping its width and height). \nDetermine if it's possible to rotate some rectangles such that the final heights form a non-ascending sequence \n(each height ≤ previous height).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {\n    if rectangles.len() <= 1 {\n        true\n    } else {\n        can_form_non_ascending_sequence_helper(rectangles, 1, max_spec(rectangles[0].0, rectangles[0].1))\n    }\n}\n\nspec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool\n    recommends 0 <= index <= rectangles.len()\n    decreases rectangles.len() - index\n{\n    if index >= rectangles.len() {\n        true\n    } else {\n        let a = rectangles[index].0;\n        let b = rectangles[index].1;\n        let min_dim = min_spec(a, b);\n        let max_dim = max_spec(a, b);\n\n        if min_dim > prev_height {\n            false\n        } else if min_dim <= prev_height < max_dim {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, min_dim)\n        } else {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, max_dim)\n        }\n    }\n}\n\nspec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {\n    /* Placeholder for parsing logic */\n    seq![]\n}\n\nspec fn min_spec(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn max_spec(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures result@ == \"YES\"@ || result@ == \"NO\"@\n    /* ensures result@ == \"YES\"@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0242", "language": "verus", "source": "apps", "source_id": "apps_test_1124", "vc-description": "Given N positive integers, repeatedly perform the operation: find maximum X and minimum x,\nif X != x then replace all X with (X - x), until all integers are equal.\nReturn the final common value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(values: Seq<int>) -> bool {\n    values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if a >= b { a } else { b }) when a > 0 && b > 0\n{\n    if a > 0 && b > 0 {\n        if a == b {\n            a\n        } else if a > b {\n            gcd(a - b, b)\n        } else {\n            gcd(a, b - a)\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int\n    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n{\n    if 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        if index == values.len() {\n            current\n        } else {\n            gcd_seq(values, index + 1, gcd(current, values[index as int]))\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_of_all(values: Seq<int>) -> int {\n    if values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        gcd_seq(values, 1, values[0])\n    } else {\n        1\n    }\n}", "vc-helpers": "spec fn values_as_int(values: Seq<i8>) -> Seq<int> {\n    values.map(|i, x| x as int)\n}\n", "vc-spec": "fn solve(values: Vec<i8>) -> (result: i8)\n    requires valid_input(values_as_int(values@)) && values.len() <= 127\n    ensures \n        result > 0 &&\n        result as int == gcd_of_all(values_as_int(values@)) &&\n        forall|i: int| 0 <= i < values@.len() ==> (values@[i] as int) % (result as int) == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0244", "language": "verus", "source": "apps", "source_id": "apps_test_1134", "vc-description": "Given n consecutive days of river observations where on day i there are m_i marks \nstrictly above the current water level, find the minimum possible sum of d_i over \nall n days, where d_i is the number of marks strictly below the water level on day i.\nEach day a mark is made at the current water level, marks never wash away, and the\ntotal number of marks can only stay the same or increase each day.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: Seq<int>) -> bool {\n    n > 0 && m.len() == n && \n    forall|i: int| 0 <= i < n ==> 0 <= #[trigger] m[i] < i + 1\n}\n\nspec fn valid_solution(n: int, m: Seq<int>, dm: Seq<int>) -> bool {\n    dm.len() == n && m.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] dm[i] >= #[trigger] m[i] + 1) &&\n    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] dm[i] <= dm[i + 1])\n}\n\nspec fn sum_below(m: Seq<int>, dm: Seq<int>) -> int\n    decreases m.len()\n{\n    if m.len() == 0 {\n        0\n    } else {\n        (dm[0] - 1 - m[0]) + sum_below(m.subrange(1, m.len() as int), dm.subrange(1, dm.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, m@.map(|_i, v: i8| v as int))\n    ensures result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0245", "language": "verus", "source": "apps", "source_id": "apps_test_1135", "vc-description": "Decode a string that was encoded by repeatedly extracting median characters.\nThe decoding process inserts each character from the encoded string back into\nits proper median position in the reconstructed word.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n >= 1 && n <= 2000 && s.len() == n && \n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn valid_output(result: Seq<char>, n: int) -> bool {\n    result.len() == n && \n    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] >= 'a' && #[trigger] result[i] <= 'z'\n}\n\nspec fn preserves_characters(s: Seq<char>, result: Seq<char>) -> bool {\n    s.to_multiset() == result.to_multiset()\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(n as int, s@)\n    ensures \n        valid_output(result@, n as int),\n        preserves_characters(s@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0246", "language": "verus", "source": "apps", "source_id": "apps_test_1138", "vc-description": "Given a string of movement directions ('L', 'R', 'U', 'D'), determine the minimum number \nof character changes needed so that following the directions returns to the starting position.\nReturn -1 if impossible (when string length is odd).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s.index(index) == c {\n        count_char_helper(s, c, index + 1, count + 1)\n    } else {\n        count_char_helper(s, c, index + 1, count)\n    }\n}\n\nspec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        0\n    } else if s.index(index) == c {\n        1 + count_char_from_index(s, c, index + 1)\n    } else {\n        count_char_from_index(s, c, index + 1)\n    }\n}\n\nspec fn correct_result(s: Seq<char>, result: int) -> bool {\n    (s.len() % 2 != 0 ==> result == -1) &&\n    (s.len() % 2 == 0 ==> result >= 0) &&\n    (s.len() % 2 == 0 ==> result <= s.len() / 2) &&\n    (s.len() % 2 == 0 ==> result == (abs(count_char(s, 'L') - count_char(s, 'R')) + abs(count_char(s, 'U') - count_char(s, 'D'))) / 2)\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures correct_result(s@, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0247", "language": "verus", "source": "apps", "source_id": "apps_test_1142", "vc-description": "Given a gun with magazine size k and n waves of monsters, find the minimum total bullets\nneeded to clear all waves. Each wave i has monsters that spawn at time l_i and must be\nkilled by time r_i. Shooting kills one monster instantly, reloading takes 1 time unit\nand discards remaining bullets. Waves are non-overlapping and chronological.\nReturn -1 if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n#[derive(PartialEq, Eq)]\nstruct Wave {\n    start_time: nat,\n    end_time: nat,\n    monsters: nat,\n}\n\nspec fn valid_waves(waves: Seq<Wave>) -> bool {\n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] waves[i].start_time <= waves[i].end_time &&\n        waves[i].monsters > 0 &&\n        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)\n}\n\nspec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {\n    k > 0 && \n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] can_solve_wave(waves, i as nat, k)\n}\n\nspec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let wave = waves[wave_index as int];\n        let time_available = wave.end_time - wave.start_time + 1;\n        let max_possible_shots = time_available * k;\n        wave.monsters <= max_possible_shots &&\n        (wave_index == 0 || can_reach_wave_in_time(waves, wave_index, k))\n    }\n}\n\nspec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index > 0 && wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let prev_wave = waves[wave_index as int - 1];\n        let curr_wave = waves[wave_index as int];\n        let time_gap = curr_wave.start_time - prev_wave.end_time;\n        let reloads_needed = calculate_reloads_needed(prev_wave.monsters, k);\n        reloads_needed <= time_gap\n    }\n}\n\nspec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {\n    if k > 0 {\n        if monsters <= k { \n            0 \n        } else { \n            ((monsters - 1) as int / k as int) as nat\n        }\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {\n    if k > 0 && valid_waves(waves) && can_solve_all_waves(waves, k) {\n        calculate_minimum_bullets_helper(waves, k, 0, k)\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat\n    decreases waves.len() - wave_index\n{\n    if wave_index >= waves.len() {\n        0\n    } else {\n        let wave = waves[wave_index as int];\n        if current_bullets >= wave.monsters {\n            wave.monsters + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        } else {\n            let reloads_needed = (((wave.monsters - 1) as int / k as int) + 1) as nat;\n            reloads_needed * k + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve_monster_waves(waves: Vec<Wave>, k: u8) -> (result: i32)\n    requires \n        valid_waves(waves@),\n        k > 0,\n    ensures \n        result == -1 <==> !can_solve_all_waves(waves@, k as nat),\n        result >= 0 <==> can_solve_all_waves(waves@, k as nat),\n        can_solve_all_waves(waves@, k as nat) ==> result == calculate_minimum_bullets(waves@, k as nat) as i32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0248", "language": "verus", "source": "apps", "source_id": "apps_test_1146", "vc-description": "Given n buttons and m bulbs, where each button can turn on a specific subset of bulbs,\ndetermine if it's possible to turn on all m bulbs by pressing some combination of buttons.\nReturn \"YES\" if all bulbs can be turned on, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(n: nat, m: nat, buttons: Seq<Seq<nat>>) -> bool {\n    buttons.len() == n &&\n    n >= 1 && m >= 1 &&\n    forall|i: int| 0 <= i < n ==> \n        #[trigger] buttons[i].len() >= 0 &&\n        forall|j: int| 0 <= j < buttons[i].len() ==> 1 <= #[trigger] buttons[i][j] <= m\n}\n\nspec fn union_of_all_bulbs(buttons: Seq<Seq<nat>>) -> Set<nat> {\n    Set::new(|bulb: nat| \n        exists|i: int, j: int| \n            0 <= i < buttons.len() && \n            0 <= j < buttons[i].len() && \n            #[trigger] buttons[i][j] == bulb\n    )\n}\n\nspec fn can_turn_on_all_bulbs(m: nat, buttons: Seq<Seq<nat>>) -> bool {\n    union_of_all_bulbs(buttons).finite() && union_of_all_bulbs(buttons).len() == m\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8, m: u8, buttons: Vec<Vec<u8>>) -> (result: String)\n    requires\n        valid_input(n as nat, m as nat, buttons@.map(|i: int, button: Vec<u8>| button@.map(|j: int, bulb: u8| bulb as nat))),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> can_turn_on_all_bulbs(m as nat, buttons@.map(|i: int, button: Vec<u8>| button@.map(|j: int, bulb: u8| bulb as nat)))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0249", "language": "verus", "source": "apps", "source_id": "apps_test_1149", "vc-description": "Given n levels in a game, determine if two players can together pass all levels.\nPlayer X can pass a specific set of levels, and Player Y can pass a specific set of levels.\nCheck if the union of their passable levels covers all levels from 1 to n.\nOutput \"I become the guy.\" if they can pass all levels together, otherwise \"Oh, my keyboard!\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    lines.len() >= 3 && {\n        let n = parse_int(lines[0]);\n        let x_line = parse_int_list(lines[1]);\n        let y_line = parse_int_list(lines[2]);\n        n >= 1 && x_line.len() > 0 && y_line.len() > 0 &&\n        x_line[0] >= 0 && y_line[0] >= 0 &&\n        x_line.len() >= (1 + x_line[0]) as nat && y_line.len() >= (1 + y_line[0]) as nat\n    }\n}\n\nspec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    let x_line = parse_int_list(lines[1]);\n    let y_line = parse_int_list(lines[2]);\n    let x_levels = set_from_seq(x_line.subrange(1, 1 + x_line[0] as int));\n    let y_levels = set_from_seq(y_line.subrange(1, 1 + y_line[0] as int));\n    let all_levels = x_levels.union(y_levels);\n    let required_levels = Set::new(|i: int| 1 <= i <= n);\n    if required_levels.subset_of(all_levels) { \n        Seq::new(17, |i: int| if i == 0 { 'I' } else if i == 1 { ' ' } else if i == 2 { 'b' } else if i == 3 { 'e' } else if i == 4 { 'c' } else if i == 5 { 'o' } else if i == 6 { 'm' } else if i == 7 { 'e' } else if i == 8 { ' ' } else if i == 9 { 't' } else if i == 10 { 'h' } else if i == 11 { 'e' } else if i == 12 { ' ' } else if i == 13 { 'g' } else if i == 14 { 'u' } else if i == 15 { 'y' } else { '.' })\n    } else { \n        Seq::new(16, |i: int| if i == 0 { 'O' } else if i == 1 { 'h' } else if i == 2 { ',' } else if i == 3 { ' ' } else if i == 4 { 'm' } else if i == 5 { 'y' } else if i == 6 { ' ' } else if i == 7 { 'k' } else if i == 8 { 'e' } else if i == 9 { 'y' } else if i == 10 { 'b' } else if i == 11 { 'o' } else if i == 12 { 'a' } else if i == 13 { 'r' } else if i == 14 { 'd' } else { '!' })\n    }\n}\n\nspec fn set_from_seq(s: Seq<int>) -> Set<int> {\n    Set::new(|x: int| s.contains(x))\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let newline_pos = find_char(s, '\\n');\n        if newline_pos == -1 {\n            Seq::new(1 as nat, |j: int| trim(s))\n        } else if 0 <= newline_pos < s.len() {\n            Seq::new(1 as nat, |j: int| trim(s.subrange(0, newline_pos))).add(split_lines(s.subrange(newline_pos+1, s.len() as int)))\n        } else {\n            Seq::new(1 as nat, |j: int| trim(s))\n        }\n    }\n}\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[s.len() as int - 1] == '\\r' {\n        s.subrange(0, s.len() as int - 1)\n    } else {\n        s\n    }\n}\n\nspec fn find_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == c {\n        0\n    } else {\n        let rest = find_char(s.subrange(1, s.len() as int), c);\n        if rest == -1 { -1 } else { rest + 1 }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        if is_valid_digits(s.subrange(1, s.len() as int)) { \n            -parse_int_helper(s.subrange(1, s.len() as int)) \n        } else { \n            0 \n        }\n    } else if is_valid_digits(s) { \n        parse_int_helper(s) \n    } else { \n        0 \n    }\n}\n\nspec fn is_valid_digits(s: Seq<char>) -> bool {\n    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> ('0' <= s[i] <= '9')\n}\n\nspec fn parse_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        char_to_digit(s[0])\n    } else {\n        parse_int_helper(s.subrange(0, s.len() as int - 1)) * 10 + char_to_digit(s[s.len() as int - 1])\n    }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as u32 as int) - ('0' as u32 as int)\n}\n\nspec fn parse_int_list(s: Seq<char>) -> Seq<int> {\n    let parts = split_by_char(s, ' ');\n    Seq::new(parts.len(), |i: int| parse_int(parts[i]))\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let delim_pos = find_char(s, delimiter);\n        if delim_pos == -1 {\n            Seq::new(1 as nat, |j: int| s)\n        } else if delim_pos == 0 {\n            split_by_char(s.subrange(1, s.len() as int), delimiter)\n        } else if 0 < delim_pos < s.len() {\n            Seq::new(1 as nat, |j: int| s.subrange(0, delim_pos)).add(split_by_char(s.subrange(delim_pos+1, s.len() as int), delimiter))\n        } else {\n            Seq::new(1 as nat, |j: int| s)\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(stdin_input@.map(|i, c| c as char))\n    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0250", "language": "verus", "source": "apps", "source_id": "apps_test_1150", "vc-description": "Given n regiments, each with 4 moles. Each mole has current position (x,y) and home position (a,b).\nA move rotates a mole's current position 90° counter-clockwise around its home position.\nA regiment is compact if its 4 moles form a square with non-zero area.\nFind minimum moves needed to make each regiment compact, or -1 if impossible.\n\n/* Simplified square check - just check if points form any valid square */\n\n/* Check if we have 4 equal sides and 2 equal diagonals */\n\n/* Simplified - just check if total moves is reasonable */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn valid_mole(mole: (int, int, int, int)) -> bool {\n    let (x, y, a, b) = mole;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&\n    -10000 <= a <= 10000 && -10000 <= b <= 10000\n}\n\nspec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {\n    moles.len() == 4 && forall|i: int| 0 <= i < 4 ==> #[trigger] valid_mole(moles[i])\n}\n\nspec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {\n    let dx = x - center_x;\n    let dy = y - center_y;\n    let rotations = times % 4;\n    if rotations == 0 {\n        (x, y)\n    } else if rotations == 1 {\n        (center_x - dy, center_y + dx)\n    } else if rotations == 2 {\n        (center_x - dx, center_y - dy)\n    } else {\n        (center_x + dy, center_y - dx)\n    }\n}\n\nspec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {\n    let (x1, y1) = p1;\n    let (x2, y2) = p2;\n    let dx = x1 - x2;\n    let dy = y1 - y2;\n    let dx_abs: nat = if dx >= 0 { dx as nat } else { (-dx) as nat };\n    let dy_abs: nat = if dy >= 0 { dy as nat } else { (-dy) as nat };\n    dx_abs * dx_abs + dy_abs * dy_abs\n}\n\nspec fn is_square(points: Seq<(int, int)>) -> bool\n    recommends points.len() == 4\n{\n    if points.len() != 4 {\n        false\n    } else {\n        let p0 = points[0];\n        let p1 = points[1];\n        let p2 = points[2];\n        let p3 = points[3];\n        let d01 = distance_squared(p0, p1);\n        let d02 = distance_squared(p0, p2);\n        let d03 = distance_squared(p0, p3);\n        let d12 = distance_squared(p1, p2);\n        let d13 = distance_squared(p1, p3);\n        let d23 = distance_squared(p2, p3);\n        \n        d01 > 0 && (\n            (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)\n        )\n    }\n}\n\nspec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool\n    recommends valid_regiment(moles)\n{\n    total_moves <= 12\n}\n\nspec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>\n    recommends moles.len() == 4\n{\n    if moles.len() != 4 {\n        seq![]\n    } else {\n        let (x0, y0, a0, b0) = moles[0];\n        let (x1, y1, a1, b1) = moles[1];\n        let (x2, y2, a2, b2) = moles[2];\n        let (x3, y3, a3, b3) = moles[3];\n        seq![\n            rotate_point(x0, y0, a0, b0, moves0),\n            rotate_point(x1, y1, a1, b1, moves1),\n            rotate_point(x2, y2, a2, b2, moves2),\n            rotate_point(x3, y3, a3, b3, moves3)\n        ]\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    recommends is_all_digits(s) && s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 0 || !is_all_digits(s) {\n        0\n    } else if s.len() == 1 {\n        ((s[0] as int) - ('0' as int)) as nat\n    } else {\n        string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (((s[s.len() - 1] as int) - ('0' as int)) as nat)\n    }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char>\n    recommends n <= 12\n{\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else { seq!['1', '2'] }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (output: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(output@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0251", "language": "verus", "source": "apps", "source_id": "apps_test_1165", "vc-description": "Given an array of n integers and m queries, for each query find any position \nwithin a specified range where the array value differs from a given target value.\nOutput the position (1-indexed) or -1 if no such position exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: Seq<int>, queries: Seq<(int, int, int)>) -> bool {\n    n > 0 && m >= 0 && a.len() == n && queries.len() == m &&\n    forall|q| queries.contains(q) ==> 1 <= q.0 <= q.1 <= n\n}\n\nspec fn valid_result(a: Seq<int>, queries: Seq<(int, int, int)>, result: Seq<int>) -> bool {\n    result.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> {\n        let l = queries[i].0;\n        let r = queries[i].1;\n        let x = queries[i].2;\n        (result[i] == -1 ==> (forall|j: int| l <= j <= r ==> 0 <= j-1 < a.len() && #[trigger] a[j-1] == x)) &&\n        (result[i] != -1 ==> l <= result[i] <= r && 0 <= result[i]-1 < a.len() && #[trigger] a[result[i]-1] != x)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, a: Vec<i8>, queries: Vec<(i8, i8, i8)>) -> (result: Vec<i8>)\n    requires valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int), queries@.map(|i: int, q: (i8, i8, i8)| (q.0 as int, q.1 as int, q.2 as int)))\n    ensures valid_result(a@.map(|i: int, x: i8| x as int), queries@.map(|i: int, q: (i8, i8, i8)| (q.0 as int, q.1 as int, q.2 as int)), result@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0252", "language": "verus", "source": "apps", "source_id": "apps_test_1176", "vc-description": "Given N integers in a row, find the maximum possible sum after performing operations\nwhere each operation chooses an index i and multiplies both A[i] and A[i+1] by -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn min_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 { \n        s[0] \n    } else { \n        let rest_min = min_seq(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>) -> (result: i8)\n    requires a@.len() >= 2\n    ensures ({\n        let count_neg = Set::new(|i: int| 0 <= i < a@.len() && a@[i] < 0).len();\n        let sum_abs = sum_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        let min_abs = min_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        result as int == if count_neg % 2 == 0 { sum_abs } else { sum_abs - 2 * min_abs }\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0253", "language": "verus", "source": "apps", "source_id": "apps_test_1177", "vc-description": "Given a sequence of N integers and a positive integer S, calculate the sum of f(L,R) \nover all pairs (L,R) where 1 ≤ L ≤ R ≤ N. For each pair (L,R), f(L,R) is the number \nof increasing subsequences with sum equal to S within the range [L,R].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n    n >= 1 && s >= 1 && a.len() == n && n <= 3000 && s <= 3000 &&\n    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nspec fn valid_result(result: int) -> bool {\n    result >= 0 && result < 998244353\n}\n\nspec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > s\n}\n\nspec fn single_element_case(n: int, s: int, a: Seq<int>) -> int\n    decreases n\n{\n    if n == 1 && a.len() == 1 {\n        if s == a[0] { 1 } else { 0 }\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, s: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        valid_result(result as int),\n        (result as int) % 998244353 == (result as int),\n        (n as int == 1 && s as int == a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        (n as int == 1 && s as int != a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        all_elements_greater_than_s(a@.map(|i: int, x: i8| x as int), s as int) ==> (result as int) == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0254", "language": "verus", "source": "apps", "source_id": "apps_test_1179", "vc-description": "Given n robots with unique identifiers, they play a game where robot i says identifiers\nof robots 1 through i. Find the k-th identifier pronounced in the entire sequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && l.len() == n && k <= n * (n + 1) / 2\n}\n\nspec fn total_identifiers_after_robot(i: int) -> int \n    recommends i >= 0\n{\n    i * (i + 1) / 2\n}\n\nspec fn correct_result(n: int, k: int, l: Seq<int>, result: int) -> bool\n    recommends valid_input(n, k, l)\n{\n    exists|i: int| #[trigger] total_identifiers_after_robot(i) > 0 &&\n      1 <= i <= n && \n      total_identifiers_after_robot(i - 1) < k <= total_identifiers_after_robot(i) &&\n      result == l[k - total_identifiers_after_robot(i - 1) - 1]\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, l@.map(|i: int, x: i8| x as int))\n    ensures correct_result(n as int, k as int, l@.map(|i: int, x: i8| x as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0255", "language": "verus", "source": "apps", "source_id": "apps_test_1195", "vc-description": "Given a list of n integers, compute 2 + (third_element XOR smallest_element), where:\n- third_element is the element at index 2 (third position) in the original list\n- smallest_element is the minimum value in the list\n- XOR is the bitwise exclusive OR operation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(lst: Seq<int>) -> bool {\n    5 <= lst.len() <= 10 &&\n    forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32\n}\n\nspec fn int_xor(a: int, b: int) -> int {\n    let a_bv = a as u32;\n    let b_bv = b as u32;\n    (a_bv ^ b_bv) as int\n}\n\nspec fn min_of_sequence(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = min_of_sequence(s.skip(1));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(lst: Vec<i8>) -> (result: i8)\n    requires valid_input(lst@.map(|i: int, x: i8| x as int))\n    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0257", "language": "verus", "source": "apps", "source_id": "apps_test_1211", "vc-description": "Given N hamsters and K types of boxes with capacities, find which single box type\nto buy (and how many boxes) to transport the maximum number of hamsters.\nEach box must be completely filled.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    k > 0 && a.len() == k && (forall|i: int| 0 <= i < k ==> #[trigger] a[i] > 0) && n >= 0\n}\n\nspec fn hamsters_transported(n: int, capacity: int) -> int {\n    if capacity > 0 {\n        capacity * (n / capacity)\n    } else {\n        0\n    }\n}\n\nspec fn optimal_solution(n: int, a: Seq<int>, box_type: int, num_boxes: int) -> bool {\n    valid_input(n, a.len() as int, a) &&\n    1 <= box_type <= a.len() &&\n    num_boxes == n / a[box_type - 1] &&\n    forall|i: int| 0 <= i < a.len() ==> #[trigger] hamsters_transported(n, a[box_type - 1]) >= #[trigger] hamsters_transported(n, a[i])\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: (i8, i8))\n    requires valid_input(n as int, k as int, a@.map(|i, x: i8| x as int))\n    ensures ({\n        let (box_type, num_boxes) = result;\n        1 <= box_type <= k &&\n        num_boxes >= 0 &&\n        optimal_solution(n as int, a@.map(|i, x: i8| x as int), box_type as int, num_boxes as int)\n    })", "vc-code": "{\n    assume(false);\n    (0, 0)\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0258", "language": "verus", "source": "apps", "source_id": "apps_test_1212", "vc-description": "Given a fence with n planks of heights, find k consecutive planks with the minimum sum of heights.\nReturn the 1-indexed starting position of such a sequence. If multiple solutions exist, return any valid one.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_window(heights: Seq<int>, start: int, k: int) -> int\n  decreases k\n{\n  if 0 <= start && start + k <= heights.len() && k > 0 {\n    if k == 1 { heights[start] }\n    else { heights[start] + sum_window(heights, start + 1, k - 1) }\n  } else {\n    0\n  }\n}\n\nspec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool\n{\n  1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> (1 <= #[trigger] heights[i] <= 100)\n}\n\nspec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool\n{\n  &&& valid_input(n, k, heights)\n  &&& 1 <= result <= n-k+1\n  &&& (forall|start: int| 0 <= start <= n-k ==> \n        sum_window(heights, result-1, k) <= #[trigger] sum_window(heights, start, k))\n  &&& (forall|start: int| 0 <= start < result-1 ==>\n        #[trigger] sum_window(heights, start, k) > sum_window(heights, result-1, k))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, heights: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0259", "language": "verus", "source": "apps", "source_id": "apps_test_1218", "vc-description": "Find the minimum number of splitters needed to transform 1 pipe into n pipes.\nAvailable splitters have 2, 3, 4, ..., k outputs respectively.\nEach splitter takes 1 input pipe and produces multiple output pipes.\nReturn -1 if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 2\n}\n\nspec fn impossibility_condition(n: int, k: int) -> bool\n    recommends valid_input(n, k)\n{\n    2 * (n - 1) - k * (k - 1) > 0\n}\n\nspec fn quadratic_condition(x: int, n: int, k: int) -> bool {\n    x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0\n}\n\nspec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {\n    (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0\n}\n\nspec fn valid_solution(n: int, k: int, result: int) -> bool\n    recommends valid_input(n, k)\n{\n    if impossibility_condition(n, k) {\n        result == -1\n    } else {\n        result >= 0 && result <= k &&\n        exists|x: int| #[trigger] quadratic_condition(x, n, k) &&\n            x >= 0 && \n            quadratic_condition(x, n, k) && \n            (x == 0 || next_quadratic_condition(x, n, k)) &&\n            result == k - x\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= -1,\n        (result == -1) <==> impossibility_condition(n as int, k as int),\n        valid_solution(n as int, k as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0260", "language": "verus", "source": "apps", "source_id": "apps_test_1225", "vc-description": "Given a monster with initial health H, find the minimum number of attacks needed to defeat it.\nAttack rules: If health is 1, monster dies. If health > 1, monster splits into two monsters\nwith health floor(X/2). Goal is to make all monsters have health <= 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(h: int) -> bool {\n    h >= 1\n}\n\nspec fn compute_attacks(h: int) -> int\n    recommends h >= 0\n{\n    if h == 0 { 0 }\n    else { compute_attacks_iterative(h, 0) }\n}\n\nspec fn compute_attacks_iterative(h: int, n: int) -> int\n    recommends h >= 0 && n >= 0\n    decreases h when h > 0\n{\n    if h == 0 { 0 }\n    else { pow2(n) + compute_attacks_iterative(h / 2, n + 1) }\n}\n\nspec fn pow2(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 { 1 }\n    else { 2 * pow2(n - 1) }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    parse_int_helper(s, 0, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    recommends 0 <= i <= s.len() && acc >= 0\n    decreases s.len() - i\n{\n    if i >= s.len() || s[i] == '\\n' || s[i] == ' ' {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        parse_int_helper(s, i + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n, seq![]) }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n when n > 0\n{\n    if n == 0 { acc }\n    else {\n        let digit = n % 10;\n        let digit_char = ('0' as int + digit) as char;\n        int_to_string_helper(n / 10, seq![digit_char].add(acc))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires stdin_input@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0261", "language": "verus", "source": "apps", "source_id": "apps_test_1227", "vc-description": "Count the integers from 1 to N (inclusive) that have exactly K non-zero digits \nin their decimal representation. N can be very large (up to 10^100) and K is \nbetween 1 and 3.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_non_zero_digits(n: int) -> int\n    decreases n when n >= 0\n{\n    if n == 0 { 0 }\n    else if n % 10 == 0 { count_non_zero_digits(n / 10) }\n    else { 1 + count_non_zero_digits(n / 10) }\n}\n\nspec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int\n{\n    count_range(n, k, 1, n)\n}\n\nspec fn count_range(n: int, k: int, start: int, end: int) -> int\n    decreases if end < start { 0int } else { end - start + 1 }\n{\n    if start > end { 0 }\n    else if count_non_zero_digits(start) == k { \n        1 + count_range(n, k, start + 1, end)\n    } else { \n        count_range(n, k, start + 1, end)\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 1 && k <= 3\n}", "vc-helpers": "", "vc-spec": "fn count_numbers_with_exactly_k_non_zero_digits(n: i8, k: i8) -> (count: i8)\nrequires\n    valid_input(n as int, k as int)\nensures\n    count as int == count_numbers_with_k_non_zero_digits(n as int, k as int),\n    count as int >= 0,\n    count as int <= n as int", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0262", "language": "verus", "source": "apps", "source_id": "apps_test_1228", "vc-description": "Given a current HP value, determine how much to increase it (by 0, 1, or 2) to achieve the highest possible category.\nHP categories are defined by remainder when divided by 4:\nCategory A: remainder 1 (highest priority), Category B: remainder 3, Category C: remainder 2, Category D: remainder 0 (lowest priority)\nPriority order: A > B > C > D", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn get_category(hp: int) -> char {\n        let remainder = hp % 4;\n        if remainder == 1 {\n            'A'\n        } else if remainder == 3 {\n            'B'\n        } else if remainder == 2 {\n            'C'\n        } else {\n            'D'\n        }\n    }\n    \n    spec fn valid_input(n: int) -> bool {\n        30 <= n <= 100\n    }\n    \n    spec fn valid_output(a: int, b: char) -> bool {\n        0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')\n    }\n    \n    spec fn optimal_choice(n: int, a: int, b: char) -> bool {\n        b == get_category(n + a) &&\n        ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&\n        ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&\n        ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&\n        ((n % 4 == 0) ==> (a == 1 && b == 'A'))\n    }", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: (i8, char))\n    requires \n        30 <= n <= 100\n    ensures \n        0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),\n        optimal_choice(n as int, result.0 as int, result.1),\n        result.1 == 'A' || result.1 == 'B'", "vc-code": "{\n    assume(false);\n    (0, 'A')\n}", "vc-postamble": "}\n\nfn main() {}"}
{"id": "VA0263", "language": "verus", "source": "apps", "source_id": "apps_test_1231", "vc-description": "Given two integers a and b representing counts of even and odd steps,\ndetermine if there exists a contiguous interval [l,r] of positive integers\ncontaining exactly a even-numbered steps and b odd-numbered steps.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    0 <= a <= 100 && 0 <= b <= 100\n}\n\nspec fn valid_output(result: String) -> bool {\n    result@ == \"YES\"@ || result@ == \"NO\"@\n}\n\nspec fn interval_exists(a: int, b: int) -> bool {\n    abs_spec(a - b) <= 1 && a + b > 0\n}\n\nspec fn abs_spec(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: String)\n    requires \n        valid_input(a as int, b as int)\n    ensures \n        valid_output(result) &&\n        ((result@ == \"YES\"@) <==> interval_exists(a as int, b as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0264", "language": "verus", "source": "apps", "source_id": "apps_test_1232", "vc-description": "Given two sorted arrays A and B (non-decreasing order), determine if it's possible \nto select k elements from A and m elements from B such that every selected element \nfrom A is strictly less than every selected element from B.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n_a: int, n_b: int, k: int, m: int, a: Seq<int>, b: Seq<int>) -> bool {\n    n_a >= 1 && n_b >= 1 &&\n    k >= 1 && k <= n_a &&\n    m >= 1 && m <= n_b &&\n    a.len() == n_a &&\n    b.len() == n_b\n}\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < s.len() ==> #[trigger] s.index(i) <= #[trigger] s.index(j)\n}\n\nspec fn valid_selection(a: Seq<int>, b: Seq<int>, k: int, m: int) -> bool\n    recommends k >= 1 && k <= a.len() && m >= 1 && m <= b.len()\n{\n    a[k - 1] < b[b.len() - m]\n}", "vc-helpers": "", "vc-spec": "fn solve(n_a: i8, n_b: i8, k: i8, m: i8, a: Vec<i8>, b: Vec<i8>) -> (result: &'static str)\n    requires \n        valid_input(n_a as int, n_b as int, k as int, m as int, a@.map(|i, x: i8| x as int), b@.map(|i, x: i8| x as int)),\n        is_sorted(a@.map(|i, x: i8| x as int)),\n        is_sorted(b@.map(|i, x: i8| x as int))\n    ensures \n        result == \"YES\" || result == \"NO\",\n        result == \"YES\" <==> valid_selection(a@.map(|i, x: i8| x as int), b@.map(|i, x: i8| x as int), k as int, m as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0265", "language": "verus", "source": "apps", "source_id": "apps_test_1240", "vc-description": "Given n columns of soldiers where column i has l_i soldiers starting with left leg \nand r_i soldiers starting with right leg, find which column to swap (change all \nleft-leg soldiers to right-leg and vice versa) to maximize the beauty of the parade.\nBeauty is defined as |L - R| where L is total left-leg soldiers and R is total \nright-leg soldiers across all columns. You can swap at most one column. \nOutput the 1-indexed column number to swap, or 0 if no swap improves the current beauty.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(columns: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < columns.len() ==> columns[i].0 > 0 && columns[i].1 > 0\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn sum_left(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].0 + sum_left(columns.drop_first())\n    }\n}\n\nspec fn sum_right(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].1 + sum_right(columns.drop_first())\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(columns: Vec<(i8, i8)>) -> (result: i8)\n    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))\n    ensures 0 <= result as int <= columns@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0266", "language": "verus", "source": "apps", "source_id": "apps_test_1255", "vc-description": "Given n customers visiting a cafe at specific times (hours and minutes), determine the minimum number of cash registers needed.\nEach customer takes less than a minute to serve and will leave if no register is available upon arrival.\nThe minimum number of registers equals the maximum number of customers arriving at the same time.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {\n    let lines = split_lines_function(input);\n    if lines.len() == 0 { 0 } else { max_frequency_in_all_lines(lines) }\n}\n\nspec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(s, 0, 0, seq![])\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if start < s.len() { acc.push(s.subrange(start, s.len() as int)) } else { acc }\n    } else if s[i] == '\\n' {\n        let new_acc = if start < i { acc.push(s.subrange(start, i)) } else { acc };\n        split_lines_helper(s, i + 1, i + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, i + 1, acc)\n    }\n}\n\nspec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {\n    if lines.len() == 0 { 0 } else { max_frequency_helper(lines, 0, 0) }\n}\n\nspec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { current_max }\n    else {\n        let count = count_occurrences(lines, lines[index]);\n        let new_max = if count > current_max { count } else { current_max };\n        max_frequency_helper(lines, index + 1, new_max)\n    }\n}\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {\n    count_occurrences_helper(lines, target, 0, 0)\n}\n\nspec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { count }\n    else {\n        let new_count = if lines[index] == target { count + 1 } else { count };\n        count_occurrences_helper(lines, target, index + 1, new_count)\n    }\n}\n\nspec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int\n    decreases lines.len() - index\n{\n    if index + 1 >= lines.len() { lines.len() as int }\n    else if lines[index + 1] == lines[index] { skip_identical(lines, index + 1) }\n    else { index + 1 }\n}\n\nspec fn int_to_string_function(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n > 0 { int_to_string_helper(n, seq![]) }\n    else { seq!['0'] }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    let digit = n % 10;\n    let digit_char = ('0' as u32 + digit as u32) as char;\n    if n / 10 == 0 { seq![digit_char].add(acc) }\n    else if n / 10 > 0 && n / 10 < n { int_to_string_helper(n / 10, seq![digit_char].add(acc)) }\n    else { seq![digit_char].add(acc) }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0267", "language": "verus", "source": "apps", "source_id": "apps_test_1267", "vc-description": "Given n participants with integer scores, determine the number of ways to award diplomas such that:\n1. At least one participant receives a diploma\n2. No participant with score 0 receives a diploma  \n3. If a participant with score X receives a diploma, then all participants with score >= X must also receive diplomas", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, scores: Seq<int>) -> bool {\n    n == scores.len() && n >= 1 && exists|i: int| 0 <= i < scores.len() && scores[i] != 0\n}\n\nspec fn unique_non_zero_scores(scores: Seq<int>) -> Set<int> {\n    Set::new(|x: int| exists|i: int| 0 <= i < scores.len() && scores[i] != 0 && scores[i] == x)\n}\n\nspec fn valid_result(scores: Seq<int>, result: int) -> bool {\n    result >= 1 && \n    result == unique_non_zero_scores(scores).len() && \n    result <= scores.len()\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, scores: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, scores@.map(|i, x| x as int))\n    ensures valid_result(scores@.map(|i, x| x as int), result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0269", "language": "verus", "source": "apps", "source_id": "apps_test_1282", "vc-description": "Given a string of 'M' (boys) and 'F' (girls), determine how many seconds\nit takes for all girls to move to the front of the line. Each second,\nall boys immediately in front of girls simultaneously swap positions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'M' || input[i] == 'F'\n}\n\nspec fn compute_swap_time(input: Seq<char>) -> nat\n    recommends valid_input(input)\n{\n    let rev_input = input.reverse();\n    let first_f = find_char(rev_input, 'F', 0);\n\n    if first_f == -1 { 0nat }\n    else {\n        let first_m_after_f = find_char(rev_input, 'M', first_f + 1);\n        if first_m_after_f == -1 { 0nat }\n        else {\n            let last_m = rfind_char(rev_input, 'M');\n            if last_m < first_m_after_f { 0nat }\n            else {\n                let substring = rev_input.subrange(first_m_after_f, last_m + 1);\n                let balance = calculate_balance(substring);\n                let f_count = count_char(substring, 'F');\n                (balance + f_count + first_m_after_f - first_f - 1) as nat\n            }\n        }\n    }\n}\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start] == c { start }\n    else { find_char(s, c, start + 1) }\n}\n\nspec fn rfind_char(s: Seq<char>, c: char) -> int {\n    rfind_char_helper(s, c, s.len() as int - 1)\n}\n\nspec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int\n    decreases pos + 1\n{\n    if pos < 0 { -1 }\n    else if s[pos] == c { pos }\n    else { rfind_char_helper(s, c, pos - 1) }\n}\n\nspec fn calculate_balance(s: Seq<char>) -> nat {\n    calculate_balance_helper(s, 0, 0)\n}\n\nspec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { balance as nat }\n    else if s[pos] == 'M' { calculate_balance_helper(s, pos + 1, balance + 1) }\n    else { calculate_balance_helper(s, pos + 1, if balance > 0 { balance - 1 } else { 0 }) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> nat {\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { count }\n    else if s[pos] == c { count_char_helper(s, c, pos + 1, count + 1) }\n    else { count_char_helper(s, c, pos + 1, count) }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { nat_to_string_helper(n, seq![]) }\n}\n\nspec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    if n == 0 { acc }\n    else { nat_to_string_helper(n / 10, seq![('0' as u8 + (n % 10) as u8) as char] + acc) }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|val: nat| val >= 0 && result@ == nat_to_string(val) + seq!['\\n'],\n        result@ == nat_to_string(compute_swap_time(input@)) + seq!['\\n']", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0270", "language": "verus", "source": "apps", "source_id": "apps_test_1289", "vc-description": "Given n bus stops at positions a_i (sorted in increasing order), a bus travels back and forth \nbetween stops 1 and n in order: 1→2→...→n→(n-1)→...→1→2→... repeatedly.\nGiven a segment of the bus journey as a sorted list of stop numbers with their visit frequencies,\ncalculate the total distance traveled during this segment, or return -1 if the distance cannot \nbe uniquely determined.\n\n/* Since |visits| >= 1, there must be at least one visit */\n\n/* This means at least one count > 0, so if allZero then maxRounds >= 1 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn all_distances_equal(positions: Seq<int>) -> bool {\n    if positions.len() <= 2 {\n        true\n    } else {\n        let first_dist = positions[1] - positions[0];\n        true /* simplified to avoid trigger issues */\n    }\n}\n\nspec fn count_visits(visits: Seq<int>, stop: int) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn max_val(s: Seq<int>) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn sum(s: Seq<int>) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> {\n    let base_counts = Seq::new(n as nat, |i: int| count_visits(visits, i + 1));\n    Seq::new(n as nat, |i: int| \n        if i == 0 || i == n - 1 { \n            base_counts[i] * 2 \n        } else { \n            base_counts[i] \n        }\n    )\n}\n\nspec fn compute_max_rounds(counts: Seq<int>) -> int {\n    max_val(Seq::new(counts.len(), |i: int| counts[i] / 2))\n}\n\nspec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool {\n    let counts = compute_counts(n, visits);\n    let max_rounds = compute_max_rounds(counts);\n    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);\n    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;\n\n    all_zero && n > 2 && !all_distances_equal(positions)\n}\n\nspec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int {\n    let counts = compute_counts(n, visits);\n    let max_rounds = compute_max_rounds(counts);\n    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);\n    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;\n\n    if all_zero {\n        if n == 2 {\n            max_rounds * (positions[1] - positions[0]) * 2 - (positions[1] - positions[0])\n        } else {\n            let first_dist = positions[1] - positions[0];\n            max_rounds * first_dist * 2 * (n - 1) - first_dist\n        }\n    } else {\n        let edge_distance = sum(Seq::new((n-1) as nat, |i: int| min(remaining_counts[i], remaining_counts[i+1]) * (positions[i+1] - positions[i])));\n        let total_edge_length = sum(Seq::new((n-1) as nat, |i: int| positions[i+1] - positions[i]));\n        edge_distance + max_rounds * 2 * total_edge_length\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)\n    requires\n        n >= 1,\n        positions.len() == n as nat,\n        is_sorted(positions@.map(|i, x: i8| x as int)),\n        m >= 1,\n        visits.len() == m as nat\n    ensures\n        result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n            -1\n        } else {\n            calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0271", "language": "verus", "source": "apps", "source_id": "apps_test_1290", "vc-description": "Given n columns and m squares appearing in specified columns, calculate points earned.\nEach square stacks in its column. When all columns have at least one square,\nthe bottom row is removed (earning 1 point) and squares drop down.\nReturn total points earned.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, squares: Seq<int>) -> bool {\n    n >= 1 && n <= 1000 &&\n    m >= 1 && m <= 1000 &&\n    squares.len() == m &&\n    forall|i: int| 0 <= i < squares.len() ==> #[trigger] squares[i] >= 1 && #[trigger] squares[i] <= n\n}\n\nspec fn count_occurrences(s: Seq<int>, value: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == value { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), value)\n    }\n}\n\nspec fn correct_result(n: int, squares: Seq<int>, result: int) -> bool {\n    0 <= result <= squares.len() &&\n    (forall|col: int| 1 <= col <= n ==> result <= #[trigger] count_occurrences(squares, col)) &&\n    (exists|col: int| 1 <= col <= n && result == #[trigger] count_occurrences(squares, col))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, squares: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, m as int, squares@.map(|i: int, v: i8| v as int))\n    ensures correct_result(n as int, squares@.map(|i: int, v: i8| v as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0272", "language": "verus", "source": "apps", "source_id": "apps_test_1291", "vc-description": "Given two sets of points in a 2D plane, determine if there exists a circle such that \nall points from one set are strictly inside the circle and all points from the other \nset are strictly outside the circle. Input consists of n and m (sizes of the sets), \nfollowed by n coordinate pairs for the first set, then m coordinate pairs for the \nsecond set. Output \"YES\" if such a separating circle exists, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input.index(i) == '\\n') &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() >= 3\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output == \"YES\\n\"@ || output == \"NO\\n\"@\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    if lines.len() >= 1 {\n        let first_line = lines[0];\n        let nm_parts = split_whitespace(first_line);\n        if nm_parts.len() >= 2 {\n            let n = string_to_int(nm_parts[0]);\n            let m = string_to_int(nm_parts[1]);\n            let a_lines = if lines.len() > n { lines.subrange(1, n+1) } else { Seq::empty() };\n            let b_lines = if lines.len() > n + m { lines.subrange(n+1, n+m+1) } else { Seq::empty() };\n            (n, m, first_line, a_lines, b_lines)\n        } else {\n            let a_seq = Seq::new(1, |i: int| Seq::empty());\n            let b_seq = Seq::new(1, |i: int| Seq::empty());\n            (1, 1, first_line, a_seq, b_seq)\n        }\n    } else {\n        let a_seq = Seq::new(1, |i: int| Seq::empty());\n        let b_seq = Seq::new(1, |i: int| Seq::empty());\n        (1, 1, Seq::empty(), a_seq, b_seq)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for line splitting */\n}\n\nspec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for whitespace splitting */\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0 /* placeholder for string to int conversion */\n}\n\nspec fn solve_circle_separation(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let parsed = parse_input(input);\n    let n = parsed.0;\n    let m = parsed.1;\n    let nm_string = parsed.2;\n    let a = parsed.3;\n    let b = parsed.4;\n\n    if (\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == \"-1 0\"@) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == \"-1 0\"@) ||\n        (n == 3 && m == 3 && a.len() > 0 && a[0] == \"-3 -4\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"15 70\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"28 9\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"917 -4476\"@) ||\n        (n == 3 && m == 2 && a.len() > 0 && a[0] == \"9599 -9999\"@) ||\n        (n == 145 && m == 143 && a.len() > 0 && a[0] == \"-5915 6910\"@) ||\n        (n == 2 && m == 10 && a.len() >= 2 && ((a[0] == \"-1 0\"@ && a[1] == \"0 -1\"@) || (a[0] == \"1 0\"@ && a[1] == \"0 1\"@))) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == \"0 -1\"@) ||\n        (n == 100 && m == 100 && a.len() > 0 && a[0] == \"-10000 6429\"@)\n    ) { \n        \"NO\\n\"@\n    }\n    else if (\n        (n == 4 && m == 4 && a.len() > 0 && a[0] == \"1 0\"@) ||\n        (n == 3 && m == 4 && a.len() > 0 && a[0] == \"-9998 -10000\"@) ||\n        (n == 1) ||\n        (m == 1) ||\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == \"3782 2631\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-4729 -6837\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"6558 -2280\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-5051 5846\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-4547 4547\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"7010 10000\"@) ||\n        (n == 1948 && m == 1091 && a.len() > 0 && a[0] == \"-1873 -10000\"@) ||\n        (n == 1477 && m == 1211 && a.len() > 0 && a[0] == \"2770 -10000\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"5245 6141\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"-4957 8783\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"-1729 2513\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"8781 -5556\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"5715 5323\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"-1323 290\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"6828 3257\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"1592 -154\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"-1535 5405\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && (a[0] == \"-3041 8307\"@ || a[0] == \"-2797 3837\"@ || a[0] == \"8393 -5715\"@))\n    ) { \n        \"YES\\n\"@\n    }\n    else if (n >= 1000) { \n        \"NO\\n\"@\n    }\n    else { \n        \"YES\\n\"@\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        valid_output(result@) &&\n        result@ == solve_circle_separation(stdin_input@) &&\n        result@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0273", "language": "verus", "source": "apps", "source_id": "apps_test_1298", "vc-description": "Given a binary string, repeatedly remove adjacent pairs of '0' and '1' characters.\nFind the minimum possible length after performing this operation any number of times.\nEach operation removes exactly one '0' and one '1', so the result is the absolute\ndifference between the count of '0's and '1's in the original string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] == '0' || #[trigger] s[i] == '1')\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (s[0] != '0' || s.len() == 1) && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn abs_diff_count(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    let count0 = count_char(s, '0');\n    let count1 = count_char(s, '1');\n    if count1 >= count0 { count1 - count0 } else { count0 - count1 }\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { seq!['0'] }\n    else if n < 10 { seq![char_of_digit(n)] }\n    else { int_to_string(n / 10).add(seq![char_of_digit(n % 10)]) }\n}\n\nspec fn char_of_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0int { '0' }\n    else if d == 1int { '1' }\n    else if d == 2int { '2' }\n    else if d == 3int { '3' }\n    else if d == 4int { '4' }\n    else if d == 5int { '5' }\n    else if d == 6int { '6' }\n    else if d == 7int { '7' }\n    else if d == 8int { '8' }\n    else if d == 9int { '9' }\n    else { '0' }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else if s.len() == 1 { (s[0] as int) - ('0' as int) }\n    else { string_to_int(s.subrange(0, s.len() - 1)) * 10int + ((s[s.len() - 1] as int) - ('0' as int)) }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_valid_integer(stdin_input@.subrange(0, newline_pos)) &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end))\n            }\n        },\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end)) &&\n                result@ == int_to_string(abs_diff_count(stdin_input@.subrange(newline_pos + 1, binary_end))).add(seq!['\\n'])\n            }\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "VA0274", "language": "verus", "source": "apps", "source_id": "apps_test_1301", "vc-description": "Given a pattern string containing lowercase letters and dots (representing unknown letters),\nfind which of the eight Pokémon names (vaporeon, jolteon, flareon, espeon, umbreon, leafeon, glaceon, sylveon)\nmatches the pattern exactly. Input consists of pattern length n and the pattern string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_pokemon_name(name: Seq<char>) -> bool {\n    name == seq!['v','a','p','o','r','e','o','n'] || \n    name == seq!['j','o','l','t','e','o','n'] || \n    name == seq!['f','l','a','r','e','o','n'] || \n    name == seq!['e','s','p','e','o','n'] ||\n    name == seq!['u','m','b','r','e','o','n'] || \n    name == seq!['l','e','a','f','e','o','n'] || \n    name == seq!['g','l','a','c','e','o','n'] || \n    name == seq!['s','y','l','v','e','o','n']\n}\n\nspec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool\n    recommends pokemon_name.len() == pattern.len()\n{\n    pokemon_name.len() == pattern.len() &&\n    forall|i: int| 0 <= i < pattern.len() ==> (pattern[i] == '.' || pattern[i] == pokemon_name[i])\n}\n\nspec fn get_pokemon_list() -> Seq<Seq<char>> {\n    seq![\n        seq!['v','a','p','o','r','e','o','n'],\n        seq!['j','o','l','t','e','o','n'],\n        seq!['f','l','a','r','e','o','n'],\n        seq!['e','s','p','e','o','n'],\n        seq!['u','m','b','r','e','o','n'],\n        seq!['l','e','a','f','e','o','n'],\n        seq!['g','l','a','c','e','o','n'],\n        seq!['s','y','l','v','e','o','n']\n    ]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* Additional validation logic would be implemented here */\n}\n\nspec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < pokemon_list.len() && \n        pokemon_list[i] == result &&\n        result.len() == pattern.len() &&\n        matches_pattern(result, pattern) &&\n        forall|j: int| 0 <= j < i ==> (pokemon_list[j].len() != pattern.len() || !matches_pattern(pokemon_list[j], pattern))\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_pokemon_name(result@),\n        is_first_match(result@, input@, get_pokemon_list()),\n        exists|i: int| 0 <= i < get_pokemon_list().len() && \n            get_pokemon_list()[i] == result@ &&\n            matches_pattern(result@, input@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0275", "language": "verus", "source": "apps", "source_id": "apps_test_1310", "vc-description": "Given an array of n non-negative integers, find the maximum XOR value among all possible \ncontiguous subarrays (segments of consecutive elements).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn xor_range(arr: Seq<u32>, i: int, j: int) -> u32;\n\nspec fn valid_input(arr: Seq<u32>) -> bool {\n    arr.len() > 0\n}\n\nspec fn is_max_xor_subarray(arr: Seq<u32>, result: u32) -> bool\n    recommends valid_input(arr)\n{\n    exists|i: int, j: int| 0 <= i <= j < arr.len() && result == xor_range(arr, i, j) &&\n    forall|i1: int, j1: int| 0 <= i1 <= j1 < arr.len() ==> \n        (xor_range(arr, i1, j1) as int) <= (result as int)\n}", "vc-helpers": "", "vc-spec": "fn solve(arr: Vec<u32>) -> (result: u32)\n    requires valid_input(arr@)\n    ensures is_max_xor_subarray(arr@, result)", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0276", "language": "verus", "source": "apps", "source_id": "apps_test_1312", "vc-description": "Distribute n candies among m friends such that each friend receives at least one candy\nand the difference between the maximum and minimum number of candies is minimized.\nThe optimal solution gives each friend either floor(n/m) or floor(n/m)+1 candies.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n  n >= m > 0\n}\n\nspec fn sum(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    s[0] + sum(s.subrange(1, s.len() as int)) \n  }\n}\n\nspec fn count(s: Seq<int>, val: int) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    (if s[0] == val { 1int } else { 0int }) + count(s.subrange(1, s.len() as int), val) \n  }\n}\n\nspec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {\n  &&& m > 0\n  &&& result.len() == m\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] > 0)\n  &&& sum(result) == n\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == n / m || result[i] == n / m + 1)\n  &&& count(result, n / m) == m - (n % m)\n  &&& count(result, n / m + 1) == n % m\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int, m as int)\n  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0277", "language": "verus", "source": "apps", "source_id": "apps_test_1317", "vc-description": "Given an n×n grid where each cell (i,j) contains (i² + j²) candies, count how many cells have a number of candies divisible by m.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_cells_divisible_by_m(n: int, m: int) -> int\n{\n    if 1 <= n && 1 <= m {\n        0 /* placeholder for set cardinality */\n    } else {\n        0\n    }\n}\n\nspec fn valid_input(n: int, m: int) -> bool {\n    1 <= n && 1 <= m && m <= 1000\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: i8)\n  requires \n    valid_input(n as int, m as int),\n  ensures \n    result >= 0,\n    result as int == count_cells_divisible_by_m(n as int, m as int),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0279", "language": "verus", "source": "apps", "source_id": "apps_test_1332", "vc-description": "Five players each start with the same positive number of coins b. Coins are passed between players.\nGiven the final coin distribution, determine the initial bet b, or -1 if no such positive b exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(coins: Seq<int>) -> bool {\n    coins.len() == 5 && forall|i: int| 0 <= i < coins.len() ==> #[trigger] coins[i] >= 0 && #[trigger] coins[i] <= 100\n}\n\nspec fn total_coins(coins: Seq<int>) -> int {\n    if coins.len() == 5 { coins[0] + coins[1] + coins[2] + coins[3] + coins[4] } else { 0 }\n}\n\nspec fn has_valid_solution(coins: Seq<int>) -> bool {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        total > 0 && total % 5 == 0\n    } else {\n        false\n    }\n}\n\nspec fn compute_result(coins: Seq<int>) -> int {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        if total > 0 && total % 5 == 0 { total / 5 } else { -1 }\n    } else {\n        -1\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(coins: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(coins@.map(|i, x| x as int)),\n    ensures\n        result as int == compute_result(coins@.map(|i, x| x as int)),\n        has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == total_coins(coins@.map(|i, x| x as int)) / 5,\n        !has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == -1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0282", "language": "verus", "source": "apps", "source_id": "apps_test_1353", "vc-description": "Find the minimum cost for Ann to make exactly n subway rides, given two ticket options:\nsingle-ride tickets (cost a rubles each) and multi-ride tickets (cost b rubles, covers m rides).\nAnn can buy any combination of these tickets.\n\n/* All single tickets */\n\n/* All multi-ride tickets (with potential waste) */\n\n/* Mixed: multi-ride + single for remainder */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: int, b: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    m >= 1 && m <= 1000 &&\n    a >= 1 && a <= 1000 &&\n    b >= 1 && b <= 1000\n}\n\nspec fn optimal_cost(n: int, m: int, a: int, b: int) -> int\n    recommends valid_input(n, m, a, b)\n{\n    if n * a <= ((n + m - 1) / m) * b {\n        if n * a <= (n / m) * b + (n % m) * a {\n            n * a\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    } else {\n        if ((n + m - 1) / m) * b <= (n / m) * b + (n % m) * a {\n            ((n + m - 1) / m) * b\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a as int, b as int),\n    ensures \n        result >= 0,\n        result as int == optimal_cost(n as int, m as int, a as int, b as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0284", "language": "verus", "source": "apps", "source_id": "apps_test_1356", "vc-description": "Given a string of lowercase English letters containing at least one 'a',\nfind the maximum length of a string obtainable by erasing some characters\nsuch that the resulting string has strictly more than half of its characters as 'a's.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_a(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == 'a' { 1 as int } else { 0 as int }) + count_a(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && exists|i: int| 0 <= i < s.len() && s[i] == 'a'\n}\n\nspec fn is_good_string(s: Seq<char>) -> bool {\n    s.len() > 0 && count_a(s) > s.len() as int / 2\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        result >= 1,\n        result <= s.len(),\n        result == min(2 * count_a(s@) - 1, s.len() as int) as usize,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0285", "language": "verus", "source": "apps", "source_id": "apps_test_1357", "vc-description": "Given n houses numbered 1 to n arranged in a clockwise ring with one-way clockwise traffic,\nfind the minimum time to complete m tasks in sequence. Each task must be completed at a \nspecific house. Starting at house 1, moving from one house to the next adjacent house takes \n1 time unit. Tasks must be completed in the given order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, tasks: Seq<int>) -> bool {\n    n >= 2 && m >= 1 && tasks.len() == m && \n    forall|i: int| 0 <= i < tasks.len() ==> 1 <= #[trigger] tasks[i] <= n\n}\n\nspec fn min_time_to_complete(n: int, tasks: Seq<int>, current_pos: int, task_index: int) -> int\n    recommends \n        n >= 2,\n        forall|i: int| 0 <= i < tasks.len() ==> 1 <= #[trigger] tasks[i] <= n,\n        1 <= current_pos <= n,\n        0 <= task_index < tasks.len()\n{\n    let target = tasks[task_index];\n    if target >= current_pos { target - current_pos }\n    else { (n - current_pos) + target }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, tasks: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, tasks@.map(|i, x: i8| x as int))\n    ensures \n        result >= 0,\n        m > 0 ==> result >= tasks@[(m as int) - 1] as int - 1,\n        result <= ((m as int) - 1) * (n as int) + tasks@[(m as int) - 1] as int - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0286", "language": "verus", "source": "apps", "source_id": "apps_test_1361", "vc-description": "Given n holds at increasing heights, remove exactly one hold (not the first or last) \nto minimize the track difficulty. The difficulty is the maximum difference between \nconsecutive hold heights.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(holds: Seq<int>) -> bool {\n    holds.len() >= 3 && forall|i: int| 0 <= i < holds.len() - 1 ==> #[trigger] holds[i] < holds[i + 1]\n}\n\nspec fn max_diff(s: Seq<int>) -> int {\n    if s.len() <= 1 { 0 }\n    else {\n        let max_so_far = if s[1] - s[0] >= 0 { s[1] - s[0] } else { 0 };\n        max_diff_helper(s, 2, max_so_far)\n    }\n}\n\nspec fn max_diff_helper(s: Seq<int>, index: int, current_max: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() { current_max }\n    else {\n        let diff = s[index] - s[index - 1];\n        let new_max = if diff > current_max { diff } else { current_max };\n        max_diff_helper(s, index + 1, new_max)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(holds: Vec<i8>) -> (result: i8)\n    requires valid_input(holds@.map(|i, x: i8| x as int))\n    ensures result as int >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0287", "language": "verus", "source": "apps", "source_id": "apps_test_1381", "vc-description": "Given k people who each want to make n paper airplanes, where s airplanes can be made from one sheet of paper,\nand paper is sold in packs of p sheets each, find the minimum number of packs needed to buy so that each person\nhas enough sheets to make their n airplanes.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(k: int, n: int, s: int, p: int) -> bool {\n  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&\n  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000\n}\n\nspec fn sheets_per_person(n: int, s: int) -> int\n  recommends s >= 1\n{\n  (n + s - 1) / s\n}\n\nspec fn total_sheets_needed(k: int, n: int, s: int) -> int\n  recommends s >= 1\n{\n  k * sheets_per_person(n, s)\n}\n\nspec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int\n  recommends s >= 1 && p >= 1\n{\n  (total_sheets_needed(k, n, s) + p - 1) / p\n}\n\nspec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool\n  recommends s >= 1 && p >= 1\n{\n  result == min_packs_needed(k, n, s, p) &&\n  result * p >= total_sheets_needed(k, n, s) &&\n  (result - 1) * p < total_sheets_needed(k, n, s)\n}", "vc-helpers": "", "vc-spec": "fn solve(k: i32, n: i32, s: i32, p: i32) -> (result: i32)\n  requires\n    valid_input(k as int, n as int, s as int, p as int),\n  ensures\n    result >= 1,\n    correct_result(result as int, k as int, n as int, s as int, p as int),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0289", "language": "verus", "source": "apps", "source_id": "apps_test_1394", "vc-description": "Given a string t, find a string s such that when you create s' by removing all 'a' \ncharacters from s (keeping other characters in order) and concatenate s and s' to \nform t = s + s', output the unique string s if it exists, otherwise output \":(\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn count_as(s: Seq<char>) -> int\n        decreases s.len()\n    {\n        if s.len() == 0 {\n            0\n        } else if s[0] == 'a' {\n            1 + count_as(s.subrange(1, s.len() as int))\n        } else {\n            count_as(s.subrange(1, s.len() as int))\n        }\n    }\n    \n    spec fn remove_as(s: Seq<char>) -> Seq<char>\n        decreases s.len()\n    {\n        if s.len() == 0 {\n            seq![]\n        } else if s[0] == 'a' {\n            remove_as(s.subrange(1, s.len() as int))\n        } else {\n            seq![s[0]].add(remove_as(s.subrange(1, s.len() as int)))\n        }\n    }", "vc-helpers": "", "vc-spec": "fn solve(t: Vec<char>) -> (result: Vec<char>)\n    requires t@.len() >= 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0290", "language": "verus", "source": "apps", "source_id": "apps_test_1395", "vc-description": "Given a positive integer represented as a string and a divisor m, find the minimum remainder \nwhen dividing any valid cyclic shift of the integer by m. A cyclic shift is valid if it \ndoesn't have leading zeros when interpreted as an integer.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 && exists|pos: int| 0 <= pos < stdin_input.len() && stdin_input[pos] == '\\n'\n}\n\nspec fn valid_digit_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn valid_number_string(s: Seq<char>) -> bool {\n    valid_digit_string(s) && s[0] != '0'\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 && forall|i: int| 0 <= i < result.len() ==> ('0' <= #[trigger] result[i] <= '9')\n}\n\nspec fn is_good_shift(s: Seq<char>, shift: int) -> bool \n    recommends 0 <= shift < s.len(), s.len() > 0\n{\n    s[shift] != '0'\n}\n\nspec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        valid_digit_string(s)\n{\n    cyclic_shift_remainder_helper(s, shift, m, 0, 0)\n}\n\nspec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        0 <= pos <= s.len(),\n        0 <= acc < m,\n        valid_digit_string(s)\n    decreases (s.len() - pos) when 0 <= pos <= s.len()\n{\n    if pos == s.len() { \n        acc \n    } else {\n        let idx = (shift + pos) % (s.len() as int);\n        let digit = (s[idx] as int) - ('0' as int);\n        let new_acc = (acc * 10 + digit) % m;\n        cyclic_shift_remainder_helper(s, shift, m, pos + 1, new_acc)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0291", "language": "verus", "source": "apps", "source_id": "apps_test_1409", "vc-description": "Given n students where each student has participated in ACM ICPC championship y_i times (0 ≤ y_i ≤ 5),\nform the maximum number of teams such that: each team has exactly 3 students, no student can be on \nmultiple teams, and each team can participate together at least k more times (since each student can \nparticipate at most 5 times total). Find the maximum number of teams that can be formed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_eligible(participations: Seq<int>, k: int) -> int\n    decreases participations.len()\n{\n    if participations.len() == 0 {\n        0 as int\n    } else {\n        (if 5 - participations[0] >= k { 1 as int } else { 0 as int }) + count_eligible(participations.subrange(1, participations.len() as int), k)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8, k: u8, participations: Vec<u8>) -> (result: u8)", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0292", "language": "verus", "source": "apps", "source_id": "apps_test_1419", "vc-description": "Given a text containing words separated by spaces, where some words contain hyphens\nthat serve as valid line break points, format the text to fit within at most k lines\nwhile minimizing the maximum line width. Line breaks can occur at spaces (space stays\non current line) or at hyphens (hyphen stays on current line, remainder goes to next line).\n\n/* Potential break point */\n\n/* Must break line */\n\n/* Can continue on current line or break */\n\n/* Regular character - must continue on current line */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1\n{\n    check_formatting(s, k, max_width, 0, 1, 0)\n}\n\nspec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() {\n        lines <= k && current_line <= max_width\n    } else {\n        if s[pos] == ' ' || s[pos] == '-' {\n            /* Potential break point */\n            if current_line + 1 > max_width {\n                /* Must break line */\n                if lines + 1 > k {\n                    false\n                } else {\n                    check_formatting(s, k, max_width, pos + 1, lines + 1, 1)\n                }\n            } else {\n                /* Can continue on current line or break */\n                (check_formatting(s, k, max_width, pos + 1, lines, current_line + 1) ||\n                 (lines < k && check_formatting(s, k, max_width, pos + 1, lines + 1, 1)))\n            }\n        } else {\n            /* Regular character - must continue on current line */\n            if current_line + 1 > max_width {\n                false\n            } else {\n                check_formatting(s, k, max_width, pos + 1, lines, current_line + 1)\n            }\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(k: i8, s: Vec<char>) -> (result: i8)\n    requires k >= 1,\n            s.len() >= 1,\n    ensures result >= 1,\n            result <= s@.len(),\n            can_format_text(s@, k as int, result as int),\n            result > 1 ==> !can_format_text(s@, k as int, (result - 1) as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0293", "language": "verus", "source": "apps", "source_id": "apps_test_1430", "vc-description": "Given a binary string S of length N and an integer K, find the maximum length of \nconsecutive '1's achievable using at most K flip operations. Each flip operation \nchooses a contiguous range and flips all bits in that range (0→1, 1→0).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {\n    n > 0 && k >= 0 && s.len() == n && \n    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i]) == '0' || s[i] == '1'\n}\n\nspec fn string_to_bits(s: Seq<char>) -> Seq<int>\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n{\n    Seq::new(s.len(), |i: int| if s[i] == '0' { 0 } else { 1 })\n}\n\nspec fn valid_result(result: int, n: int) -> bool {\n    0 <= result <= n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, s: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, k as int, s@)\n    ensures valid_result(result as int, n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0295", "language": "verus", "source": "apps", "source_id": "apps_test_1451", "vc-description": "Given n positive integers and a threshold k, count how many integers contain at most k lucky digits.\nLucky digits are 4 and 7.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {\n    n >= 1 && k >= 0 && numbers.len() == n && forall|i: int| 0 <= i < numbers.len() ==> numbers[i] > 0\n}\n\nspec fn count_lucky_digits(num: int) -> int\n    decreases num when num >= 0\n{\n    if num <= 0 { 0 }\n    else {\n        let digit = num % 10;\n        let rest = num / 10;\n        let digit_count: int = if digit == 4 || digit == 7 { 1 } else { 0 };\n        digit_count + count_lucky_digits(rest)\n    }\n}\n\nspec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int\n    decreases up_to when up_to >= 0\n{\n    if up_to <= 0 { 0 }\n    else {\n        let prev_count = count_valid_numbers(numbers, k, up_to - 1);\n        if count_lucky_digits(numbers[up_to - 1]) <= k { prev_count + 1 } else { prev_count }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, numbers: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures 0 <= result as int <= n as int", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0296", "language": "verus", "source": "apps", "source_id": "apps_test_1461", "vc-description": "Given a functional directed graph where each vertex i has exactly one outgoing edge\nto vertex f[i] with weight w[i], find for each starting vertex the sum and minimum\nweight of all edges on a path of exactly k edges.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {\n  n > 0 && f.len() == n && w.len() == n &&\n  (forall|i: int| #![trigger f[i]] 0 <= i < n ==> 0 <= f[i] < n) &&\n  (forall|i: int| #![trigger w[i]] 0 <= i < n ==> w[i] >= 0)\n}\n\nspec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {\n  sums.len() == n && mins.len() == n &&\n  forall|i: int| #![trigger sums[i], mins[i]] 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0\n}\n\nspec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 0 { 0 }\n  else { w[start] + path_sum(f[start], k - 1, f, w) }\n}\n\nspec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 1 { w[start] }\n  else {\n    let next_min = path_min(f[start], k - 1, f, w);\n    if w[start] <= next_min { w[start] } else { next_min }\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve_graph(n: i8, k: i8, f: Vec<i8>, w: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires \n    valid_graph(n as int, f@.map_values(|x: i8| x as int), w@.map_values(|x: i8| x as int)),\n    k > 0\n  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0297", "language": "verus", "source": "apps", "source_id": "apps_test_1486", "vc-description": "Given n cities located on a coordinate axis with positions in ascending order,\ncalculate for each city the minimum and maximum cost to send a letter to any other city.\nThe cost equals the distance between cities.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cities: Seq<int>) -> bool {\n  cities.len() >= 2 &&\n  forall|i: int, j: int| 0 <= i < j < cities.len() ==> cities[i] < cities[j]\n}\n\nspec fn min_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[i-1]\n  } else {\n    let left_dist = cities[i] - cities[i-1];\n    let right_dist = cities[i+1] - cities[i];\n    if left_dist <= right_dist { left_dist } else { right_dist }\n  }\n}\n\nspec fn max_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[cities.len()-1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[0]\n  } else {\n    let dist_to_first = cities[i] - cities[0];\n    let dist_to_last = cities[cities.len()-1] - cities[i];\n    if dist_to_first >= dist_to_last { dist_to_first } else { dist_to_last }\n  }\n}\n\nspec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {\n  valid_input(cities) &&\n  min_distances.len() == cities.len() &&\n  max_distances.len() == cities.len() &&\n  forall|i: int| 0 <= i < cities.len() ==> \n    min_distances[i] == min_distance(cities, i) &&\n    max_distances[i] == max_distance(cities, i) &&\n    min_distances[i] > 0 &&\n    max_distances[i] > 0\n}", "vc-helpers": "", "vc-spec": "fn calculate_distances(cities: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires valid_input(cities@.map(|i, v: i8| v as int))\n  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0299", "language": "verus", "source": "apps", "source_id": "apps_test_1526", "vc-description": "Given three integers A, B, and C, find the minimum number of operations to make all three equal.\nOperations: (1) Choose any two numbers and increase both by 1, (2) Choose any one number and increase it by 2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    0 <= a <= 50 && 0 <= b <= 50 && 0 <= c <= 50\n}\n\nspec fn max_of_3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a }\n    else if b >= c { b }\n    else { c }\n}\n\nspec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {\n    if a >= b && a >= c {\n        if b >= c { (a, b, c) } else { (a, c, b) }\n    } else if b >= a && b >= c {\n        if a >= c { (b, a, c) } else { (b, c, a) }\n    } else {\n        if a >= b { (c, a, b) } else { (c, b, a) }\n    }\n}\n\nspec fn min_operations(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let (a0, a1, a2) = sort_descending(a, b, c);\n    let gap1 = a0 - a1;\n    let updated_smallest = a2 + gap1;\n    let remaining_gap = a0 - updated_smallest;\n    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2\n}\n\nspec fn all_equal(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires\n        valid_input(a as int, b as int, c as int),\n    ensures\n        result >= 0,\n        all_equal(a as int, b as int, c as int) ==> result == 0,\n        result as int == min_operations(a as int, b as int, c as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0300", "language": "verus", "source": "apps", "source_id": "apps_test_1529", "vc-description": "Given n sentences from a chat record, determine the speaker of each sentence based on these patterns:\n- Freda always ends her sentences with \"lala.\"\n- Rainbow always begins his sentences with \"miao.\"\nFor each sentence, classify it as spoken by Freda, Rainbow, or unknown if it's ambiguous or matches neither pattern.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(input, 0, seq![], seq![])\n    }\n}\n\nspec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i when 0 <= i <= input.len()\n{\n    if i == input.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if i < input.len() && input[i] == '\\n' {\n        split_lines_helper(input, i + 1, seq![], acc.push(current))\n    } else if i < input.len() {\n        split_lines_helper(input, i + 1, current.push(input[i]), acc)\n    } else {\n        acc\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        acc\n    } else if i < s.len() && '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n == 0 {\n        seq![]\n    } else if n == 1 && 1 < lines.len() {\n        classify_sentence_func(lines[1])\n    } else if n > 1 && n < lines.len() {\n        build_output_func(lines, n-1) + seq!['\\n'] + classify_sentence_func(lines[n])\n    } else {\n        seq![]\n    }\n}\n\nspec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {\n    if ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) && !starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) {\n        seq!['F', 'r', 'e', 'd', 'a', '\\'', 's']\n    } else if starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) && !ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) {\n        seq!['R', 'a', 'i', 'n', 'b', 'o', 'w', '\\'', 's']\n    } else {\n        seq!['O', 'M', 'G', '>', '.', '<', ' ', 'I', ' ', 'd', 'o', 'n', '\\'', 't', ' ', 'k', 'n', 'o', 'w', '!']\n    }\n}\n\nspec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {\n    prefix.len() <= s.len() && (forall|i: int| 0 <= i < prefix.len() ==> s[i] == prefix[i])\n}\n\nspec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {\n    suffix.len() <= s.len() && (forall|i: int| 0 <= i < suffix.len() ==> s[s.len() - suffix.len() + i] == suffix[i])\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0301", "language": "verus", "source": "apps", "source_id": "apps_test_1533", "vc-description": "Given a sequence of names, for each position i, determine if that same name\nappeared at any earlier position j < i in the sequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_output(names: Seq<&str>, output: Seq<&str>) -> bool {\n    output.len() == names.len() &&\n    forall|i: int| 0 <= i < names.len() ==> \n        output[i] == (if exists|j: int| 0 <= j < i && names[j] == names[i] { \"YES\" } else { \"NO\" })\n}", "vc-helpers": "", "vc-spec": "fn solve(names: Vec<&str>) -> (output: Vec<&str>)\n    ensures valid_output(names@, output@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0302", "language": "verus", "source": "apps", "source_id": "apps_test_1541", "vc-description": "Given a string representing a lever with weights and a pivot, determine if the lever\ntilts left, right, or remains balanced based on torque calculations.\nThe pivot is marked by '^', weights are digits 1-9, and empty positions are '='.\nTorque = weight × distance from pivot. Left weights contribute positive torque,\nright weights contribute negative torque.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_lever_input(s: Seq<char>) -> bool {\n        s.len() >= 3 &&\n        (exists|i: int| 0 <= i < s.len() && s[i] == '^') &&\n        (forall|i: int| 0 <= i < s.len() ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&\n        (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == '^' ==> s[j] != '^') &&\n        (forall|i: int| 0 <= i < s.len() && s[i] == '^' ==> (i != 0 && i != s.len() - 1))\n    }\n    \n    spec fn find_pivot(s: Seq<char>) -> int {\n        find_pivot_helper(s, 0)\n    }\n    \n    spec fn find_pivot_helper(s: Seq<char>, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if s[index] == '^' {\n            index\n        } else {\n            find_pivot_helper(s, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0)\n    }\n    \n    spec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if '1' <= s[index] <= '9' {\n            let weight = (s[index] as int) - ('0' as int);\n            (pivot_pos - index) * weight + calculate_torque_helper(s, pivot_pos, index + 1)\n        } else {\n            calculate_torque_helper(s, pivot_pos, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0) - calculate_torque_helper(s, pivot_pos, up_to)\n    }", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_lever_input(s@)\n    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0304", "language": "verus", "source": "apps", "source_id": "apps_test_1550", "vc-description": "Given a combination lock display with n digits, find the smallest possible number \nachievable using two operations: (1) Add 1 to all digits (9 wraps to 0), and \n(2) Shift all digits one position right (rightmost digit becomes leftmost).\nLeading zeros are ignored when comparing numbers for size.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, digits: Seq<char>) -> bool {\n    n > 0 && digits.len() == n && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= '0' && #[trigger] digits[i] <= '9'\n}\n\nspec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {\n    let key = if s[index] == '0' { 0 } else { 10 - (s[index] as int - '0' as int) };\n    let transformed = transform_digits(s, key);\n    rotate_string(transformed, index)\n}\n\nspec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let digit = (s[0] as int - '0' as int + key) % 10;\n        seq![('0' as int + digit) as char].add(transform_digits(s.skip(1), key))\n    }\n}\n\nspec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        s.skip(index).add(s.take(index))\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n    decreases input.len()\n{\n    parse_input_helper(input, 0, seq![], seq![])\n}\n\nspec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i\n{\n    if i >= input.len() {\n        if current_line.len() > 0 { lines.push(current_line) } else { lines }\n    } else if input[i] == '\\n' {\n        parse_input_helper(input, i + 1, seq![], lines.push(current_line))\n    } else {\n        parse_input_helper(input, i + 1, current_line.push(input[i]), lines)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        0\n    } else {\n        (s[0] as int - '0' as int) + 10 * parse_int(s.skip(1))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        string_to_int(s.skip(1))\n    } else {\n        (s[0] as int - '0' as int) * pow(10, (s.len() - 1) as nat) + string_to_int(s.skip(1))\n    }\n}\n\nspec fn pow(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        (exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n'),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let lines = parse_input(stdin_input@);\n            if lines.len() >= 2 {\n                let n = parse_int(lines[0]);\n                let digits = lines[1];\n                if valid_input(n, digits) {\n                    let min_result = result@.take(result@.len() - 1);\n                    min_result.len() == n &&\n                    (forall|i: int| 0 <= i < min_result.len() ==> #[trigger] min_result[i] >= '0' && #[trigger] min_result[i] <= '9') &&\n                    (exists|index: int| 0 <= index < n && min_result == modify_string(digits, index)) &&\n                    (forall|index: int| 0 <= index < n ==> string_to_int(min_result) <= string_to_int(modify_string(digits, index)))\n                } else {\n                    result@ == seq!['\\n']\n                }\n            } else {\n                result@ == seq!['\\n']\n            }\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0305", "language": "verus", "source": "apps", "source_id": "apps_test_1568", "vc-description": "Given n messages arriving at specified times, determine the maximum money achievable by time T.\nEach message has initial value A that decreases by B per minute after arrival.\nEarn C per unread message per minute. All messages must be read by time T.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    1 <= a <= 1000 &&\n    1 <= b <= 1000 &&\n    1 <= c <= 1000 &&\n    1 <= t <= 1000 &&\n    arrivals.len() == n &&\n    forall|i: int| 0 <= i < arrivals.len() ==> #[trigger] arrivals[i] >= 1 && #[trigger] arrivals[i] <= t\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {\n    if b > c {\n        n * a\n    } else {\n        n * a + (c - b) * (n * t - sum_seq(arrivals))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8, c: i8, t: i8, arrivals: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0306", "language": "verus", "source": "apps", "source_id": "apps_test_1576", "vc-description": "Decrypt a string that was encrypted using the Right-Left cipher.\nThe Right-Left cipher encrypts by starting with the first character,\nthen alternating between appending to the right (even positions) and\nprepending to the left (odd positions) for subsequent characters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(t: Seq<char>) -> bool {\n    t.len() >= 1\n}", "vc-helpers": "", "vc-spec": "fn solve(t: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(t@)\n    ensures result@.len() == t@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0307", "language": "verus", "source": "apps", "source_id": "apps_test_1577", "vc-description": "Given a string input containing two lines: an integer n and a string s of length n with only 'A' and 'D' characters,\ndetermine which character appears more frequently. Return \"Anton\" if 'A' appears more, \"Danik\" if 'D' appears more,\nor \"Friendship\" if they appear equally.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|newline_pos: int| 0 <= newline_pos < input.len() && input[newline_pos] == '\\n'\n}\n\nspec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_game_string(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let s = lines[1];\n        s.len() == n && n >= 1\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_game_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'D'\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {\n    if count_a > count_d {\n        seq!['A', 'n', 't', 'o', 'n']\n    } else if count_d > count_a {\n        seq!['D', 'a', 'n', 'i', 'k']\n    } else {\n        seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p']\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn string_to_int(s: Seq<char>) -> int;", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@) &&\n        valid_parsed_input(split_lines(input@))\n    ensures \n        result@ == seq!['A', 'n', 't', 'o', 'n'] || \n        result@ == seq!['D', 'a', 'n', 'i', 'k'] || \n        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&\n        result@ == {\n            let lines = split_lines(input@);\n            let s = lines[1];\n            let count_a = count_char(s, 'A');\n            let count_d = count_char(s, 'D');\n            determine_winner(count_a, count_d)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0308", "language": "verus", "source": "apps", "source_id": "apps_test_1578", "vc-description": "Given an integer N, find a permutation P₁, P₂, ..., Pₙ of numbers 1 to N\nthat maximizes the sum M₁ + M₂ + ... + Mₙ, where Mᵢ is the remainder when i is divided by Pᵢ.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn max_sum(n: int) -> int\n    recommends n >= 1\n{\n    n * (n - 1) / 2\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures result as int == max_sum(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0310", "language": "verus", "source": "apps", "source_id": "apps_test_1594", "vc-description": "Given a playlist of n songs where song i has duration t_i minutes and is played c_i consecutive times.\nThe playlist plays songs in order: song 1 (c_1 times), then song 2 (c_2 times), etc.\nFor m given time moments, determine which song number is playing at each moment.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int\n  recommends \n    n >= 0,\n    songs.len() >= n,\n    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases n\n  when n >= 0 && songs.len() >= n\n{\n  if n == 0 { \n    0 \n  } else { \n    songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1) \n  }\n}\n\nspec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int\n  recommends \n    song_idx >= -1,\n    songs.len() > song_idx,\n    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases song_idx + 1\n  when song_idx >= -1 && songs.len() > song_idx\n{\n  if song_idx == -1 { \n    0 \n  } else { \n    songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1) \n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, songs: Vec<(i8, i8)>, queries: Vec<i8>) -> (result: Vec<i8>)\n  requires \n    n >= 0,\n    m >= 0,\n    songs.len() == n as nat,\n    queries.len() == m as nat,\n    forall|i: int| #![trigger songs[i]] 0 <= i < n as int ==> songs[i].0 > 0 && songs[i].1 > 0,\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int - 1 ==> queries[i] < queries[i + 1],\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int ==> queries[i] >= 1,\n    m == 0 || queries[(m-1) as int] as int <= sum_playlist_duration(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), n as int)\n  ensures \n    result.len() == m as nat,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> 1 <= result[i] as int <= n as int,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> queries[i] as int <= cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 1),\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> result[i] as int == 1 || queries[i] as int > cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 2)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0311", "language": "verus", "source": "apps", "source_id": "apps_test_1598", "vc-description": "Given a binary string s, find a binary string t of the same length such that\nfor every substring s[l..r] and t[l..r], they have the same length of longest\nnon-decreasing subsequence, and the number of zeros in t is maximized.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {\n    if str.len() == 0 {\n        0\n    } else if str.len() == 1 {\n        1\n    } else {\n        longest_non_decreasing_subseq_helper(str, 1, 1, 1)\n    }\n}\n\nspec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat\n    decreases str.len() - i\n{\n    if i >= str.len() {\n        max_len\n    } else {\n        let new_current_len = if str[i] >= str[i-1] { current_len + 1 } else { 1 };\n        let new_max_len = if new_current_len > max_len { new_current_len } else { max_len };\n        longest_non_decreasing_subseq_helper(str, i + 1, new_current_len, new_max_len)\n    }\n}\n\nspec fn count_zeros(str: Seq<char>) -> nat\n    decreases str.len()\n{\n    if str.len() == 0 {\n        0\n    } else if str[0] == '0' {\n        1 + count_zeros(str.subrange(1, str.len() as int))\n    } else {\n        count_zeros(str.subrange(1, str.len() as int))\n    }\n}\n\nspec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {\n    forall|l: int, r: int| 0 <= l <= r <= s.len() ==> \n        longest_non_decreasing_subseq(s.subrange(l, r)) == longest_non_decreasing_subseq(t.subrange(l, r))\n}\n\nspec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && same_subsequence_lengths(s, t)\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_binary_string(s@),\n    ensures\n        valid_solution(s@, result@),", "vc-code": "{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0312", "language": "verus", "source": "apps", "source_id": "apps_test_1605", "vc-description": "Given a string of length n containing only 'a' and 'b' characters, count the number of \"good\" substrings of even length and odd length.\nA substring is \"good\" if after merging all consecutive equal characters, the resulting string is a palindrome.\nFor example: \"aabba\" becomes \"aba\" after merging, which is a palindrome, so \"aabba\" is good.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'a' || s[i] == 'b'\n}\n\nspec fn merge_consecutive(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s.len() == 1 {\n        s\n    } else if s[0] == s[1] {\n        merge_consecutive(s.subrange(1, s.len() as int))\n    } else {\n        seq![s[0]].add(merge_consecutive(s.subrange(1, s.len() as int)))\n    }\n}\n\nspec fn is_palindrome(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        true\n    } else {\n        s[0] == s[s.len() - 1] && is_palindrome(s.subrange(1, s.len() - 1))\n    }\n}\n\nspec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {\n    &&& valid_input(s)\n    &&& 0 <= i <= j < s.len()\n    &&& {\n        let sub = s.subrange(i, j + 1);\n        is_palindrome(merge_consecutive(sub))\n    }\n}\n\nspec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {\n    &&& valid_input(s)\n    &&& even_count >= 0\n    &&& odd_count >= 0\n    &&& even_count + odd_count >= s.len()\n    &&& odd_count >= s.len()\n    &&& (s.len() == 1 ==> even_count == 0 && odd_count == 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: (u32, u32))\n    requires valid_input(s@)\n    ensures valid_output(s@, result.0 as int, result.1 as int)", "vc-code": "{\n    assume(false);\n    (0, 0)\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0315", "language": "verus", "source": "apps", "source_id": "apps_test_1618", "vc-description": "Given a staircase with n stairs at non-decreasing heights, process m boxes thrown sequentially.\nEach box has width w and height h, covering stairs 1 through w. A box falls until its bottom \ntouches either a stair top or a previously placed box top within its coverage area.\nDetermine the landing height of each box's bottom.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn max(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn valid_stairs(stair_heights: Seq<int>) -> bool {\n    stair_heights.len() >= 1 &&\n    (forall|i: int| 0 <= i < stair_heights.len() - 1 ==> #[trigger] stair_heights[i] <= stair_heights[add(i, 1)]) &&\n    (forall|i: int| 0 <= i < stair_heights.len() ==> #[trigger] stair_heights[i] >= 0)\n}\n\nspec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {\n    forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1\n}\n\nspec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool\n    recommends \n        stair_heights.len() >= 1,\n        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()\n{\n    result.len() == boxes.len() &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] >= stair_heights[0] && result[i] >= stair_heights[sub(boxes[i].0, 1)]) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] == max(if i == 0 { stair_heights[0] } else { result[sub(i, 1)] + boxes[sub(i, 1)].1 }, \n                        stair_heights[sub(boxes[i].0, 1)]))\n}", "vc-helpers": "", "vc-spec": "fn solve(stairs_amount: i8, stair_heights: Vec<i8>, boxes_amount: i8, boxes: Vec<(i8, i8)>) -> (result: Vec<i8>)\n    requires \n        stairs_amount >= 1,\n        stair_heights.len() == stairs_amount as int,\n        boxes_amount >= 0,\n        boxes.len() == boxes_amount as int,\n        valid_stairs(stair_heights@.map(|i: int, x: i8| x as int)),\n        valid_boxes(boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stairs_amount as int),\n    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0316", "language": "verus", "source": "apps", "source_id": "apps_test_1620", "vc-description": "Given a positive integer n, construct a string of length n using only characters 'a', 'b', and 'c' such that:\n1. The string contains no palindromic substrings of length 3\n2. The number of 'c' characters is minimized", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn valid_output(s: &Seq<char>, n: int) -> bool {\n  s.len() == n &&\n  (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == 'a' || s[i] == 'b' || s[i] == 'c') &&\n  (forall|i: int| 0 <= i <= s.len() - 3 ==> !(#[trigger] s[i] == s[i+2]))\n}\n\nspec fn minimal_c_usage(s: &Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == 'a' || s[i] == 'b'\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<char>)\n  requires \n    valid_input(n as int)\n  ensures \n    valid_output(&result@, n as int) &&\n    minimal_c_usage(&result@)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0317", "language": "verus", "source": "apps", "source_id": "apps_test_1621", "vc-description": "Given a string of lowercase letters and a value for each letter, calculate the maximum \npossible value of a string after inserting exactly k lowercase letters. The value of a \nstring s = s₁s₂...sₙ is defined as f(s) = Σᵢ₌₁ⁿ (wₛᵢ × i), where wₛᵢ is the value of \ncharacter sᵢ and i is its 1-indexed position.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn string_value(s: Seq<char>, w: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 }\n  else {\n    let char_index = (s.last() as int) - ('a' as int);\n    string_value(s.drop_last(), w) + s.len() * w[char_index]\n  }\n}\n\nspec fn append_value(start_pos: int, count: int, max_val: int) -> int\n  decreases count\n{\n  if count <= 0 { 0 }\n  else { (start_pos + count) * max_val + append_value(start_pos, count - 1, max_val) }\n}\n\nspec fn max_value(w: Seq<int>) -> int\n  decreases w.len()\n{\n  if w.len() <= 1 { w[0] }\n  else if w[0] >= max_value(w.subrange(1, w.len() as int)) { w[0] }\n  else { max_value(w.subrange(1, w.len() as int)) }\n}\n\nspec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool\n{\n  w.len() == 26 && \n  k >= 0 && \n  s.len() <= 1000 && \n  k <= 1000 && \n  (forall|i: int| 0 <= i < w.len() ==> #[trigger] w[i] >= 0 && #[trigger] w[i] <= 1000) &&\n  (forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] && #[trigger] s[i] <= 'z')\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>, k: i8, w: Vec<i8>) -> (result: i8)\n  requires valid_input(s@, k as int, w@.map(|i, x| x as int))\n  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0318", "language": "verus", "source": "apps", "source_id": "apps_test_1623", "vc-description": "Given an array of n positive integers where the number of distinct elements \nis between l and r (inclusive) and each element is either 1 or even with its \nhalf also present in the array, find the minimum and maximum possible sums.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, l: int, r: int) -> bool {\n    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 } else { base * power(base, exp - 1) }\n}\n\nspec fn sum_with_decreasing_powers(n: int, start_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 } \n    else if start_power <= 1 { n }\n    else { start_power + sum_with_decreasing_powers(n - 1, start_power / 2) }\n}\n\nspec fn sum_with_increasing_powers(n: int, max_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 }\n    else if n == 1 { max_power }\n    else { max_power + sum_with_increasing_powers(n - 1, max_power * 2) }\n}\n\nspec fn min_sum_calculation(n: int, l: int) -> int {\n    if n >= 1 && l >= 1 {\n        let start_power = power(2, l - 1);\n        sum_with_decreasing_powers(n, start_power)\n    } else {\n        0\n    }\n}\n\nspec fn max_sum_calculation(n: int, r: int) -> int {\n    if n >= 1 && r >= 1 {\n        let max_power = power(2, r - 1);\n        sum_with_increasing_powers(n, max_power)\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, l: i8, r: i8) -> (result: (i8, i8))\n    requires valid_input(n as int, l as int, r as int)\n    ensures ({\n        let (min_sum, max_sum) = result;\n        min_sum > 0 &&\n        max_sum > 0 &&\n        min_sum <= max_sum &&\n        min_sum as int == min_sum_calculation(n as int, l as int) &&\n        max_sum as int == max_sum_calculation(n as int, r as int)\n    })", "vc-code": "{\n    assume(false);\n    (0, 0)\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0319", "language": "verus", "source": "apps", "source_id": "apps_test_1627", "vc-description": "Given an array of n integers representing animal heights, sort the array in non-decreasing order\nusing a specific operation that selects a segment of even length and swaps adjacent pairs within it.\nOutput the sequence of operations (at most 20,000) needed to sort the array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {\n    forall|op: (int, int)| operations.contains(op) ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1\n}\n\nspec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool \n    decreases arr.len() - i\n{\n    if i >= arr.len() - 1 {\n        true\n    } else {\n        arr[i] <= arr[i + 1] && is_sorted_helper(arr, i + 1)\n    }\n}\n\nspec fn is_sorted(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 {\n        true\n    } else {\n        is_sorted_helper(arr, 0)\n    }\n}\n\nspec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {\n    if i >= 0 && j >= 0 && i < arr.len() && j < arr.len() && j == i + 1 {\n        arr.update(i, arr[j]).update(j, arr[i])\n    } else {\n        arr\n    }\n}\n\nspec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>\n    decreases operations.len()\n{\n    if operations.len() == 0 {\n        arr\n    } else {\n        let op = operations[0];\n        if 1 <= op.0 <= arr.len() && 1 <= op.1 <= arr.len() && op.1 == op.0 + 1 {\n            let new_arr = swap_adjacent(arr, (op.0 - 1) as int, (op.1 - 1) as int);\n            apply_operations(new_arr, operations.drop_first())\n        } else {\n            apply_operations(arr, operations.drop_first())\n        }\n    }\n}\n\nspec fn count_inversions(arr: Seq<int>) -> nat {\n    /* Count of pairs (i, j) where i < j and arr[i] > arr[j] */\n    0nat /* Placeholder implementation */\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, arr: Vec<i8>) -> (operations: Vec<(i8, i8)>)\n  requires \n      valid_input(n as int, arr@.map_values(|x: i8| x as int)),\n  ensures \n      valid_operations(operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)), n as int) &&\n      (is_sorted(apply_operations(arr@.map_values(|x: i8| x as int), operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)))) || operations.len() == 20000) &&\n      operations.len() <= 20000 &&\n      (is_sorted(arr@.map_values(|x: i8| x as int)) ==> operations.len() == 0)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0320", "language": "verus", "source": "apps", "source_id": "apps_test_1628", "vc-description": "Given a string containing only 'x' and 'y' characters, apply operations:\n1. Swap leftmost \"yx\" to \"xy\" \n2. Remove leftmost \"xy\"\nApply operation 1 if possible, otherwise operation 2, repeat until no operations possible.\nReturn the final non-empty string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'x' || s[i] == 'y'\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> nat {\n    s.filter(|x: char| x == c).len()\n}\n\nspec fn valid_output(s: Seq<char>, result: Seq<char>) -> bool \n    recommends valid_input(s)\n{\n    let count_x = count_char(s, 'x');\n    let count_y = count_char(s, 'y');\n    if count_y > count_x {\n        result.len() == count_y - count_x && forall|i: int| 0 <= i < result.len() ==> result[i] == 'y'\n    } else {\n        result.len() == count_x - count_y && forall|i: int| 0 <= i < result.len() ==> result[i] == 'x'\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures valid_output(s@, result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0323", "language": "verus", "source": "apps", "source_id": "apps_test_1635", "vc-description": "Given a sequence of cafe visits, find the cafe that was visited earliest among all last visits to each cafe.\nFor each unique cafe, record the position of its last occurrence, then return the cafe whose last occurrence \nhas the smallest position.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn last_occurrence_helper(cafes: Seq<int>, cafe: int, pos: int) -> int\n    decreases pos + 1\n{\n    if pos < 0 || pos >= cafes.len() { -1 }\n    else if cafes[pos] == cafe { pos }\n    else { last_occurrence_helper(cafes, cafe, pos - 1) }\n}\n\nspec fn last_occurrence_position(cafes: Seq<int>, cafe: int) -> int\n{\n    last_occurrence_helper(cafes, cafe, (cafes.len() - 1) as int)\n}", "vc-helpers": "", "vc-spec": "fn solve(cafes: Vec<i8>) -> (mini: i8)\n    requires\n        cafes.len() > 0,\n    ensures\n        cafes@.contains(mini),\n        forall|cafe: i8| #![auto] cafes@.contains(cafe) ==> last_occurrence_position(cafes@.map(|i, x: i8| x as int), mini as int) <= last_occurrence_position(cafes@.map(|i, x: i8| x as int), cafe as int),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0324", "language": "verus", "source": "apps", "source_id": "apps_test_1643", "vc-description": "Given a binary string s, find a binary string t of the same length such that:\n1. For every substring s[l..r], the longest non-decreasing subsequence length in s[l..r] \n   equals the longest non-decreasing subsequence length in t[l..r]\n2. The number of zeros in t is maximized", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '0' {\n        1 + count_zeros(s.subrange(1, s.len() as int))\n    } else {\n        count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_ones(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        1 + count_ones(s.subrange(1, s.len() as int))\n    } else {\n        count_ones(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        1\n    } else {\n        let count_ones = count_ones(s);\n        let count_zeros = s.len() - count_ones;\n        if count_zeros == 0 {\n            count_ones\n        } else if count_ones == 0 {\n            1\n        } else {\n            count_zeros + count_ones\n        }\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int\n    recommends 0 <= l <= r < s.len()\n{\n    let sub = s.subrange(l, r + 1);\n    longest_non_decreasing_subseq_length_complete(sub)\n}\n\nspec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    &&& s.len() == t.len()\n    &&& valid_binary_string(s)\n    &&& valid_binary_string(t)\n    &&& (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' ==> t[i] == '0')\n    &&& (forall|i: int| 0 <= i < s.len() ==> t[i] == '1' ==> s[i] == '1')\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_binary_string(s@)\n    ensures basic_valid_solution(s@, result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0325", "language": "verus", "source": "apps", "source_id": "apps_test_1646", "vc-description": "Given a binary string with no redundant leading zeros, find the minimum possible binary string \nachievable using these operations: 1) Swap any two adjacent characters, 2) Replace \"11\" with \"1\".\nThe goal is to minimize the decimal value represented by the resulting binary string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1') &&\n    (s == seq!['0'] || s[0] == '1')\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0int\n    } else { \n        (if s[0] == '0' { 1int } else { 0int }) + count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn create_zero_seq(n: nat) -> Seq<char> {\n    Seq::new(n, |i: int| '0')\n}\n\nspec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {\n    (s == seq!['0'] ==> result == seq!['0'])\n    &&\n    (s != seq!['0'] ==> result == seq!['1'] + create_zero_seq(count_zeros(s) as nat))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 1 && n <= 100,\n        s.len() == n as usize,\n        valid_binary_string(s@),\n    ensures \n        valid_binary_string(result@),\n        is_minimal_form(s@, result@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0326", "language": "verus", "source": "apps", "source_id": "apps_test_1655", "vc-description": "Given n people in positions 1 to n, where person i has weapon reach L_i.\nAll people simultaneously attack: person i kills person j if and only if \nj < i and j >= i - L_i. Determine the number of survivors.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n && forall|i: int| 0 <= i < n ==> a[i] >= 0\n}\n\nspec fn count_survivors(n: int, a: Seq<int>) -> int {\n    count_survivors_from(n, a, 0, n)\n}\n\nspec fn count_survivors_from(n: int, a: Seq<int>, start: int, left: int) -> int\n    decreases n - start\n{\n    if start >= n {\n        0\n    } else {\n        let i = n - 1 - start;\n        let survives: int = if i < left { 1 } else { 0 };\n        let new_left: int = if i - a[i] < left { i - a[i] } else { left };\n        survives + count_survivors_from(n, a, start + 1, new_left)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map_values(|x: i8| x as int))\n    ensures result >= 0 && result <= n && result as int == count_survivors(n as int, a@.map_values(|x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0327", "language": "verus", "source": "apps", "source_id": "apps_test_1656", "vc-description": "Given a non-empty string containing only characters 'v' and 'o' with length at most 10^6,\ncalculate its \"wow factor\" - the number of subsequences that form the pattern \"wow\".\nEach 'w' must be represented by exactly two consecutive 'v' characters.\nA valid \"wow\" subsequence consists of: two consecutive 'v' characters (first 'w'),\nan 'o' character appearing later, and two consecutive 'v' characters after the 'o' (second 'w').", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn wow_factor(s: Seq<char>) -> int {\n    if s.len() < 4 { 0 }\n    else {\n        wow_factor_sum(s, 0)\n    }\n}\n\nspec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos <= 1 { 0 }\n    else {\n        let prev = count_vv_pairs_before(s, pos - 1);\n        if s[pos-1] == 'v' && s[pos-2] == 'v' { prev + 1 } else { prev }\n    }\n}\n\nspec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() - 1 { 0 }\n    else {\n        let rest = count_vv_pairs_after(s, pos + 1);\n        if pos + 1 < s.len() && s[pos] == 'v' && s[pos+1] == 'v' { rest + 1 } else { rest }\n    }\n}\n\nspec fn wow_factor_sum(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() { 0 }\n    else {\n        let current = if s[pos] == 'o' { \n            count_vv_pairs_before(s, pos) * count_vv_pairs_after(s, pos + 1)\n        } else { 0 };\n        current + wow_factor_sum(s, pos + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i8)\n    ensures\n        result as int == wow_factor(s@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0329", "language": "verus", "source": "apps", "source_id": "apps_test_1672", "vc-description": "Given a sequence of magnets with orientations \"01\" or \"10\", count the number of groups formed.\nAdjacent magnets with same orientation attract (same group), different orientations repel (separate groups).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(magnets: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < magnets.len() ==> \n        (magnets[i].len() == 2 && \n         ((magnets[i][0] == '0' && magnets[i][1] == '1') || \n          (magnets[i][0] == '1' && magnets[i][1] == '0')))\n}\n\nspec fn count_groups(magnets: Seq<Seq<char>>) -> int {\n    if magnets.len() == 0 { \n        0 as int\n    } else { \n        1 + (Set::new(|i: int| 1 <= i < magnets.len() && magnets[i] != magnets[i-1]).len() as int)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(magnets: Vec<Vec<char>>) -> (result: usize)\n    requires \n        valid_input(magnets@.map(|i, v: Vec<char>| v@))\n    ensures \n        result >= 0,\n        magnets@.len() == 0 ==> result == 0,\n        magnets@.len() > 0 ==> result >= 1,\n        result <= magnets@.len(),\n        valid_input(magnets@.map(|i, v: Vec<char>| v@)) ==> result == count_groups(magnets@.map(|i, v: Vec<char>| v@)) as usize", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0330", "language": "verus", "source": "apps", "source_id": "apps_test_1675", "vc-description": "Given n football teams where each team has home and away kit colors (different colors),\ncalculate how many games each team plays in home kit vs away kit in a round-robin tournament.\nKit rules: home team wears home kit, away team wears away kit unless it conflicts with \nhome team's home kit color, then away team wears home kit.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, teams: Seq<(int, int)>) -> bool {\n  n >= 2 && teams.len() == n &&\n  (forall|i: int| 0 <= i < n ==> #[trigger] teams[i].0 != #[trigger] teams[i].1) &&\n  (forall|i: int| 0 <= i < n ==> \n    (Set::new(|j: int| 0 <= j < n && #[trigger] teams[j].0 == #[trigger] teams[i].1)).len() <= (n - 1) as nat)\n}\n\nspec fn valid_output(n: int, teams: Seq<(int, int)>, result: Seq<(int, int)>) -> bool\n  recommends teams.len() == n\n{\n  result.len() == n &&\n  (forall|i: int| 0 <= i < n ==> #[trigger] result[i].0 + #[trigger] result[i].1 == 2 * (n - 1)) &&\n  (forall|i: int| 0 <= i < n ==> #[trigger] result[i].0 >= n - 1) &&\n  (forall|i: int| 0 <= i < n ==> #[trigger] result[i].1 >= 0) &&\n  (forall|i: int| 0 <= i < n ==> {\n    let home_count = (Set::new(|j: int| 0 <= j < n && #[trigger] teams[j].0 == #[trigger] teams[i].1)).len() as int;\n    #[trigger] result[i].0 == (n - 1) + home_count &&\n    #[trigger] result[i].1 == (n - 1) - home_count\n  })\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, teams: Vec<(i8, i8)>) -> (result: Vec<(i8, i8)>)\n  requires valid_input(n as int, teams@.map_values(|t: (i8, i8)| (t.0 as int, t.1 as int)))\n  ensures valid_output(n as int, teams@.map_values(|t: (i8, i8)| (t.0 as int, t.1 as int)), result@.map_values(|r: (i8, i8)| (r.0 as int, r.1 as int)))", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0333", "language": "verus", "source": "apps", "source_id": "apps_test_1689", "vc-description": "Given a bus with n rows of seats, where each row contains 4 seats arranged as two pairs \nseparated by a walkway (format: XX|XX), find two adjacent empty seats in the same pair \nfor two passengers. Each seat is either 'O' (empty) or 'X' (occupied). If such a pair \nexists, mark it with \"++\" and output \"YES\" with the modified configuration. Otherwise, \noutput \"NO\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {\n    n >= 0 && rows.len() == n && forall|i: int| 0 <= i < rows.len() ==> rows[i].len() == 5\n}\n\nspec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < rows.len() && \n        ((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n         (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < rows.len() ==> \n        !((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n          (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {\n    result.len() != 2 || result[0] != 'N' || result[1] != 'O' ==> result.len() >= 4\n}", "vc-helpers": "spec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {\n    v@.map(|i, row: Vec<char>| row@)\n}\n", "vc-spec": "fn solve(n: i8, rows: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        valid_input(n as int, vec_to_seq_seq(rows))\n    ensures \n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') || result@.len() >= 4,\n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> no_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        !(result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> has_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        valid_solution(result@, vec_to_seq_seq(rows))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0334", "language": "verus", "source": "apps", "source_id": "apps_test_1711", "vc-description": "Count the number of arrays of length n where each element is from 1 to m,\nexactly one pair of elements are equal (all others distinct), and the array\nis unimodal (strictly ascending then strictly descending around a peak).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 2 && m >= 1 && n <= m && m <= 200000\n}\n\nspec fn combination(n: int, k: int, modulus: int) -> int {\n    0  /* placeholder - actual combinatorial calculation */\n}\n\nspec fn power(base: int, exp: int, modulus: int) -> int {\n    0  /* placeholder - actual modular exponentiation */\n}\n\nspec fn expected_result(n: int, m: int) -> int {\n    if n == 2 {\n        0\n    } else {\n        (((combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * power(2, n - 3, 998244353)) % 998244353\n    }\n}\n\nspec fn valid_output(result: int) -> bool {\n    0 <= result < 998244353\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        valid_output(result as int),\n        result as int == expected_result(n as int, m as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0335", "language": "verus", "source": "apps", "source_id": "apps_test_1712", "vc-description": "Two players (Vanya and Vova) attack monsters simultaneously with different frequencies.\nVanya attacks at frequency a hits/second, Vova at frequency b hits/second.\nFor each monster requiring mobs[i] hits, determine who makes the final hit.\nThe attack pattern repeats every (a+b) hits, so we can use modular arithmetic.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {\n    n >= 0 && a > 0 && b > 0 && mobs.len() == n &&\n    forall|i: int| 0 <= i < n ==> #[trigger] mobs[i] >= 0\n}\n\nspec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < n ==> \n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a']) || \n        (result[i]@ =~= seq!['V', 'o', 'v', 'a']) || \n        (result[i]@ =~= seq!['B', 'o', 't', 'h'])\n}\n\nspec fn determine_winner(k: int, a: int, b: int) -> int {\n    if k <= a { 0 } else { 1 }\n}\n\nspec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool\n    recommends a > 0 && b > 0 && mobs.len() == n\n{\n    valid_output(result, n) &&\n    forall|i: int| 0 <= i < n ==> {\n        let total = a + b;\n        let k = if mobs[i] == 0 { 0 } else { mobs[i] % total };\n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a'] <==> determine_winner(k, a, b) == 0) &&\n        (result[i]@ =~= seq!['V', 'o', 'v', 'a'] <==> determine_winner(k, a, b) == 1) &&\n        (result[i]@ =~= seq!['B', 'o', 't', 'h'] <==> determine_winner(k, a, b) == 2)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8, mobs: Vec<i8>) -> (result: Vec<Vec<char>>)\n    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0336", "language": "verus", "source": "apps", "source_id": "apps_test_1723", "vc-description": "Given an integer n (2 ≤ n ≤ 10^5), construct two trees with n nodes each:\n1. First tree: Where Mahmoud's algorithm produces incorrect minimum vertex cover size\n2. Second tree: Where Mahmoud's algorithm produces correct minimum vertex cover size\nMahmoud's algorithm roots the tree at node 1, counts nodes at even/odd depths,\nand returns min(evenCnt, oddCnt) as the vertex cover size.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_output(n: int, result: Seq<String>) -> bool\n    recommends n >= 2\n{\n    if n < 6 {\n        result.len() == 1 + (n - 1) &&\n        result[0]@ == seq!['-', '1'] &&\n        (forall|i: int| #![auto] 1 <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 1))\n    } else {\n        result.len() == (5 + (n - 6)) + (n - 1) &&\n        result[0]@ == seq!['1', ' ', '2'] && \n        result[1]@ == seq!['1', ' ', '3'] && \n        result[2]@ == seq!['1', ' ', '4'] && \n        result[3]@ == seq!['2', ' ', '5'] && \n        result[4]@ == seq!['2', ' ', '6'] &&\n        (forall|i: int| #![auto] 5 <= i < 5 + (n - 6) ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 2)) &&\n        (forall|i: int| #![auto] 5 + (n - 6) <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i - (5 + (n - 6)) + 2))\n    }\n}\n\nspec fn int_to_string_pos(n: nat) -> Seq<char>\n    decreases n\n{\n    if n < 10 {\n        seq![(n + ('0' as nat)) as char]\n    } else {\n        int_to_string_pos(n / 10) + int_to_string_pos(n % 10)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n < 0 {\n        seq!['-'] + int_to_string_pos((-n) as nat)\n    } else {\n        int_to_string_pos(n as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<String>)\n    requires n as int >= 2\n    ensures valid_output(n as int, result@)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0338", "language": "verus", "source": "apps", "source_id": "apps_test_1725", "vc-description": "Given an n × m matrix of integers and parameter d, find minimum operations to make all elements equal.\nEach operation adds or subtracts d from any element. Return -1 if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool {\n    n > 0 && m > 0 && d > 0 &&\n    matrix.len() == n &&\n    (forall|i: int| #![auto] 0 <= i < n ==> matrix[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> matrix[i][j] > 0)\n}\n\nspec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool\n    recommends valid_input(matrix.len() as int, if matrix.len() > 0 { matrix[0].len() as int } else { 0 }, d, matrix)\n{\n    forall|i: int, j: int, k: int, l: int| \n        0 <= i < matrix.len() && 0 <= j < matrix[0].len() && \n        0 <= k < matrix.len() && 0 <= l < matrix[0].len() ==>\n        matrix[i][j] % d == matrix[k][l] % d\n}\n\nspec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>\n    decreases matrix.len()\n{\n    if matrix.len() == 0 {\n        seq![]\n    } else {\n        matrix[0].add(flatten(matrix.subrange(1, matrix.len() as int)))\n    }\n}\n\nspec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>\n    recommends d > 0\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![s[0] / d].add(divide_sequence_by_d(s.subrange(1, s.len() as int), d))\n    }\n}\n\nspec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if s[0] >= target { s[0] - target } else { target - s[0] }) + \n        sum_abs_differences_from_target(s.subrange(1, s.len() as int), target)\n    }\n}\n\nspec fn seq_min(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() == 0 {\n        0\n    } else {\n        let rest_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() == 0 {\n        0\n    } else {\n        let rest_max = seq_max(s.subrange(1, s.len() as int));\n        if s[0] >= rest_max { s[0] } else { rest_max }\n    }\n}\n\nspec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int\n    recommends simplified.len() > 0\n    decreases max_val - min_val\n{\n    if min_val >= max_val {\n        sum_abs_differences_from_target(simplified, min_val)\n    } else {\n        let mid = (min_val + max_val) / 2;\n        let mid_ops = sum_abs_differences_from_target(simplified, mid);\n        let left_ops = if mid > min_val { min_ops_in_range(simplified, min_val, mid - 1) } else { mid_ops };\n        let right_ops = if mid < max_val { min_ops_in_range(simplified, mid + 1, max_val) } else { mid_ops };\n        if mid_ops <= left_ops && mid_ops <= right_ops {\n            mid_ops\n        } else if left_ops <= right_ops {\n            left_ops\n        } else {\n            right_ops\n        }\n    }\n}\n\nspec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int\n    recommends simplified.len() > 0\n{\n    let min_val = seq_min(simplified);\n    let max_val = seq_max(simplified);\n    min_ops_in_range(simplified, min_val, max_val)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures \n        result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),\n        result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),\n        result >= 0 ==> {\n            let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));\n            let simplified = divide_sequence_by_d(flat, d as int);\n            result as int == minimum_operations_to_make_equal(simplified)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0339", "language": "verus", "source": "apps", "source_id": "apps_test_1735", "vc-description": "Two players alternate turns removing consecutive identical letters from a string.\nThe player who cannot make a move loses. Determine if the first player wins.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_max_moves(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let stack: Seq<char> = seq![];\n        let moves: nat = 0;\n        count_max_moves_helper(s, 0, stack, moves)\n    }\n}\n\nspec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat\n    decreases s.len() - i\n{\n    if i <= s.len() {\n        if i == s.len() {\n            moves\n        } else if stack.len() > 0 && s[i as int] == stack[stack.len() as int - 1] {\n            count_max_moves_helper(s, i + 1, stack.subrange(0, stack.len() as int - 1), moves + 1)\n        } else {\n            count_max_moves_helper(s, i + 1, stack.push(s[i as int]), moves)\n        }\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: &'static str)\n    requires s.len() >= 1\n    ensures\n        result == \"Yes\" || result == \"No\",\n        result == \"Yes\" <==> count_max_moves(s@) % 2 == 1,\n        result == \"No\" <==> count_max_moves(s@) % 2 == 0,", "vc-code": "{\n    assume(false);\n    \"No\"\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0341", "language": "verus", "source": "apps", "source_id": "apps_test_1746", "vc-description": "Determine if a rooted tree is a \"spruce\". A rooted tree is a spruce if every \nnon-leaf vertex has at least 3 leaf children. A leaf is a vertex with no children,\nand a non-leaf vertex has at least one child.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn has_children(node: int, parents: Seq<int>, n: int) -> bool\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    exists|i: int| 0 <= i < n - 1 && parents[i] - 1 == node\n}\n\nspec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    (Set::new(|i: int| 0 <= i < n - 1 && parents[i] - 1 == node && !has_children(i + 1, parents, n))).len() as int\n}\n\nspec fn valid_input(n: int, parents: Seq<int>) -> bool\n{\n    n >= 3 && parents.len() == n - 1 && \n    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] parents[i] >= 1 && parents[i] <= i + 1)\n}\n\nspec fn is_spruce(n: int, parents: Seq<int>) -> bool\n    recommends valid_input(n, parents)\n{\n    forall|node: int| 0 <= node < n && has_children(node, parents, n) ==> \n        count_leaf_children(node, parents, n) >= 3\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, parents: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, parents@.map_values(|x: i8| x as int)),\n    ensures \n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        result@ == seq!['Y', 'e', 's'] <==> is_spruce(n as int, parents@.map_values(|x: i8| x as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0342", "language": "verus", "source": "apps", "source_id": "apps_test_1754", "vc-description": "Given n students across m schools, where each student has a unique power level,\nthe Technogoblet selects the strongest student from each school. We want k specific \nstudents (Chosen Ones) to be selected. We can create new schools and reassign students.\nFind the minimum number of new schools needed so all k Chosen Ones get selected.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_strongest_in_school(student_idx: int, powers: Seq<int>, schools: Seq<int>) -> bool\n  recommends 0 <= student_idx < powers.len() && powers.len() == schools.len()\n{\n  forall|j: int| 0 <= j < powers.len() && schools[j] == schools[student_idx] ==> powers[j] <= powers[student_idx]\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, k: i8, powers: Vec<i8>, schools: Vec<i8>, chosen: Vec<i8>) -> (result: i8)\n  requires \n      n >= 1 && m >= 1 && k >= 1 && k <= n && m <= n,\n      powers@.len() == n as nat && schools@.len() == n as nat && chosen@.len() == k as nat\n  ensures \n      result >= 0 && result <= k", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0343", "language": "verus", "source": "apps", "source_id": "apps_test_1757", "vc-description": "Generate a string of exactly n characters where each character is either 'O' or 'o'.\nThe i-th character (1-indexed) should be 'O' if i is a Fibonacci number, 'o' otherwise.\nFibonacci sequence: f₁ = 1, f₂ = 1, fₙ = fₙ₋₁ + fₙ₋₂ for n > 2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_fibonacci(num: int) -> bool {\n    num == 1 || num == 2 || exists|k: nat| is_fib_seq(k) == num\n}\n\nspec fn is_fib_seq(n: nat) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        1\n    } else {\n        is_fib_seq((n - 1) as nat) + is_fib_seq((n - 2) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<char>)\n    requires n >= 1 && n <= 100\n    ensures \n        result.len() == n as nat\n        && (forall|i: int| 0 <= i < result.len() ==> result[i] == 'O' || result[i] == 'o')\n        && (forall|i: int| 1 <= i <= n ==> (is_fibonacci(i) <==> result[i-1] == 'O'))\n        && (forall|i: int| 1 <= i <= n ==> (!is_fibonacci(i) <==> result[i-1] == 'o'))", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0344", "language": "verus", "source": "apps", "source_id": "apps_test_1761", "vc-description": "Given n words forming a message, determine if a received text could have been encoded by:\n1. Creating coded string with \"<3\" before each word and after last word\n2. Inserting additional characters anywhere in the coded string\nCheck if received message contains expected coded string as subsequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {\n    0  /* placeholder for uninterpreted function */\n}\n\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 2 &&\n    {\n        let n = parse_int_helper(input[0], 0, 0);\n        n >= 1 && n + 1 < input.len()\n    }\n}\n\nspec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>\n    decreases words.len()\n{\n    if words.len() == 0 {\n        seq!['<', '3']\n    } else {\n        seq!['<', '3'] + words[0] + build_expected_pattern(words.subrange(1, words.len() as int))\n    }\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool\n    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()\n{\n    if pattern_index <= pattern.len() && text_index <= text.len() {\n        if pattern_index == pattern.len() {\n            true\n        } else if text_index == text.len() {\n            false\n        } else if pattern[pattern_index as int] == text[text_index as int] {\n            is_subsequence_helper(pattern, text, (pattern_index + 1) as nat, (text_index + 1) as nat)\n        } else {\n            is_subsequence_helper(pattern, text, pattern_index, (text_index + 1) as nat)\n        }\n    } else {\n        false\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        input.len() >= 2,\n        valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures \n        result@ == seq!['y', 'e', 's'] || result@ == seq!['n', 'o'],\n        result@ == seq!['y', 'e', 's'] <==> {\n            valid_input(input@.map(|i, v: Vec<char>| v@)) && {\n                let n = parse_int_helper(input@.map(|i, v: Vec<char>| v@)[0], 0, 0);\n                let expected = build_expected_pattern(input@.map(|i, v: Vec<char>| v@).subrange(1, n + 1));\n                let message = input@.map(|i, v: Vec<char>| v@)[n + 1];\n                is_subsequence(expected, message)\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0345", "language": "verus", "source": "apps", "source_id": "apps_test_1766", "vc-description": "Two players take turns picking cards from either end of a row of n cards. Each card has a distinct\ninteger value. The first player (Sereja) goes first. Both players use a greedy strategy: they always\nchoose the card with the larger value between the leftmost and rightmost available cards. Determine\nthe final scores of both players.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() >= 1 &&\n    (forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0) &&\n    (forall|i: int, j: int| 0 <= i < j < cards.len() ==> cards[i] != cards[j])\n}\n\nspec fn sum(cards: Seq<int>) -> int \n    decreases cards.len()\n{\n    if cards.len() == 0 { \n        0 \n    } else { \n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int\n    decreases right - left + 1\n    when 0 <= left <= right < cards.len()\n{\n    if left == right {\n        if sereja_turn { cards[left] } else { 0 }\n    } else if cards[left] > cards[right] {\n        (if sereja_turn { cards[left] } else { 0 }) + sereja_optimal_score(cards, left+1, right, !sereja_turn)\n    } else {\n        (if sereja_turn { cards[right] } else { 0 }) + sereja_optimal_score(cards, left, right-1, !sereja_turn)\n    }\n}\n\nspec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {\n    valid_input(cards) ==>\n    scores.len() == 2 &&\n    scores[0] >= 0 && scores[1] >= 0 &&\n    scores[0] + scores[1] == sum(cards) &&\n    scores[0] == sereja_optimal_score(cards, 0, cards.len()-1, true) &&\n    scores[1] == sum(cards) - sereja_optimal_score(cards, 0, cards.len()-1, true)\n}", "vc-helpers": "", "vc-spec": "fn solve(cards: Vec<i8>) -> (scores: Vec<i8>)\n    requires valid_input(cards@.map(|i, x| x as int))\n    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0347", "language": "verus", "source": "apps", "source_id": "apps_test_1788", "vc-description": "Given two integers A and B where A = X + Y and B = X - Y, find the original integers X and Y.\nThe inputs are constrained to be between -100 and 100, and unique integer solutions are guaranteed to exist.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    -100 <= a <= 100 && -100 <= b <= 100 && (a + b) % 2 == 0 && (a - b) % 2 == 0\n}\n\nspec fn correct_solution(a: int, b: int, x: int, y: int) -> bool {\n    a == x + y && b == x - y\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int)\n    ensures correct_solution(a as int, b as int, result.0 as int, result.1 as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0348", "language": "verus", "source": "apps", "source_id": "apps_test_1795", "vc-description": "Given n planes numbered 1 to n, where each plane i likes exactly one other plane f_i (f_i ≠ i),\ndetermine if there exists a love triangle. A love triangle occurs when plane A likes plane B,\nplane B likes plane C, and plane C likes plane A.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, f: Seq<int>) -> bool {\n    n >= 2 && n <= 5000 &&\n    f.len() == n &&\n    forall|i: int| 0 <= i < f.len() ==> 1 <= f[i] <= n && f[i] != i + 1\n}\n\nspec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>\n    recommends valid_input(n, f)\n{\n    Seq::new(n as nat, |j: int| f[j] - 1)\n}\n\nspec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool\n    recommends \n        a.len() == n &&\n        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n\n{\n    exists|i: int| 0 <= i < n && \n        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i\n}\n\nspec fn has_love_triangle(n: int, f: Seq<int>) -> bool\n    recommends valid_input(n, f)\n{\n    let a = zero_indexed_array(n, f);\n    has_love_triangle_with(n, a)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, f: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, f@.map(|i: int, x: i8| x as int)),\n    ensures \n        result@.len() == 2 || result@.len() == 3,\n        (result@.len() == 3) <==> has_love_triangle(n as int, f@.map(|i: int, x: i8| x as int)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0349", "language": "verus", "source": "apps", "source_id": "apps_test_1797", "vc-description": "Given n subway stations where each station i has exactly one outgoing train to station p_i,\nand the array p represents a permutation, find the maximum \"convenience\" after changing at \nmost 2 values in p. Convenience is defined as the number of ordered pairs (x,y) where you \ncan travel from station x to station y using the subway trains.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, p: Seq<int>) -> bool {\n  n > 0 && p.len() == n &&\n  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&\n  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn count_true(visited: Seq<bool>) -> int\n  decreases visited.len()\n{\n  if visited.len() == 0 { 0int }\n  else { (if visited[0] { 1int } else { 0int }) + count_true(visited.subrange(1, visited.len() as int)) }\n}\n\nspec fn sum_of_squares(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0int } else { s[0] * s[0] + sum_of_squares(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_unvisited(visited: Seq<bool>) -> int {\n  0int  /* placeholder */\n}\n\nspec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {\n  1int  /* placeholder */\n}\n\nspec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {\n  visited  /* placeholder */\n}\n\nspec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {\n  get_cycles_helper(n, p, Seq::new(n as nat, |i: int| false), Seq::empty())\n}\n\nspec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>\n  decreases n - count_true(visited)\n{\n  if count_true(visited) >= n { cycles }\n  else {\n    let unvisited = find_unvisited(visited);\n    if unvisited == -1int { cycles }\n    else if 0 <= unvisited < n {\n      let cycle_length = get_cycle_length(p, visited, unvisited);\n      let new_visited = mark_cycle_visited(p, visited, unvisited);\n      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n {\n        get_cycles_helper(n, p, new_visited, cycles.push(cycle_length))\n      } else {\n        cycles.push(cycle_length)\n      }\n    } else {\n      cycles\n    }\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, p: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))\n  ensures result > 0", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0350", "language": "verus", "source": "apps", "source_id": "apps_test_1805", "vc-description": "Given n matches, find the minimum number of additional matches needed to form a valid equation a + b = c \nwhere a, b, c are positive integers. Each integer k uses k matches, '+' uses 1 match, '=' uses 1 match.\nTotal matches needed: a + b + c + 2 = 2(a + b) + 2 since c = a + b.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(queries: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 2\n}\n\nspec fn min_additional_matches(n: int) -> int\n    recommends n >= 2\n{\n    if n >= 4 { n % 2 } else { 4 - n }\n}\n\nspec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool\n    recommends valid_input(queries)\n{\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == min_additional_matches(queries[i])\n}", "vc-helpers": "", "vc-spec": "fn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: i8| x as int))\n    ensures valid_result(queries@.map(|i: int, x: i8| x as int), results@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0351", "language": "verus", "source": "apps", "source_id": "apps_test_1809", "vc-description": "Given n books with weights w_i, find the optimal initial stacking order to minimize total weight lifted \nwhen reading books according to a given sequence. To read book x: lift all books above x, remove x from \nstack, put lifted books back (maintaining order), then place x on top. The book being read is not counted \nas lifted weight.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(s: Seq<char>) -> bool {\n    s.len() >= 5 && s[s.len() as int - 1] == '\\n'\n}\n\nspec fn calculate_result_from_input(s: Seq<char>) -> Seq<char> {\n    s /* placeholder implementation */\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        s.len() > 0,\n        (exists|i: int| 0 <= i < s.len() as int && s@[i] == '\\n'),\n        is_valid_input(s@),\n    ensures \n        result.len() > 0,\n        result@[result.len() as int - 1] == '\\n'", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0353", "language": "verus", "source": "apps", "source_id": "apps_test_1826", "vc-description": "Given a sequence of moves 'U' (up) and 'R' (right), replace consecutive pairs \"RU\" or \"UR\" \nwith diagonal moves \"D\" to minimize sequence length. Input format is a number n followed by \nnewline, then a string of n characters containing only 'U' and 'R'.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|pos: int| 0 <= pos < input.len() && input[pos] == '\\n'\n}\n\nspec fn valid_move_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'U' || s[i] == 'R'\n}\n\nspec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {\n    if length <= 1 {\n        0\n    } else {\n        count_replacements_helper(s, start, length, 1, 0)\n    }\n}\n\nspec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int\n    decreases length - i\n{\n    if i >= length {\n        count\n    } else if start + i < s.len() && s[start + i - 1] != s[start + i] {\n        if i + 2 <= length {\n            count_replacements_helper(s, start, length, i + 2, count + 1)\n        } else {\n            count + 1\n        }\n    } else {\n        count_replacements_helper(s, start, length, i + 1, count)\n    }\n}\n\nspec fn minimized_length(original_length: int, replacements: int) -> int {\n    original_length - replacements\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0356", "language": "verus", "source": "apps", "source_id": "apps_test_1837", "vc-description": "Given a permutation of integers 0 to n-1, find the maximum number of fixed points\n(positions where a[i] = i) after performing at most one swap operation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| #![trigger a[i]] 0 <= i < n ==> 0 <= a[i] < n) &&\n    (forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < n ==> a[i] != a[j]) &&\n    (forall|k: int| #![trigger a[k]] 0 <= k < n ==> exists|i: int| 0 <= i < n && a[i] == k)\n}\n\nspec fn current_fixed_points(a: Seq<int>) -> int {\n    a.len() as int\n}\n\nspec fn max_possible_fixed_points(a: Seq<int>) -> int \n    recommends valid_input(a.len() as int, a)\n{\n    let current = current_fixed_points(a);\n    if current == a.len() {\n        a.len() as int\n    } else if exists|i: int| 0 <= i < a.len() && a[i] != i && a[a[i] as int] == i {\n        current + 2\n    } else {\n        current + 1\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i, x| x as int)),\n    ensures \n        result as int == max_possible_fixed_points(a@.map(|i, x| x as int)),\n        result >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0357", "language": "verus", "source": "apps", "source_id": "apps_test_1840", "vc-description": "Given s spaceships with attacking powers and b bases with defensive powers and gold amounts,\ndetermine the maximum gold each spaceship can steal. A spaceship can attack any base where \nthe spaceship's attacking power is greater than or equal to the base's defensive power.\nWhen attacking a base, the spaceship steals all gold from that base.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: nat, b: nat, attacking_powers: Seq<nat>, bases: Seq<(nat, nat)>) -> bool {\n    attacking_powers.len() == s && bases.len() == b\n}\n\nspec fn sum_gold_for_spaceship(attacking_power: nat, bases: Seq<(nat, nat)>) -> nat\n    decreases bases.len()\n{\n    if bases.len() == 0 {\n        0\n    } else if attacking_power >= bases[0].0 {\n        bases[0].1 + sum_gold_for_spaceship(attacking_power, bases.subrange(1, bases.len() as int))\n    } else {\n        sum_gold_for_spaceship(attacking_power, bases.subrange(1, bases.len() as int))\n    }\n}\n\nspec fn valid_output(s: nat, attacking_powers: Seq<nat>, bases: Seq<(nat, nat)>, result: Seq<nat>) -> bool {\n    result.len() == s &&\n    (forall|i: int| 0 <= i < s ==> result[i] >= 0) &&\n    (forall|i: int| 0 <= i < s && i < attacking_powers.len() ==> \n        result[i] == sum_gold_for_spaceship(attacking_powers[i], bases))\n}", "vc-helpers": "", "vc-spec": "fn solve(s: u8, b: u8, attacking_powers: Vec<u8>, bases: Vec<(u8, u8)>) -> (result: Vec<u8>)\n    requires valid_input(s as nat, b as nat, attacking_powers@.map(|i, x: u8| x as nat), bases@.map(|i, x: (u8, u8)| (x.0 as nat, x.1 as nat)))\n    ensures valid_output(s as nat, attacking_powers@.map(|i, x: u8| x as nat), bases@.map(|i, x: (u8, u8)| (x.0 as nat, x.1 as nat)), result@.map(|i, x: u8| x as nat))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0358", "language": "verus", "source": "apps", "source_id": "apps_test_1841", "vc-description": "Given an array of n integers and m queries, for each query l_i, find the number of distinct elements\nin the suffix of the array starting from position l_i (1-indexed). The suffix includes all elements\nfrom position l_i to the end of the array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: Seq<int>, queries: Seq<int>) -> bool {\n    a.len() == n && queries.len() == m && n >= 1 && m >= 1 &&\n    forall|i: int| 0 <= i < m ==> (#[trigger] queries[i], 1 <= queries[i] <= n).1\n}\n\nspec fn distinct_count(a: Seq<int>, start: int) -> int\n    recommends 0 <= start < a.len()\n{\n    let suffix_indices = Set::new(|j: int| start <= j < a.len());\n    let suffix_values = suffix_indices.map(|j: int| a[j]);\n    suffix_values.len() as int\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, a: Vec<i8>, queries: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, m as int, a@.map(|i, x| x as int), queries@.map(|i, x| x as int))\n    ensures \n        result.len() == m &&\n        (forall|i: int| 0 <= i < m ==> (#[trigger] result@[i], result@[i] as int == distinct_count(a@.map(|i, x| x as int), queries@[i] as int - 1)).1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0359", "language": "verus", "source": "apps", "source_id": "apps_test_1849", "vc-description": "Given an integer n, consider all integers from 0 to 10^n - 1, each padded with leading zeros to exactly n digits.\nA \"block\" is a maximal consecutive sequence of identical digits.\nFor each length i from 1 to n, count the total number of blocks of length i across all these padded numbers.\nOutput n integers modulo 998244353, where the i-th integer is the number of blocks of length i.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec const MOD: int = 998244353int;\n\nspec fn valid_input(n: int) -> bool\n{\n  n >= 1\n}\n\nspec fn pow(base: int, exp: int, modulus: int) -> int\n  decreases exp\n{\n  if exp <= 0 { 1int }\n  else { (base * pow(base, exp - 1, modulus)) % modulus }\n}\n\nspec fn block_count_formula(n: int, i: int) -> int\n  recommends n >= 1 && 1 <= i <= n\n{\n  if i == n { 10int }\n  else { \n    ((2int * 9int * pow(10int, n - i - 1, MOD) * 10int) + \n     (if i < n - 1 { ((n - 1 - i) * 9int * 9int * pow(10int, n - i - 2, MOD) * 10int) } else { 0int })) % MOD\n  }\n}\n\nspec fn valid_result(result: Seq<int>, n: int) -> bool\n  recommends n >= 1\n{\n  result.len() == n &&\n  (forall|k: int| 0 <= k < n ==> #[trigger] result[k] >= 0 && #[trigger] result[k] < MOD) &&\n  (n >= 1 ==> result[n-1] == 10int) &&\n  (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] == block_count_formula(n, i+1))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0360", "language": "verus", "source": "apps", "source_id": "apps_test_1850", "vc-description": "Given N astronauts with current point rankings and N point awards for the next race,\nfind the best possible ranking for astronaut at position D after the race.\nThe target astronaut gets the maximum award, and we try to minimize awards to astronauts\nahead of them to maximize how many can be overtaken.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {\n        n >= 1 && n <= 200000 &&\n        d >= 1 && d <= n &&\n        current_points.len() == n &&\n        awards.len() == n &&\n        d-1 < current_points.len() &&\n        (forall|i: int| 0 <= i < current_points.len()-1 ==> \n            #[trigger] current_points.index(i) >= current_points.index((i+1) as int)) &&\n        (forall|i: int| 0 <= i < awards.len()-1 ==> \n            #[trigger] awards.index(i) >= awards.index((i+1) as int))\n    }\n    \n    spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int)\n    {\n        count_overtaken_helper(current_points, awards, d, 0, 0)\n    }\n    \n    spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int),\n            0 <= pos <= d-1,\n            0 <= used_awards <= awards.len()\n        decreases d-1-pos\n    {\n        if pos >= d-1 {\n            0\n        } else {\n            let target_score = current_points.index(d-1) + awards.index(0);\n            let remaining_awards = awards.len() - used_awards;\n            if remaining_awards > 0 && used_awards < awards.len() && current_points.index(pos) + awards.index(awards.len()-1-used_awards) <= target_score {\n                1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)\n            } else {\n                count_overtaken_helper(current_points, awards, d, pos+1, used_awards)\n            }\n        }\n    }", "vc-helpers": "", "vc-spec": "fn solve(n: i8, d: i8, current_points: Vec<i8>, awards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, d as int, current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int))\n    ensures \n        1 <= result as int <= d as int,\n        result as int == d as int - count_overtaken(current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int), d as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\n\nfn main() {}"}
{"id": "VA0361", "language": "verus", "source": "apps", "source_id": "apps_test_1877", "vc-description": "Given a sequence of moves on a 2D grid starting from position (0,0), count the number of times \nthe path crosses between two kingdoms separated by the line x = y. Kingdom 1 contains points \nwhere x > y, Kingdom 2 contains points where x < y, and points where x = y are on the wall/gates.\nMoves are 'U' (up: y+1) and 'R' (right: x+1). Count transitions between kingdoms, ignoring \npositions on the wall, with no cost for the initial move from starting position.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n >= 0 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> (s[i] == 'U' || s[i] == 'R')\n}\n\nspec fn count_kingdom_transitions(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else { count_transitions_helper(s, 0, 0, 0, -1) }\n}\n\nspec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() { 0 }\n    else {\n        let new_x = if s[pos] == 'U' { x } else { x + 1 };\n        let new_y = if s[pos] == 'U' { y + 1 } else { y };\n\n        if new_x == new_y {\n            count_transitions_helper(s, pos + 1, new_x, new_y, pred)\n        } else {\n            let cur = if new_x > new_y { 0 } else { 1 };\n            let transition: int = if cur != pred && pred != -1 { 1 } else { 0 };\n            transition + count_transitions_helper(s, pos + 1, new_x, new_y, cur)\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(n as int, s@),\n        n >= 0\n    ensures \n        result >= 0 &&\n        result <= n &&\n        (n == 0 ==> result == 0) &&\n        result as int == count_kingdom_transitions(s@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0362", "language": "verus", "source": "apps", "source_id": "apps_test_1878", "vc-description": "Given n rectangles on a 100×100 grid, where each rectangle is defined by its bottom-left corner (x₁, y₁) and top-right corner (x₂, y₂), \ncalculate the sum of all cell values in the grid. Each cell's value equals the number of rectangles that contain it.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        }\n    } else if s[pos] == '\\n' {\n        let new_acc = if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        };\n        split_lines_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        parse_int_pos_func(s)\n    }\n}\n\nspec fn parse_int_pos_func(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if '0' <= s[0] && s[0] <= '9' {\n        (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn parse_ints_func(s: Seq<char>) -> Seq<int> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        parse_ints_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        }\n    } else if s[pos] == ' ' {\n        let new_acc = if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        };\n        parse_ints_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        parse_ints_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'] + int_to_string_pos(-n)\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char]\n    }\n}\n\nspec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int\n    decreases rectangle_lines.len()\n{\n    if rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))\n    }\n}\n\nspec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 || rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@),\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|total_area: int| {\n            &&& total_area >= 0\n            &&& result@ == int_to_string_func(total_area) + seq!['\\n']\n            &&& {\n                let processed_input = if input@.len() > 0 && input@[input@.len() - 1] == '\\n' {\n                    input@\n                } else {\n                    input@ + seq!['\\n']\n                };\n                let lines = split_lines_func(processed_input);\n                if lines.len() == 0 {\n                    total_area == 0\n                } else {\n                    let n = parse_int_func(lines[0]);\n                    if n >= 0 && n + 1 <= lines.len() {\n                        total_area == compute_total_area(lines.subrange(1, n + 1))\n                    } else {\n                        total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)\n                    }\n                }\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0363", "language": "verus", "source": "apps", "source_id": "apps_test_1886", "vc-description": "Given a non-empty word consisting of lowercase and uppercase English letters,\ncapitalize the first letter while keeping all other letters unchanged.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(word: Seq<char>) -> bool {\n    word.len() > 0 && forall|i: int| 0 <= i < word.len() ==> \n        (('a' <= word[i] && word[i] <= 'z') || ('A' <= word[i] && word[i] <= 'Z'))\n}\n\nspec fn correct_capitalization(input: Seq<char>, output: Seq<char>) -> bool {\n    valid_input(input) ==> (\n        output.len() == input.len() &&\n        ('A' <= output[0] && output[0] <= 'Z') &&\n        (('a' <= input[0] && input[0] <= 'z') ==> ('A' <= output[0] && output[0] <= 'Z')) &&\n        (('A' <= input[0] && input[0] <= 'Z') ==> (output[0] == input[0])) &&\n        forall|i: int| 1 <= i < input.len() ==> output[i] == input[i]\n    )\n}", "vc-helpers": "", "vc-spec": "fn capitalize_first_letter(word: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(word@)\n    ensures correct_capitalization(word@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0364", "language": "verus", "source": "apps", "source_id": "apps_test_1887", "vc-description": "Given two rows of n students each, select a team with maximum total height\nsuch that selected students have strictly increasing indices, no two\nconsecutive selected students are from the same row, and any number of\nstudents can be selected (including zero).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {\n    n >= 1 && h1.len() >= n && h2.len() >= n &&\n    (forall|i: int| 0 <= i < n ==> h1[i] >= 0) &&\n    (forall|i: int| 0 <= i < n ==> h2[i] >= 0)\n}\n\nspec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n{\n    let dp1 = max_height_ending_in_row1(n, h1, h2);\n    let dp2 = max_height_ending_in_row2(n, h1, h2);\n    if dp1 > dp2 { dp1 } else { dp2 }\n}\n\nspec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row1_decreases\n{\n    if n == 1 { h1[0] }\n    else {\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let take_from_row2 = prev_row2 + h1[n-1];\n        if take_from_row2 > prev_row1 { take_from_row2 } else { prev_row1 }\n    }\n}\n\nspec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row2_decreases\n{\n    if n == 1 { h2[0] }\n    else {\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let take_from_row1 = prev_row1 + h2[n-1];\n        if take_from_row1 > prev_row2 { take_from_row1 } else { prev_row2 }\n    }\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, h1: Vec<i8>, h2: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n    ensures \n        result >= 0,\n        result as int == max_team_height(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0365", "language": "verus", "source": "apps", "source_id": "apps_test_1889", "vc-description": "Given an n×m grid where each cell contains either 0 or 1, process q queries.\nEach query flips the value at position (i,j) from 0 to 1 or 1 to 0.\nAfter each query, calculate the score: the maximum length of consecutive 1s across all rows in the grid.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {\n    grid.len() == n && n > 0 && m > 0 &&\n    (forall|i: int| 0 <= i < n ==> grid[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {\n    queries.len() == q && q >= 0 &&\n    (forall|k: int| 0 <= k < q ==> #[trigger] queries[k].0 >= 1 && queries[k].0 <= n && queries[k].1 >= 1 && queries[k].1 <= m)\n}\n\nspec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int\n    decreases l.len() - index\n{\n    if index >= l.len() {\n        max_so_far\n    } else if l[index] == 1 {\n        let new_current = current + 1;\n        let new_max = if new_current > max_so_far { new_current } else { max_so_far };\n        cons_helper(l, index + 1, new_current, new_max)\n    } else {\n        cons_helper(l, index + 1, 0, max_so_far)\n    }\n}\n\nspec fn cons(l: Seq<int>) -> int {\n    cons_helper(l, 0, 0, 0)\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let rest = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] > rest { s[0] } else { rest }\n    }\n}\n\nspec fn compute_score(grid: Seq<Seq<int>>) -> int {\n    if grid.len() == 0 {\n        0\n    } else {\n        let row_scores = Seq::new(grid.len(), |i: int| cons(grid[i]));\n        max_in_seq(row_scores)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, q: i8, grid: Vec<Vec<i8>>, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires \n        valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), n as int, m as int),\n        valid_queries(queries@.map(|k: int, query: (i8, i8)| (query.0 as int, query.1 as int)), q as int, n as int, m as int),\n    ensures \n        results.len() == q,", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0366", "language": "verus", "source": "apps", "source_id": "apps_test_1909", "vc-description": "Given n tasks numbered 1 to n and parameter k, find the starting task that minimizes\ntotal \"telling off power\" when Dima performs tasks in circular order and Inna\ninterrupts every k tasks (1st, (k+1)th, (2k+1)th, etc.).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, powers: Seq<int>) -> bool {\n    n > 0 && k > 0 && k <= n && n % k == 0 && powers.len() == n\n}\n\nspec fn is_optimal_starting_task(result: int, n: int, k: int, powers: Seq<int>) -> bool {\n    1 <= result <= k\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, powers: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, powers@.map(|i: int, x: i8| x as int))\n    ensures is_optimal_starting_task(result as int, n as int, k as int, powers@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0368", "language": "verus", "source": "apps", "source_id": "apps_test_1922", "vc-description": "Given an N×M grid of cards (all initially face up), perform one operation for each card position (i,j): \nflip the card at position (i,j) and all cards in the 8 adjacent positions (sharing a side or corner), \nif those positions exist in the grid. Determine how many cards face down after all N×M operations are completed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 1 && m >= 1\n}\n\nspec fn count_face_down_cards(n: int, m: int) -> int\n    recommends valid_input(n, m)\n{\n    if n == 1 && m == 1 {\n        1\n    } else if n == 1 {\n        m - 2\n    } else if m == 1 {\n        n - 2\n    } else {\n        (n - 2) * (m - 2)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int),\n    ensures \n        result as int == count_face_down_cards(n as int, m as int),\n        result >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0369", "language": "verus", "source": "apps", "source_id": "apps_test_1925", "vc-description": "Given integers A, B, and N, find the maximum value of floor(A*x/B) - A*floor(x/B) \nover all non-negative integers x where 0 ≤ x ≤ N.\n\n/* B must be positive */\n\n/* default values with B=1 to avoid division by zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    parse_three_ints_func(input).1 > 0\n}\n\nspec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) \n    recommends s.len() > 0\n{\n    let nums = parse_numbers(s, 0, seq![], 0, false);\n    if nums.len() >= 3 { \n        (nums[0], if nums[1] > 0 { nums[1] } else { 1 }, nums[2])\n    } else { \n        (0, 1, 0) \n    }\n}\n\nspec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if in_number && nums.len() < 3 { nums.push(current) } else { nums }\n    } else if nums.len() >= 3 {\n        nums\n    } else {\n        let c = s[i];\n        if c >= '0' && c <= '9' {\n            let digit = c as int - '0' as int;\n            if !in_number {\n                parse_numbers(s, i + 1, nums, digit, true)\n            } else {\n                parse_numbers(s, i + 1, nums, current * 10 + digit, true)\n            }\n        } else if in_number {\n            parse_numbers(s, i + 1, nums.push(current), 0, false)\n        } else {\n            parse_numbers(s, i + 1, nums, current, false)\n        }\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'].add(int_to_string_helper_func(-n)) }\n    else { int_to_string_helper_func(n) }\n}\n\nspec fn int_to_string_helper_func(n: int) -> Seq<char> \n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_helper_func(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn compute_max_value(a: int, b: int, n: int) -> int \n    recommends b > 0\n{\n    let min_val = if b - 1 < n { b - 1 } else { n };\n    (a * min_val) / b\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures ({\n        let parts = parse_three_ints_func(input@);\n        let a = parts.0;\n        let b = parts.1;  \n        let n = parts.2;\n        b > 0 &&\n        result@ == int_to_string_func(compute_max_value(a, b, n)).add(seq!['\\n'])\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0370", "language": "verus", "source": "apps", "source_id": "apps_test_1926", "vc-description": "Given an array of n integers, for each k from 1 to n-1, construct a k-ary heap structure \nand count the number of min-heap property violations. In a k-ary heap with 1-indexed elements,\nelement at index i has parent at index ⌊(i+k-2)/k⌋ (for i > 1). A violation occurs when \na[child] < a[parent].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n  n >= 2 && a.len() == n\n}\n\nspec fn count_violations_for_k(a: Seq<int>, n: int, k: int) -> int {\n  let violations = Set::new(|i: int| 2 <= i <= n && {\n    let parent_idx = (i + k - 2) / k;\n    parent_idx >= 1 && a[i-1] < a[parent_idx-1]\n  });\n  violations.len() as int\n}\n\nspec fn valid_output(result: Seq<int>, n: int, a: Seq<int>) -> bool {\n  result.len() == n - 1 &&\n  (forall|k: int| 1 <= k <= n - 1 ==> #[trigger] result[k-1] >= 0) &&\n  (forall|k: int| 1 <= k <= n - 1 ==> #[trigger] result[k-1] == count_violations_for_k(a, n, k))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)\n  requires valid_input(n as int, a@.map(|_i, x| x as int))\n  ensures valid_output(result@.map(|_i, x| x as int), n as int, a@.map(|_i, x| x as int))", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0372", "language": "verus", "source": "apps", "source_id": "apps_test_1940", "vc-description": "Given n types of pebbles with w_i pebbles of type i, and a person with 2 pockets \nthat can each hold at most k pebbles, find the minimum number of days needed to \ncollect all pebbles. Different pebble types cannot be mixed in the same pocket, \nboth pockets can be used simultaneously on the same day, and each pebble type \nmust be collected completely.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, w: Seq<int>) -> bool {\n    k > 0 && n >= 0 && w.len() == n && forall|i: int| 0 <= i < w.len() ==> w[i] >= 0\n}\n\nspec fn sum_trips(w: Seq<int>, k: int) -> int\n    decreases w.len()\n{\n    if w.len() == 0 {\n        0\n    } else {\n        (w[0] + k - 1) / k + sum_trips(w.drop_first(), k)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, w: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, w@.map_values(|v: i8| v as int)),\n    ensures \n        result >= 0,\n        result as int == (sum_trips(w@.map_values(|v: i8| v as int), k as int) + 1) / 2,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0374", "language": "verus", "source": "apps", "source_id": "apps_test_1958", "vc-description": "Given n buyers and cost p per apple, determine total money seller should receive.\nEach buyer purchased exactly half the apples available at their turn.\nIf apples were odd, buyer received additional half apple as gift.\nSeller started with some positive number of apples and ended with zero apples.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {\n    1 <= n <= 40 &&\n    2 <= p <= 1000 &&\n    p % 2 == 0 &&\n    buyers.len() == n &&\n    forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n}\n\nspec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n{\n    compute_payment_backward(buyers, p, buyers.len() - 1, 0)\n}\n\nspec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                -1 <= current_index < buyers.len(),\n                current_apples >= 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n    decreases current_index + 1\n{\n    if current_index < 0 {\n        0\n    } else {\n        let new_apples = if buyers[current_index] == \"halfplus\" { \n                            current_apples * 2 + 1\n                         } else { \n                            current_apples * 2\n                         };\n        let payment = if buyers[current_index] == \"halfplus\" { \n                          (new_apples / 2) * p\n                       } else { \n                          current_apples * p\n                       };\n        payment + compute_payment_backward(buyers, p, current_index - 1, new_apples)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, p: i8, buyers: Vec<&str>) -> (result: i8)\n    requires valid_input(n as int, p as int, buyers@)\n    ensures result >= 0,\n            result as int == compute_total_payment(buyers@, p as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0375", "language": "verus", "source": "apps", "source_id": "apps_test_1965", "vc-description": "Given n accounts with integer ratings and one infected account (Killjoy's) with rating x,\nfind the minimum number of contests needed to infect all n accounts.\nInfection spreads instantly to accounts with the same rating.\nIn contests, participants can change ratings (sum of changes = 0), Killjoy cannot participate.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == x {\n        1 + count_occurrences(s.drop_first(), x)\n    } else {\n        count_occurrences(s.drop_first(), x)\n    }\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.drop_first())\n    }\n}\n\nspec fn valid_input(n: int, ratings: Seq<int>) -> bool {\n    n >= 2 && ratings.len() == n\n}\n\nspec fn all_infected(k: int, ratings: Seq<int>) -> bool {\n    ratings.contains(k) && count_occurrences(ratings, k) == ratings.len()\n}\n\nspec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {\n    (ratings.contains(k) && count_occurrences(ratings, k) != ratings.len()) ||\n    (!ratings.contains(k) && k * ratings.len() == sum(ratings))\n}\n\nspec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {\n    !ratings.contains(k) && k * ratings.len() != sum(ratings)\n}", "vc-helpers": "", "vc-spec": "fn solve_case(n: i8, k: i8, ratings: Vec<i8>) -> (answer: i8)\n    requires \n        valid_input(n as int, ratings@.map(|i: int, x: i8| x as int))\n    ensures \n        answer >= 0 && answer <= 2,\n        all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 0,\n        can_infect_in_one_contest(k as int, ratings@.map(|i: int, x: i8| x as int)) && !all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 1,\n        requires_two_contests(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 2", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0381", "language": "verus", "source": "apps", "source_id": "apps_test_1985", "vc-description": "Given k jury members who sequentially add points to an initial score, determine how many\npossible initial scores could produce a given set of observed intermediate scores.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }\n}\n\nspec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int\n    recommends 0 <= pos < a.len(), b.len() > 0\n{\n    b[0] - sum(a.subrange(0, pos + 1))\n}\n\nspec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n    decreases pos\n    when pos >= 0\n{\n    if pos == 0 { \n        set![score_at_pos] \n    } else { \n        set![score_at_pos].union(compute_backward_scores(pos - 1, score_at_pos - a[pos], a))\n    }\n}\n\nspec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n    decreases a.len() - pos\n    when pos < a.len()\n{\n    if pos == a.len() - 1 { \n        Set::empty() \n    } else { \n        compute_forward_scores(pos + 1, score_at_pos + a[pos + 1], a).insert(score_at_pos + a[pos + 1])\n    }\n}\n\nspec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n{\n    let backwards = compute_backward_scores(pos, score_at_pos, a);\n    let forwards = compute_forward_scores(pos, score_at_pos, a);\n    backwards.union(forwards)\n}\n\nspec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool\n    recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0\n{\n    let scores = compute_scores(pos, b[0], a);\n    forall|j: int| 0 <= j < b.len() ==> #[trigger] scores.contains(b[j])\n}\n\nspec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>\n    recommends \n        k > 0,\n        a.len() == k,\n        b.len() > 0,\n        forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000,\n        forall|i: int| 0 <= i < b.len() ==> -4000000 <= #[trigger] b[i] <= 4000000\n{\n    Set::new(|x: int| exists|i: int| #[trigger] is_valid_initial_score(i, k, a, b) && 0 <= i < k && x == compute_initial_score(i, a, b))\n}\n\nspec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool\n{\n    k > 0 && n > 0 && a.len() == k && b.len() == n && n <= k &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] b[i] != #[trigger] b[j]) &&\n    (forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000) &&\n    (forall|i: int| 0 <= i < n ==> -4000000 <= #[trigger] b[i] <= 4000000)\n}", "vc-helpers": "", "vc-spec": "fn solve(k: i8, n: i8, a: Vec<i8>, b: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(k as int, n as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))\n    ensures\n        result >= 0,\n        result <= k,\n        result as int == valid_initial_scores(k as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)).len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0382", "language": "verus", "source": "apps", "source_id": "apps_test_1988", "vc-description": "Given multiple test cases, each containing a string, find the lexicographically smallest\nstring achievable by applying one of n possible transformations, where transformation i\neither rotates the string by i positions or rotates and reverses the prefix based on parity.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 2 &&\n    (s.last() == '\\n' || (s.len() >= 2 && s.subrange(s.len() - 2, s.len() as int) == seq!['\\n']))\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 0 &&\n    (result.len() == 0 || result.last() == '\\n')\n}\n\nspec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>\n    recommends 1 <= k <= n && input_str.len() == n\n{\n    let i = k - 1;\n    if (n - i) % 2 == 0 {\n        input_str.subrange(i, n as int) + input_str.subrange(0, i)\n    } else {\n        input_str.subrange(i, n as int) + reverse_string(input_str.subrange(0, i))\n    }\n}\n\nspec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool\n    recommends input_str.len() == n\n{\n    1 <= k <= n &&\n    result_str == transform_string(input_str, n, k) &&\n    true /* Simplified to avoid trigger issues */\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![] /* TODO: Define line splitting logic */\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0 /* TODO: Define integer parsing logic */\n}\n\nspec fn is_lowercase_letter(c: char) -> bool {\n    'a' <= c && c <= 'z'\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char> {\n    s /* TODO: Define string reversal logic */\n}\n\nspec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {\n    true /* TODO: Define lexicographic comparison */\n}", "vc-helpers": "", "vc-spec": "fn solve(s: &str) -> (result: String)\n  requires valid_input(s@)\n  ensures valid_output(result@)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0383", "language": "verus", "source": "apps", "source_id": "apps_test_2015", "vc-description": "Given three integers representing counts of red, green, and blue lamps,\ndetermine if it's possible to arrange all lamps in a line such that\nno two adjacent lamps have the same color.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(r: int, g: int, b: int) -> bool {\n    r >= 1 && g >= 1 && b >= 1\n}\n\nspec fn max_of_3(r: int, g: int, b: int) -> int {\n    if r >= g && r >= b {\n        r\n    } else if g >= r && g >= b {\n        g\n    } else {\n        b\n    }\n}\n\nspec fn can_arrange(r: int, g: int, b: int) -> bool\n    recommends valid_input(r, g, b)\n{\n    let max_count = max_of_3(r, g, b);\n    let total = r + g + b;\n    2 * max_count <= total + 1\n}", "vc-helpers": "", "vc-spec": "fn check_lamp_arrangement(r: i8, g: i8, b: i8) -> (result: bool)\n    requires valid_input(r as int, g as int, b as int)\n    ensures result == can_arrange(r as int, g as int, b as int)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0384", "language": "verus", "source": "apps", "source_id": "apps_test_2025", "vc-description": "Given a positive integer n, express it as a sum of composite numbers using the maximum possible number of summands.\nA composite number is an integer greater than 1 that is not prime (has positive divisors other than 1 and itself).\nFor each query, return the maximum number of composite summands, or -1 if no such splitting exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_composite(x: int) -> bool {\n    x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0\n}\n\nspec fn valid_input(queries: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1\n}\n\nspec fn max_composite_summands(n: int) -> int {\n    if n % 4 == 0 {\n        n / 4\n    } else if n % 4 == 1 && n / 4 >= 2 {\n        n / 4 - 1\n    } else if n % 4 == 2 && n / 4 >= 1 {\n        n / 4\n    } else if n % 4 == 3 && n / 4 >= 3 {\n        n / 4 - 1\n    } else {\n        -1\n    }\n}\n\nspec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1\n}", "vc-helpers": "", "vc-spec": "fn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i, x: i8| x as int))\n    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0385", "language": "verus", "source": "apps", "source_id": "apps_test_2039", "vc-description": "Given an array of integers, count the number of local extrema.\nA local minimum is an element strictly less than both neighbors.\nA local maximum is an element strictly greater than both neighbors.\nFirst and last elements cannot be local extrema since they lack two neighbors.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n\n}\n\nspec fn count_local_extrema(n: int, a: Seq<int>) -> int\n    recommends valid_input(n, a)\n{\n    Set::<int>::new(|i: int| 1 <= i < n - 1 && ((a[i] > a[i-1] && a[i] > a[i+1]) || (a[i] < a[i-1] && a[i] < a[i+1]))).len() as int\n}\n\nspec fn is_local_extremum(a: Seq<int>, i: int) -> bool\n    recommends 0 <= i < a.len()\n{\n    1 <= i < a.len() - 1 && ((a[i] > a[i-1] && a[i] > a[i+1]) || (a[i] < a[i-1] && a[i] < a[i+1]))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map_values(|x: i8| x as int))\n    ensures \n        result >= 0,\n        n <= 2 ==> result == 0,\n        n > 2 ==> result <= n - 2,\n        result as int == count_local_extrema(n as int, a@.map_values(|x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0386", "language": "verus", "source": "apps", "source_id": "apps_test_2044", "vc-description": "Given a notebook with infinite pages where each page holds exactly m names,\nwrite names for n consecutive days. On day i, write exactly a_i names.\nFill pages sequentially - when a page becomes full, turn to the next page.\nDetermine how many times you turn pages on each day.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && a.len() == n && \n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1)\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n    result.len() == n && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)\n}\n\nspec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { 0 }\n    else { (s + a[i]) / m }\n}\n\nspec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { s }\n    else { (s + a[i]) % m }\n}\n\nspec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool\n    recommends m >= 1\n{\n    result.len() == a.len() &&\n    (forall|i: int| 0 <= i < a.len() ==> {\n        let s = compute_state_at(a, m, i);\n        #[trigger] result[i] == (s + a[i]) / m\n    })\n}\n\nspec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int\n    recommends m >= 1, day >= 0\n    decreases day\n{\n    if day <= 0 { 0 }\n    else if day > a.len() { compute_state_at(a, m, a.len() as int) }\n    else if day > 0 && day <= a.len() { (compute_state_at(a, m, day - 1) + a[day - 1]) % m }\n    else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: Vec<i8>)\nrequires\n    valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int))\nensures\n    valid_output(result@.map(|i: int, x: i8| x as int), n as int),\n    correct_page_turns(result@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), m as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0387", "language": "verus", "source": "apps", "source_id": "apps_test_2049", "vc-description": "Given an array of n integers and m queries, determine for each query whether a specified subsegment forms a \"ladder\".\nA ladder is a sequence that first non-decreases, then non-increases. Formally, there exists a position x such that \nelements are non-decreasing up to position x, then non-increasing from position x onward.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {\n  &&& 0 <= l <= r < arr.len()\n  &&& if l == r {\n    true\n  } else {\n    exists|k: int| l <= k <= r && \n      is_non_decreasing(arr, l, k) && \n      is_non_increasing(arr, k, r)\n  }\n}\n\nspec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] <= arr[i+1]\n}\n\nspec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] >= arr[i+1]\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, arr: Vec<i8>, queries: Vec<(i8, i8)>) -> (results: Vec<Vec<char>>)\n  requires \n    n >= 1 && m >= 1,\n    arr@.len() == n as int,\n    queries@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> 1 <= #[trigger] queries@[i].0 as int <= queries@[i].1 as int <= n as int,\n  ensures \n    results@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> #[trigger] results@[i]@ == seq!['Y', 'e', 's'] || results@[i]@ == seq!['N', 'o'],\n    forall|i: int| 0 <= i < m as int ==> \n      (#[trigger] results@[i]@ == seq!['Y', 'e', 's'] <==> is_ladder(arr@.map(|_i, v| v as int), queries@[i].0 as int - 1, queries@[i].1 as int - 1)),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0388", "language": "verus", "source": "apps", "source_id": "apps_test_2074", "vc-description": "Two players play a sequential game on a grid of restaurant costs.\nEmma (first player) chooses a row to maximize final cost.\nJack (second player) then chooses a column to minimize final cost.\nBoth play optimally. Find the resulting cost when both play optimally.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0\n}\n\nspec fn seq_min(s: Seq<int>) -> int \n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_min = seq_min(s.drop_first());\n        if s[0] <= tail_min { \n            s[0]\n        } else { \n            tail_min\n        }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_max = seq_max(s.drop_first());\n        if s[0] >= tail_max { \n            s[0]\n        } else { \n            tail_max\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(grid: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures ({\n        let grid_spec = grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int));\n        let row_mins = Seq::new(grid_spec.len(), |i: int| seq_min(grid_spec[i]));\n        result as int == seq_max(row_mins)\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0389", "language": "verus", "source": "apps", "source_id": "apps_test_2080", "vc-description": "Given q queries with numbers n_i, find the maximum number of edges in a simple undirected graph\nwith n_i vertices where at least half of the edges are bridges. A bridge is an edge whose\nremoval increases the number of connected components in the graph.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 2000000000\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    result >= 0 &&\n    result >= n - 1 &&\n    result <= n * (n - 1) / 2\n}\n\nspec fn compute_expected_result(n: int) -> int {\n    let quad_solv_numerator = isqrt(8*n + 1) - 1;\n    let x = quad_solv_numerator / 2;\n    let y = x + 1;\n    let xed = x * (x - 1) / 2 + n - x;\n    let ybr = n - y;\n    let yed = 2 * ybr;\n    if xed > yed { xed } else { yed }\n}\n\nspec fn isqrt(n: int) -> int {\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n <= 3 { 1 }\n    else {\n        let guess = n / 2;\n        let low = 0;\n        let high = guess + 1;\n        isqrt_helper(n, low, high)\n    }\n}\n\nspec fn isqrt_helper(n: int, low: int, high: int) -> int\n    decreases high - low\n{\n    if high - low <= 1 { low }\n    else {\n        let mid = (low + high) / 2;\n        if mid * mid <= n {\n            isqrt_helper(n, mid, high)\n        } else {\n            isqrt_helper(n, low, mid)\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int),\n    ensures\n        valid_output(n as int, result as int),\n        result as int == compute_expected_result(n as int),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0392", "language": "verus", "source": "apps", "source_id": "apps_test_2104", "vc-description": "Given integers l and r where l < r, partition all integers from l to r (inclusive) \ninto exactly (r-l+1)/2 pairs such that each pair (i,j) has gcd(i,j) = 1. \nEach number must appear in exactly one pair.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(l: int, r: int) -> bool {\n    l < r && (r - l) % 2 == 1\n}\n\nspec fn gcd(a: int, b: int) -> int\n    recommends a != 0 || b != 0\n    decreases (if a >= 0 { a } else { -a })\n{\n    if a == 0 {\n        if b >= 0 { b } else { -b }\n    } else {\n        gcd(b % a, a)\n    }\n}\n\nspec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {\n    exists|i: int, j: int| l <= i <= r && l <= j <= r && i != j &&\n        pair == int_to_string(i).add(seq![' ']).add(int_to_string(j)) &&\n        (i != 0 || j != 0) && gcd(i, j) == 1\n}\n\nspec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {\n    result.len() >= 1 &&\n    result[0] == seq!['Y', 'E', 'S'] &&\n    result.len() == 1 + (r - l + 1) / 2 &&\n    (forall|i: int| 1 <= i < result.len() ==> pair_has_gcd_one(result[i], l, r))\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'].add(int_to_string_pos(-n))\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![char_from_digit(n)]\n    } else {\n        int_to_string_pos(n / 10).push(char_from_digit(n % 10))\n    }\n}\n\nspec fn char_from_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}", "vc-helpers": "", "vc-spec": "fn solve(l: i8, r: i8) -> (result: Vec<Vec<char>>)\n    requires valid_input(l as int, r as int)\n    ensures\n        result.len() >= 1,\n        result[0]@ == seq!['Y', 'E', 'S'],\n        result.len() == 1 + (r as int - l as int + 1) / 2,\n        forall|i: int| 1 <= i < result.len() ==> \n            #[trigger] result[i]@ == int_to_string(l as int + 2 * (i - 1)).add(seq![' ']).add(int_to_string(l as int + 2 * (i - 1) + 1))", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0394", "language": "verus", "source": "apps", "source_id": "apps_test_2123", "vc-description": "Given n+1 pylons numbered 0 to n, where pylon 0 has height 0 and pylons 1 to n have heights h₁, h₂, ..., hₙ.\nA player starts at pylon 0 with 0 energy and wants to reach pylon n by jumping from pylon k to pylon k+1.\nEach jump from pylon k to k+1 changes energy by (hₖ - hₖ₊₁). Energy must remain non-negative at all times.\nThe player can pay $1 to increase any pylon's height by 1. Find the minimum cost to make the journey possible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    via max_in_seq_decreases\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        let tail = s.subrange(1, s.len() as int);\n        let tail_max = max_in_seq(tail);\n        if s[0] >= tail_max { s[0] } else { tail_max }\n    }\n}\n\n#[via_fn]\nproof fn max_in_seq_decreases(s: Seq<int>) {\n    assume(false);\n}\n\nspec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool\n    recommends valid_input(n, heights)\n{\n    result == max_in_seq(heights) &&\n    forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&\n    exists|i: int| 0 <= i < heights.len() && heights[i] == result\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, heights: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))\n    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0396", "language": "verus", "source": "apps", "source_id": "apps_test_2167", "vc-description": "Given an array of n integers, find the maximum number of elements that can be made equal\nafter performing any number of operations where each operation chooses two different elements\nand simultaneously increases one by 1 and decreases the other by 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn correct_result(n: int, arr: Seq<int>, result: int) -> bool {\n    &&& (sum_seq(arr) % n == 0 ==> result == n)\n    &&& (sum_seq(arr) % n != 0 ==> result == n - 1)\n    &&& (result == n || result == n - 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, arr: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, arr@.map(|i: int, x: i8| x as int))\n    ensures correct_result(n as int, arr@.map(|i: int, x: i8| x as int), result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0398", "language": "verus", "source": "apps", "source_id": "apps_test_2180", "vc-description": "Given an n × n chessboard, find the maximum number of \"Coders\" that can be placed\nsuch that none attacks another. A Coder at position (x, y) can attack positions\n(x±1, y) and (x, y±1) (horizontally and vertically adjacent squares).\nOutput the maximum count and a valid placement configuration using checkerboard pattern.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn max_coders(n: int) -> int {\n    if n >= 1 { n * n / 2 + n * n % 2 } else { 0 }\n}\n\nspec fn valid_output_format(result: Seq<Seq<char>>, n: int) -> bool {\n    n >= 1 &&\n    result.len() == (n + 1) &&\n    (forall|i: int| 1 <= i <= n ==> #[trigger] result[i].len() == n)\n}\n\nspec fn valid_checkerboard_placement(result: Seq<Seq<char>>, n: int) -> bool {\n    n >= 1 &&\n    valid_output_format(result, n) &&\n    (forall|i: int, j: int| 1 <= i <= n && 0 <= j < n ==>\n        (#[trigger] result[i][j] == 'C') <==> \n            (if (i - 1) % 2 == 0 { j % 2 == 0 } else { j % 2 == 1 }))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<String>)\n    requires valid_input(n as int)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0399", "language": "verus", "source": "apps", "source_id": "apps_test_2183", "vc-description": "Given three brothers numbered 1, 2, and 3, exactly two brothers arrived on time \nfor a meeting and one brother was late. Given the numbers of the two brothers who \narrived on time, determine the number of the brother who was late.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_brother_numbers(a: int, b: int) -> bool {\n    1 <= a <= 3 && 1 <= b <= 3 && a != b\n}\n\nspec fn late_brother(a: int, b: int) -> int\n    recommends valid_brother_numbers(a, b)\n{\n    6 - a - b\n}\n\nspec fn is_valid_result(a: int, b: int, result: int) -> bool {\n    valid_brother_numbers(a, b) ==> \n        (1 <= result <= 3 && result != a && result != b)\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n    requires \n        valid_brother_numbers(a as int, b as int)\n    ensures \n        is_valid_result(a as int, b as int, result as int) &&\n        result as int == late_brother(a as int, b as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0400", "language": "verus", "source": "apps", "source_id": "apps_test_2187", "vc-description": "Given an array of integers, find the minimum number of operations to make it non-decreasing.\nIn each operation, select a contiguous non-decreasing subsegment and add 1 to all elements.\nThe solution sums violations where arr[i] > arr[i+1], as each violation requires (arr[i] - arr[i+1]) operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {\n    forall|i: int| 0 <= i < test_cases.len() ==> test_cases[i].len() >= 1\n}\n\nspec fn sum_differences(arr: Seq<int>, start: int) -> int\n    recommends 0 <= start <= arr.len()\n    decreases arr.len() - start\n{\n    if start >= arr.len() - 1 {\n        0\n    } else {\n        (if arr[start] > arr[start + 1] { arr[start] - arr[start + 1] } else { 0 }) + sum_differences(arr, start + 1)\n    }\n}\n\nspec fn correct_result(test_cases: Seq<Seq<int>>, results: Seq<int>) -> bool {\n    results.len() == test_cases.len() &&\n    forall|i: int| 0 <= i < test_cases.len() ==> results[i] == sum_differences(test_cases[i], 0) &&\n    forall|i: int| 0 <= i < results.len() ==> results[i] >= 0\n}", "vc-helpers": "", "vc-spec": "fn solve(test_cases: Vec<Vec<i8>>) -> (results: Vec<i8>)\n    requires valid_input(test_cases@.map_values(|v: Vec<i8>| v@.map_values(|x: i8| x as int)))\n    ensures correct_result(test_cases@.map_values(|v: Vec<i8>| v@.map_values(|x: i8| x as int)), results@.map_values(|x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0402", "language": "verus", "source": "apps", "source_id": "apps_test_2202", "vc-description": "Given a sequence A of N integers and a positive integer p, split A into exactly 2 contiguous,\nnon-overlapping parts (each containing at least 1 element) to maximize the sum of their scores.\nThe score of a part is the sum of its elements modulo p. Find the maximum possible sum of scores.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, p: int, a: Seq<int>) -> bool {\n    n >= 2 && p >= 2 && a.len() == n && forall|i: int| 0 <= i < n ==> a[i] >= 1\n}\n\nspec fn split_score(a: Seq<int>, split_idx: int, p: int) -> int {\n    0 /* placeholder for split score calculation */\n}\n\nspec fn max_seq(scores: Seq<int>) -> int {\n    0 /* placeholder for maximum value in sequence */\n}\n\nspec fn max_split_score(a: Seq<int>, p: int) -> int\n    recommends a.len() >= 2, p >= 2\n{\n    let scores = Seq::new((a.len() - 1) as nat, |i: int| split_score(a, i + 1, p));\n    max_seq(scores)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, p: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, p as int, a@.map_values(|x: i8| x as int))\n    ensures \n        result >= 0 &&\n        result < 2 * p &&\n        result as int == max_split_score(a@.map_values(|x: i8| x as int), p as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0403", "language": "verus", "source": "apps", "source_id": "apps_test_2209", "vc-description": "Given n strings containing only 's' and 'h' characters, arrange them in optimal order\nand concatenate to form a single string. Find the maximum possible \"noise\" which is\nthe number of \"sh\" subsequences in the resulting concatenated string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 1 &&\n    (forall|i: int| 0 <= i < input[0].len() ==> #[trigger] input[0][i] == input[0][i] && '0' <= input[0][i] <= '9') &&\n    {\n        let n = string_to_int(input[0]);\n        n >= 1 && input.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n ==> #[trigger] input[i] == input[i] && (input[i].len() > 0 &&\n            forall|j: int| 0 <= j < input[i].len() ==> #[trigger] input[i][j] == input[i][j] && (input[i][j] == 's' || input[i][j] == 'h'))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { string_to_int(s.subrange(0, s.len() as int - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn count_sh_subsequences(s: Seq<char>) -> int {\n    count_sh_subsequences_helper(s, 0, 0)\n}\n\nspec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int\n    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0\n{\n    if index == s.len() { 0 }\n    else if index < s.len() && s[index] == 's' {\n        count_sh_subsequences_helper(s, index + 1, s_count + 1)\n    } else if index < s.len() && s[index] == 'h' {\n        s_count + count_sh_subsequences_helper(s, index + 1, s_count)\n    } else {\n        count_sh_subsequences_helper(s, index + 1, s_count)\n    }\n}\n\nspec fn string_ratio(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 } else { count_char(s, 's') * 1000 / s.len() as int }\n}\n\nspec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>\n    decreases strings.len()\n{\n    if strings.len() == 0 { Seq::empty() }\n    else { strings[0] + concatenate_strings(strings.subrange(1, strings.len() as int)) }\n}\n\nspec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < strings.len() ==> \n        #[trigger] strings[i] == strings[i] && #[trigger] strings[j] == strings[j] &&\n        strings[i].len() > 0 && strings[j].len() > 0 ==> \n        string_ratio(strings[i]) <= string_ratio(strings[j])\n}\n\nspec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {\n    arranged.len() == original.len() &&\n    forall|s: Seq<char>| #[trigger] original.contains(s) <==> arranged.contains(s)\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<Vec<char>>) -> (result: i32)\n    requires valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0405", "language": "verus", "source": "apps", "source_id": "apps_test_2220", "vc-description": "Given n emotes with happiness values, use emotes m times total to maximize happiness.\nCannot use the same emote more than k consecutive times.\n\n/* Assumes optimal strategy using highest and second highest values */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {\n    n >= 2 && k >= 1 && m >= 1 && emotes.len() == n &&\n    forall|i: int| 0 <= i < emotes.len() ==> emotes[i] >= 1\n}\n\nspec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {\n    let k_plus_1 = k + 1;\n    let total = m / k_plus_1;\n    let remainder = m % k_plus_1;\n\n    let max_val = max_value(emotes);\n    let second_max_val = second_max_value(emotes);\n    remainder * max_val + max_val * (total * k) + second_max_val * total\n}\n\nspec fn max_value(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] >= max_value(s.skip(1)) {\n        s[0]\n    } else if s.len() > 1 {\n        max_value(s.skip(1))\n    } else {\n        s[0]\n    }\n}\n\nspec fn second_max_value(s: Seq<int>) -> int {\n    let max_val = max_value(s);\n    let filtered = filter_out(s, max_val, 1);\n    if filtered.len() > 0 {\n        max_value(filtered)\n    } else {\n        1\n    }\n}\n\nspec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>\n    decreases s.len(), count\n{\n    if s.len() == 0 || count == 0 {\n        s\n    } else if s[0] == val {\n        filter_out(s.skip(1), val, count - 1)\n    } else {\n        seq![s[0]].add(filter_out(s.skip(1), val, count))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, k: i8, emotes: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, k as int, \n            seq![].add(emotes@.map(|i: int, x: i8| x as int)))\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0406", "language": "verus", "source": "apps", "source_id": "apps_test_2238", "vc-description": "Given an odd integer n (3 ≤ n ≤ 101), create an n×n matrix representing a crystal with a diamond pattern.\nUse 'D' for diamond cells and '*' for all other cells.\nThe diamond pattern forms a symmetric diamond shape where the top half starts with 1 'D' and increases by 2 'D's per row\nuntil the middle row has n 'D's, then the bottom half decreases symmetrically.\nAll 'D's in each row are centered with '*' characters filling remaining positions.\n\n/* First half (including middle): rows 0 to magic */\n\n/* Second half: rows magic+1 to n-1 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 3 && n <= 101 && n % 2 == 1\n}\n\nspec fn valid_result(result: Seq<String>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() == n\n}\n\nspec fn repeat_char(c: char, count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 { Seq::empty() }\n    else { repeat_char(c, count - 1).push(c) }\n}\n\nspec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {\n    result.len() == n ==> {\n        let magic = (n - 1) / 2;\n        \n        (forall|i: int| 0 <= i <= magic && i < result.len() ==> {\n            let stars = magic - i;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        }) &&\n        \n        (forall|i: int| magic + 1 <= i < n && i < result.len() ==> {\n            let u = i - magic;\n            let stars = u;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        })\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: usize) -> (result: Vec<String>)\n    requires \n        valid_input(n as int)\n    ensures \n        valid_result(result@, n as int),\n        correct_diamond_pattern(result@, n as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0409", "language": "verus", "source": "apps", "source_id": "apps_test_2256", "vc-description": "Given n students in positions 1 to n, with two rival students initially at positions a and b,\nfind the maximum distance between the rivals after performing at most x adjacent swaps.\nDistance between positions p and s is |p - s|.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, x: int, a: int, b: int) -> bool {\n    2 <= n <= 100 && 0 <= x <= 100 && 1 <= a <= n && 1 <= b <= n && a != b\n}\n\nspec fn max_distance(n: int, x: int, a: int, b: int) -> int\n    recommends valid_input(n, x, a, b)\n{\n    let initial_distance = if a >= b { a - b } else { b - a };\n    let max_possible_distance = initial_distance + x;\n    let max_line_distance = n - 1;\n    if max_possible_distance <= max_line_distance { max_possible_distance } else { max_line_distance }\n}\n\nspec fn valid_result(n: int, x: int, a: int, b: int, result: int) -> bool\n    recommends valid_input(n, x, a, b)\n{\n    result == max_distance(n, x, a, b) && 0 <= result <= n - 1\n}", "vc-helpers": "", "vc-spec": "fn solve_rival_distance(n: i8, x: i8, a: i8, b: i8) -> (result: i8)\n    requires\n        valid_input(n as int, x as int, a as int, b as int),\n    ensures\n        valid_result(n as int, x as int, a as int, b as int, result as int),\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0410", "language": "verus", "source": "apps", "source_id": "apps_test_2282", "vc-description": "Given n movement commands ('L' for left, 'R' for right), determine how many\ndifferent final positions are possible when any subset of commands may be ignored.\nThe answer is always n + 1, representing all positions from minimum to maximum.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<u8>) -> bool {\n    input.len() > 0 && exists|i: int| 0 <= i < input.len() && input[i] == 10u8\n}\n\nspec fn valid_command_input(input: Seq<u8>) -> bool {\n    /* Abstract specification for valid command input */\n    input.len() >= 2\n}\n\nspec fn extract_n(input: Seq<u8>) -> int {\n    /* Abstract specification for extracting n */\n    if valid_command_input(input) { 42 } else { 0 }\n}\n\nspec fn correct_output(input: Seq<u8>, result: Seq<u8>) -> bool {\n    valid_command_input(input) ==> \n        result.len() > 0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<u8>) -> (result: Vec<u8>)\n    requires \n        valid_input(input@),\n    ensures \n        correct_output(input@, result@),\n        (!valid_command_input(input@) ==> result@.len() == 0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0411", "language": "verus", "source": "apps", "source_id": "apps_test_2293", "vc-description": "Given n stores and m days of shopping, determine if positive integer values can be assigned \nto stores such that Dora beats Swiper every day. Dora buys from some stores each day, \nSwiper from remaining stores. Dora wins if LCM(her purchases) > LCM(Swiper's purchases).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    input@.len() > 0\n    /* Additional validation logic would go here in a real implementation */\n}\n\nspec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    Set::empty() /* Placeholder - actual implementation would parse input */\n}\n\nspec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    let all_stores: Set<int> = Set::new(|i: int| 1 <= i <= n);\n    let dora_set = extract_dora_set(input, day_index, n);\n    all_stores.difference(dora_set)\n}\n\nspec fn solution_exists(input: &str) -> bool\n    recommends valid_input(input)\n{\n    /* Logic to check if a valid assignment exists */\n    true /* Placeholder */\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires\n        valid_input(input),\n    ensures\n        result@ =~= \"possible\"@ || result@ =~= \"impossible\"@,\n        (result@ =~= \"possible\"@) <==> solution_exists(input),", "vc-code": "{\n    assume(false);\n    \"impossible\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0412", "language": "verus", "source": "apps", "source_id": "apps_test_2297", "vc-description": "Given an array where element a[i] = i * (-1)^i (so a[1] = -1, a[2] = 2, a[3] = -3, etc.),\nanswer queries asking for the sum of elements from index l to r inclusive.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_query(query: (int, int)) -> bool {\n    query.0 >= 1 && query.0 <= query.1\n}\n\nspec fn valid_input(queries: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn array_element(i: int) -> int\n    recommends i >= 1\n{\n    i * (if i % 2 == 1 { -1 } else { 1 })\n}\n\nspec fn range_sum(l: int, r: int) -> int\n    recommends l >= 1\n    decreases r - l + 1\n{\n    if l > r { 0 } else { array_element(l) + range_sum(l + 1, r) }\n}\n\nspec fn prefix_sum(k: int) -> int {\n    if k % 2 == 0 { k / 2 } else { -(k + 1) / 2 }\n}\n\nspec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool\n    recommends valid_input(queries)\n{\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == prefix_sum(queries[i].1) - prefix_sum(queries[i].0 - 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))\n    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0413", "language": "verus", "source": "apps", "source_id": "apps_test_2308", "vc-description": "Given two binary strings x and y representing integers f(x) and f(y), find the non-negative integer k \nthat minimizes the lexicographic value of rev_k, where s_k = f(x) + f(y) × 2^k and rev_k is the \nbinary representation of s_k written in reverse order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 && \n    is_valid_number(lines[0]) &&\n    {\n        let t = string_to_int(lines[0]);\n        t >= 0 && lines.len() >= 2 * t + 1 &&\n        forall|i: int| 1 <= i < 2 * t + 1 ==> #[trigger] lines.len() > i && is_binary_string(lines[i]) && contains_one(lines[i])\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] is_valid_number(output_lines[i])\n    }\n}\n\nspec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && 1 + 2*i < lines.len() && 2 + 2*i < lines.len() ==> {\n            let x = lines[1 + 2*i];\n            let y = lines[2 + 2*i];\n            let rev_x = reverse(x);\n            let rev_y = reverse(y);\n            let start = index_of(rev_y, '1');\n            start >= 0 &&\n            {\n                let offset = index_of_from(rev_x, '1', start);\n                #[trigger] string_to_int(output_lines[i]) == offset\n            }\n        }\n    }\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == '0' || s.index(i) == '1'\n}\n\nspec fn contains_one(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && #[trigger] s.index(i) == '1'\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '0' && s.index(i) <= '9'\n}\n\n/* Helper functions */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    arbitrary()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    arbitrary()\n}\n\nspec fn reverse(s: Seq<char>) -> Seq<char> {\n    arbitrary()\n}\n\nspec fn index_of(s: Seq<char>, c: char) -> int {\n    arbitrary()\n}\n\nspec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {\n    arbitrary()\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (output: String)\n    requires\n        input@.len() > 0,\n        input@.index(input@.len() as int - 1) == '\\n',\n        valid_input(input@),\n    ensures\n        valid_output(output@, input@),\n        output@.len() > 0 ==> output@.index(output@.len() as int - 1) != '\\n',\n        correct_computation(output@, input@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0414", "language": "verus", "source": "apps", "source_id": "apps_test_2320", "vc-description": "Given two strings s and t of equal length, determine the minimum number of moves needed to transform s into t.\nIn each move, you can select any character from s and move it to either the beginning or end of the string.\nIf transformation is impossible, return -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_character(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == c { 1 as int } else { 0 as int }) + count_character(s.skip(1), c)\n    }\n}\n\nspec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && \n    (forall|c: char| count_character(s, c) == count_character(t, c))\n}\n\nspec fn find_next_match(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        s.len() as int\n    } else if s[start] == c {\n        start\n    } else {\n        find_next_match(s, c, start + 1)\n    }\n}\n\nspec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool\n    decreases j - i + 1, s.len() - k\n{\n    if i > j {\n        true\n    } else if k >= s.len() {\n        false\n    } else {\n        let next_k = find_next_match(s, t[j], k);\n        if next_k >= s.len() {\n            false\n        } else if i == j {\n            true\n        } else {\n            can_match_substring(s, t, i, j-1, next_k+1)\n        }\n    }\n}\n\nspec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int\n    decreases t.len() - i, t.len() - j\n{\n    if i >= t.len() {\n        max_so_far\n    } else if j >= t.len() {\n        max_preservable_length(s, t, i+1, i+1, max_so_far)\n    } else {\n        let current_len = j - i + 1;\n        let can_match = can_match_substring(s, t, i, j, 0);\n        let new_max = if can_match && current_len > max_so_far { current_len } else { max_so_far };\n        max_preservable_length(s, t, i, j+1, new_max)\n    }\n}\n\nspec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        max_preservable_length(s, t, 0, 0, 0)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>, t: Vec<char>) -> (result: i32)\n    requires \n        s.len() == t.len(),\n        s.len() >= 0,\n    ensures \n        result == -1 <==> !has_same_character_counts(s@, t@),\n        result >= -1,\n        result != -1 ==> 0 <= result <= s.len() as i32,\n        result != -1 ==> has_same_character_counts(s@, t@),\n        result != -1 ==> result == s.len() as i32 - max_longest_subsequence(s@, t@) as i32,\n        s.len() == 0 ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0416", "language": "verus", "source": "apps", "source_id": "apps_test_2330", "vc-description": "Given n fridges with weights a₁, a₂, ..., aₙ, create exactly m steel chains between fridges \nsuch that all fridges are \"private\". A chain connecting fridges u and v costs aᵤ + aᵥ. \nA fridge is \"private\" if only its owner can unlock it. Find the minimum total cost to create \nexactly m chains making all fridges private, or determine if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum Result {\n    Impossible,\n    Possible { cost: int, edges: Seq<(int, int)> }\n}\n\nspec fn seq_sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + seq_sum(s.skip(1))\n    }\n}\n\nspec fn seq_sum_first(s: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n > 0 && n - 1 < s.len() {\n        s[n-1] + seq_sum_first(s, n-1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index(weights: Seq<int>) -> int {\n    if weights.len() > 0 {\n        min_index_helper(weights, 0, 1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if weights[next] < weights[current_min] {\n        min_index_helper(weights, next, next + 1)\n    } else {\n        min_index_helper(weights, current_min, next + 1)\n    }\n}\n\nspec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {\n    if weights.len() > 1 && 0 <= exclude < weights.len() {\n        let first_valid = if exclude == 0 { 1 } else { 0 };\n        min_index_excluding_helper(weights, exclude, first_valid, 0)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if next == exclude {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    } else if weights[next] < weights[current_min] {\n        min_index_excluding_helper(weights, exclude, next, next + 1)\n    } else {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(t: i8, cases: Vec<(i8, i8, Vec<i8>)>) -> (results: Vec<Result>)\n    requires \n        t >= 0,\n        cases.len() == t as nat,\n        forall|i: int| #![auto] 0 <= i < t as int ==> \n            cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2@.len() == cases[i].0 as nat\n    ensures \n        results@.len() == t as nat", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0417", "language": "verus", "source": "apps", "source_id": "apps_test_2340", "vc-description": "Navigate down a cliff from height h to ground using platforms and magic crystals.\nCharacter starts at platform height h, can pull levers to hide current platform and toggle platform at height x-1,\ncan fall safely at most 2 heights, and magic crystals can toggle any platform state (except height h).\nFind minimum number of crystals needed to reach ground safely.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {\n    h >= 1 && n >= 1 && platforms.len() >= n && n > 0 && platforms.len() > 0 && platforms[0] == h\n}\n\nspec fn valid_crystal_count(crystals: int, n: int) -> bool {\n    crystals >= 0 && crystals <= n - 1\n}\n\nspec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {\n    if platforms.len() >= 1 && platforms[0] == h && h >= 1 {\n        if platforms.len() == 1 {\n            0\n        } else {\n            count_crystals_needed_up_to(h, platforms.push(0), (platforms.len() - 1) as int)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            0\n        } else {\n            let cur_pos = simulate_position_up_to(h, arr, up_to - 1);\n            let prev_crystals = count_crystals_needed_up_to(h, arr, up_to - 1);\n            if cur_pos == arr[up_to as int] {\n                prev_crystals\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                prev_crystals\n            } else {\n                prev_crystals + 1\n            }\n        }\n    } else {\n        0\n    }\n}\n\nspec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            h\n        } else {\n            let prev_pos = simulate_position_up_to(h, arr, up_to - 1);\n            if prev_pos == arr[up_to as int] {\n                prev_pos\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                arr[up_to as int] - 1\n            } else {\n                prev_pos\n            }\n        }\n    } else {\n        h\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    requires input@.len() > 0\n    ensures result@.len() >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0418", "language": "verus", "source": "apps", "source_id": "apps_test_2350", "vc-description": "An infinite table is filled starting from cell (1,1) which contains integer 1.\nEach cell (x,y) contains the sum of the cell above it (x-1,y) and the cell to its left (x,y-1).\nFor boundary cases: cell(1,y) = y and cell(x,1) = x.\nGiven start coordinates (x₁, y₁) and end coordinates (x₂, y₂), find the number of\ndifferent possible sums when traversing from start to end cell, moving only down or right.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_test_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    1 <= x1 <= x2 && 1 <= y1 <= y2\n}\n\nspec fn count_different_sums(x1: int, y1: int, x2: int, y2: int) -> int\n    recommends valid_test_case(x1, y1, x2, y2)\n{\n    (x2 - x1) * (y2 - y1) + 1\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires valid_input(input@)\n    ensures output@.len() >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0419", "language": "verus", "source": "apps", "source_id": "apps_test_2353", "vc-description": "Given four integers representing sleep requirements and alarm timing,\nsimulate an alarm system where: first alarm rings after b minutes,\nif total sleep >= a then wake permanently, otherwise set alarm for c minutes later\nand spend d minutes falling asleep. If alarm rings while falling asleep (c <= d),\nreset and repeat. Find total time until permanent wake or -1 if never happens.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && d >= 0\n}\n\nspec fn first_alarm_sufficient(a: int, b: int) -> bool {\n    a <= b\n}\n\nspec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c <= d\n}\n\nspec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c > d\n}\n\nspec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {\n    let remaining = a - b;\n    let cycles = (remaining - 1) / (c - d) + 1;\n    b + c * cycles\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int, d as int)\n    ensures \n        first_alarm_sufficient(a as int, b as int) ==> result as int == b as int,\n        never_wakes(a as int, b as int, c as int, d as int) ==> result == -1,\n        eventually_wakes(a as int, b as int, c as int, d as int) ==> result as int == calculate_wake_time(a as int, b as int, c as int, d as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0420", "language": "verus", "source": "apps", "source_id": "apps_test_2354", "vc-description": "Fill an n×n chessboard with numbers 1 to n² using a specific pattern:\nPlace first ⌈n²/2⌉ numbers in cells where (row + column) is even, filling left-to-right, top-to-bottom\nPlace remaining numbers in cells where (row + column) is odd, filling left-to-right, top-to-bottom\nFor given queries (xi, yi), return the number at each position", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, queries: Seq<(int, int)>) -> bool {\n    n > 0 && \n    forall|i: int| 0 <= i < queries.len() ==> #[trigger] queries[i].0 >= 1 && #[trigger] queries[i].0 <= n && #[trigger] queries[i].1 >= 1 && #[trigger] queries[i].1 <= n\n}\n\nspec fn chessboard_value(n: int, x: int, y: int) -> int {\n    if (x + y) % 2 == 0 {\n        1 + (x / 2) * n + (x % 2) * ((n + 1) / 2) + y / 2\n    } else {\n        (n * n + 1) / 2 + 1 + (x / 2) * n + (x % 2) * (n / 2) + y / 2\n    }\n}\n\nspec fn valid_result(n: int, queries: Seq<(int, int)>, results: Seq<int>) -> bool {\n    valid_input(n, queries) ==> (\n        results.len() == queries.len() &&\n        forall|i: int| 0 <= i < queries.len() ==> {\n            let x = #[trigger] queries[i].0 - 1;\n            let y = #[trigger] queries[i].1 - 1;\n            0 <= x < n && 0 <= y < n &&\n            #[trigger] results[i] == chessboard_value(n, x, y)\n        }\n    )\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires valid_input(n as int, queries@.map(|i: int, q: (i8, i8)| (q.0 as int, q.1 as int)))\n    ensures valid_result(n as int, queries@.map(|i: int, q: (i8, i8)| (q.0 as int, q.1 as int)), results@.map(|i: int, r: i8| r as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0422", "language": "verus", "source": "apps", "source_id": "apps_test_2375", "vc-description": "Two players Alice and Brown play a turn-based stone game starting with Alice.\nThere are two piles with X and Y stones. On each turn, a player chooses positive\ninteger i, takes 2i stones from one pile (requiring at least 2i stones),\ndiscards i stones, and places remaining i stones in the other pile.\nThe player who cannot make a valid move loses. Determine winner with optimal play.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn alice_wins(x: int, y: int) -> bool {\n    abs(x - y) > 1\n}\n\nspec fn brown_wins(x: int, y: int) -> bool {\n    abs(x - y) <= 1\n}\n\nspec fn valid_input(x: int, y: int) -> bool {\n    x >= 0 && y >= 0\n}", "vc-helpers": "", "vc-spec": "fn determine_winner(x: i8, y: i8) -> (winner: &'static str)\n    requires \n        valid_input(x as int, y as int),\n    ensures \n        winner == \"Alice\" || winner == \"Brown\",\n        (winner == \"Alice\") <==> alice_wins(x as int, y as int),\n        (winner == \"Brown\") <==> brown_wins(x as int, y as int),", "vc-code": "{\n    assume(false);\n    \"Alice\"\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0423", "language": "verus", "source": "apps", "source_id": "apps_test_2377", "vc-description": "Find the minimum number of attacks needed to deal at least H total damage to a monster\nusing N katanas. Each katana can be wielded (deals a_i damage, repeatable) or \nthrown (deals b_i damage, once only). Constraints: a_i <= b_i, all values positive.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, h: int, a: Seq<int>, b: Seq<int>) -> bool {\n    a.len() == n && b.len() == n && n > 0 && h > 0 &&\n    (forall|i: int| 0 <= i < n ==> a[i] > 0 && b[i] > 0) &&\n    (forall|i: int| 0 <= i < n ==> a[i] <= b[i])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn max_wield_exists(a: Seq<int>, max_a: int) -> bool {\n    (exists|i: int| 0 <= i < a.len() && a[i] == max_a) &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] <= max_a)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, h: i8, a: Vec<i8>, b: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, h as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))\n    ensures result > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0425", "language": "verus", "source": "apps", "source_id": "apps_test_2386", "vc-description": "Given an integer sequence A of length N, find the minimum value of:\nabs(A₁ - (b+1)) + abs(A₂ - (b+2)) + ... + abs(Aₙ - (b+N))\nwhere b is any integer we can choose.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1\n}\n\nspec fn transform(a: Seq<int>) -> Seq<int> {\n    Seq::new(a.len(), |i: int| a[i] - (i + 1))\n}\n\nspec fn sum_abs_diffs(a: Seq<int>, target: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        abs_int(a[0] - target) + sum_abs_diffs(a.subrange(1, a.len() as int), target)\n    }\n}\n\nspec fn median_of(a: Seq<int>) -> int {\n    let sorted = sorted_seq(a);\n    if sorted.len() == 0 {\n        0\n    } else if sorted.len() % 2 == 1 {\n        sorted[sorted.len() as int / 2]\n    } else if sorted.len() == 2 {\n        (sorted[0] + sorted[1]) / 2\n    } else {\n        (sorted[sorted.len() as int / 2 - 1] + sorted[sorted.len() as int / 2]) / 2\n    }\n}\n\nspec fn sorted_seq(a: Seq<int>) -> Seq<int> {\n    a\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int == sum_abs_diffs(transform(a@.map(|i: int, x: i8| x as int)), median_of(transform(a@.map(|i: int, x: i8| x as int)))),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0426", "language": "verus", "source": "apps", "source_id": "apps_test_2396", "vc-description": "Given m ships, each with a destination coordinate expressed as (a+b)/c where a, b, c are positive integers,\ndetermine how many ships (including itself) will have the same destination coordinate for each ship.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(result: Seq<int>, input: Seq<char>) -> bool {\n    result.len() >= 0 &&\n    (forall|i: int| 0 <= i < result.len() ==> result[i] >= 1) &&\n    (forall|i: int| 0 <= i < result.len() ==> result[i] <= result.len())\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<i8>)\n    requires valid_input(input@)\n    ensures valid_output(result@.map(|i: int, x: i8| x as int), input@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0427", "language": "verus", "source": "apps", "source_id": "apps_test_2406", "vc-description": "Simulate a landslide process on an array of strictly increasing heights.\nEach minute, for every position j where h_j + 2 ≤ h_{j+1}, one unit slides \nfrom position j+1 to position j. All transfers happen simultaneously.\nThe process stops when no position satisfies the sliding condition.\nReturn the final stable heights.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])\n}\n\nspec fn valid_output(n: int, result: Seq<int>) -> bool {\n    result.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)\n}\n\nspec fn is_stable(result: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, heights: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, heights@.map(|i, v| v as int))\n    ensures \n        valid_output(n as int, result@.map(|i, v| v as int)) &&\n        sum_seq(result@.map(|i, v| v as int)) == sum_seq(heights@.map(|i, v| v as int)) &&\n        is_stable(result@.map(|i, v| v as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0429", "language": "verus", "source": "apps", "source_id": "apps_test_2422", "vc-description": "Given an integer n representing total windows in a building, find any valid combination\nof non-negative integers (a, b, c) representing 3-room, 5-room, and 7-room apartments\nsuch that 3a + 5b + 7c = n. Return -1 if no valid combination exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_solution(n: int, a: int, b: int, c: int) -> bool {\n        a >= 0 && b >= 0 && c >= 0 && 3 * a + 5 * b + 7 * c == n\n    }\n    \n    spec fn valid_result(n: int, result: Seq<int>) -> bool {\n        (result.len() == 1 && result[0] == -1) ||\n        (result.len() == 3 && result[0] >= 0 && result[1] >= 0 && result[2] >= 0 && \n         valid_solution(n, result[0], result[1], result[2]))\n    }", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<i8>)\n    requires \n        n as int >= 1,\n    ensures \n        valid_result(n as int, result@.map(|_index, x: i8| x as int)),\n        (n as int) % 3 == 0 ==> (result@.len() == 3 && result@.map(|_index, x: i8| x as int) == seq![(n as int) / 3, 0, 0]),\n        (n as int) % 3 == 1 && (n as int) < 7 ==> (result@.len() == 1 && result@[0] as int == -1),\n        (n as int) % 3 == 1 && (n as int) >= 7 ==> (result@.len() == 3 && result@.map(|_index, x: i8| x as int) == seq![((n as int) - 7) / 3, 0, 1]),\n        (n as int) % 3 == 2 && (n as int) < 5 ==> (result@.len() == 1 && result@[0] as int == -1),\n        (n as int) % 3 == 2 && (n as int) >= 5 ==> (result@.len() == 3 && result@.map(|_index, x: i8| x as int) == seq![((n as int) - 5) / 3, 1, 0])", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "}\n\nfn main() {}"}
{"id": "VA0430", "language": "verus", "source": "apps", "source_id": "apps_test_2425", "vc-description": "Given a positive integer a, find the maximum possible value of gcd(a ⊕ b, a & b) \nwhere b is chosen from the range [1, a-1] and ⊕ denotes XOR and & denotes AND operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn power2(k: nat) -> int\n    decreases k\n{\n    if k == 0 { 1 } else { 2 * power2((k - 1) as nat) }\n}\n\nspec fn valid_query(a: int) -> bool\n{\n    2 <= a <= power2(25) - 1\n}\n\nspec fn valid_queries(queries: Seq<int>) -> bool\n{\n    forall|i: int| #![auto] 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn largest_proper_divisor(n: int) -> int\n    recommends n > 1\n{\n    if n <= 1 { \n        1 \n    } else { \n        largest_proper_divisor_helper(n, 2) \n    }\n}\n\nspec fn largest_proper_divisor_helper(n: int, d: int) -> int\n    recommends n > 1 && d >= 2\n    decreases if n >= d { n - d } else { 0 }\n{\n    if d * d > n { \n        1 \n    } else if n % d == 0 { \n        let quotient = n / d;\n        if quotient == d { \n            quotient \n        } else if n > d {\n            let remainder_check = largest_proper_divisor_helper(n, d + 1);\n            if quotient > remainder_check { quotient } else { remainder_check }\n        } else {\n            quotient\n        }\n    } else if n > d { \n        largest_proper_divisor_helper(n, d + 1) \n    } else {\n        1\n    }\n}\n\nspec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool\n{\n    results.len() == queries.len() &&\n    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&\n    true\n}", "vc-helpers": "", "vc-spec": "fn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_queries(queries@.map(|_i, x: i8| x as int))\n    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0432", "language": "verus", "source": "apps", "source_id": "apps_test_2434", "vc-description": "Given two integers n and m where m < n, determine if it's possible to select m vertices \nfrom a regular n-gon such that these m vertices form a regular m-gon with the same center.\nThe solution is \"YES\" if n is divisible by m, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn yes_string() -> Seq<char> {\n    seq!['Y', 'E', 'S']\n}\n\nspec fn no_string() -> Seq<char> {\n    seq!['N', 'O']\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_by_newline(input);\n    lines.len() >= 1 && \n    is_valid_int(lines[0]) &&\n    {\n        let t = parse_int(lines[0]);\n        t >= 0 && t + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= t ==> #[trigger] is_valid_two_int_line(lines[i])\n    }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn is_valid_two_int_line(s: Seq<char>) -> bool {\n    let parts = split_by_space(s);\n    parts.len() >= 2 && is_valid_int(parts[0]) && is_valid_int(parts[1])\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    let input_lines = split_by_newline(input);\n    if input_lines.len() == 0 { \n        output.len() == 0\n    } else {\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_by_newline(output);\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] seq_equals(output_lines[i], yes_string()) || #[trigger] seq_equals(output_lines[i], no_string())\n    }\n}\n\nspec fn correct_divisibility_results(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_by_newline(input);\n    if input_lines.len() == 0 { \n        output.len() == 0\n    } else {\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_by_newline(output);\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && i + 1 < input_lines.len() ==> {\n            let parts = split_by_space(input_lines[i + 1]);\n            parts.len() >= 2 ==> {\n                let x = parse_int(parts[0]);\n                let y = parse_int(parts[1]);\n                y != 0 ==> (#[trigger] seq_equals(output_lines[i], yes_string()) <==> x % y == 0)\n            }\n        }\n    }\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == #[trigger] s2[i]\n}\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![]\n    } else if s[0] == '\\n' { \n        seq![seq![]].add(split_by_newline(s.subrange(1, s.len() as int)))\n    } else {\n        let rest = split_by_newline(s.subrange(1, s.len() as int));\n        if rest.len() == 0 { \n            seq![s]\n        } else { \n            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![]\n    } else if s[0] == ' ' { \n        seq![seq![]].add(split_by_space(s.subrange(1, s.len() as int)))\n    } else {\n        let rest = split_by_space(s.subrange(1, s.len() as int));\n        if rest.len() == 0 { \n            seq![s]\n        } else { \n            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 {\n        if '0' <= s[0] <= '9' { \n            s[0] as int - '0' as int \n        } else { \n            0 \n        }\n    } else {\n        if '0' <= s[0] <= '9' {\n            (s[0] as int - '0' as int) * pow10(s.len() - 1) + parse_int(s.subrange(1, s.len() as int))\n        } else { \n            0 \n        }\n    }\n}\n\nspec fn pow10(n: int) -> int \n    decreases n\n{\n    if n <= 0 { 1 } else { 10 * pow10(n - 1) }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires \n        input.len() > 0,\n        valid_input_format(input@),\n    ensures \n        forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n',\n        valid_output_format(output@, input@),\n        correct_divisibility_results(input@, output@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0433", "language": "verus", "source": "apps", "source_id": "apps_test_2435", "vc-description": "Given an array of n integers where initially a[x] = 1 and all other elements are 0,\ndetermine how many positions can contain the value 1 after performing m swap operations optimally.\nEach operation i allows swapping any two elements at positions c and d where l_i ≤ c, d ≤ r_i.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool {\n    test_cases.len() >= 0 &&\n    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {\n        let (n, x, operations) = test_cases[i];\n        n >= 1 && 1 <= x <= n && operations.len() >= 0 &&\n        forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 >= 1 && {\n            let (l, r) = operations[j];\n            1 <= l <= r <= n\n        }\n    }\n}\n\nspec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)\n    recommends forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 <= operations[j].1\n{\n    compute_final_bounds_helper(x, x, operations, 0)\n}\n\nspec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool\n    recommends valid_input(test_cases)\n{\n    results.len() == test_cases.len() &&\n    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {\n        let (n, x, operations) = test_cases[i];\n        let final_bounds = compute_final_bounds(x, operations);\n        results[i] == final_bounds.1 - final_bounds.0 + 1 &&\n        final_bounds.0 <= x <= final_bounds.1 &&\n        results[i] >= 1 &&\n        1 <= final_bounds.0 <= final_bounds.1 <= n\n    }\n}\n\nspec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)\n    decreases operations.len() - index\n{\n    if index >= operations.len() {\n        (min_pos, max_pos)\n    } else {\n        let (l, r) = operations[index];\n        let new_min = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {\n            if l < min_pos { l } else { min_pos }\n        } else { min_pos };\n        let new_max = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {\n            if r > max_pos { r } else { max_pos }\n        } else { max_pos };\n        compute_final_bounds_helper(new_min, new_max, operations, index + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(test_cases: Vec<(i8, i8, Vec<(i8, i8)>)>) -> (results: Vec<i8>)\n    requires valid_input(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))))\n    ensures valid_results(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))), results@.map(|i: int, r: i8| r as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0434", "language": "verus", "source": "apps", "source_id": "apps_test_2443", "vc-description": "Given a modulus m and a list of n forbidden values, construct the longest possible sequence where:\n- Each sequence element is an integer in [0, m-1]  \n- All prefix products modulo m are distinct\n- No prefix product modulo m equals any forbidden value\n- Sequence length is maximized", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat\n  recommends modulus > 0, i <= s.len()\n  decreases i\n{\n    if i == 0 { 1 }\n    else { (s[i as int - 1] * prefix_product(s, (i - 1) as nat, modulus)) % modulus }\n}\n\nspec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>\n  recommends modulus > 0\n{\n    Seq::new(s.len(), |i: int| prefix_product(s, (i + 1) as nat, modulus))\n}\n\nspec fn all_distinct<T>(s: Seq<T>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]\n}\n\nspec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool\n  recommends modulus > 0\n{\n    let products = prefix_products(s, modulus);\n    forall|i: int| 0 <= i < products.len() ==> !forbidden.contains(products[i])\n}\n\nspec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {\n    m >= 1 &&\n    n >= 0 &&\n    forbidden.len() == n &&\n    (forall|i: int| 0 <= i < forbidden.len() ==> #[trigger] forbidden[i] >= 0 && forbidden[i] < m) &&\n    (forall|i: int, j: int| 0 <= i < j < forbidden.len() ==> #[trigger] forbidden[i] != #[trigger] forbidden[j])\n}\n\nspec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool\n  recommends m > 0\n{\n    (forall|i: int| 0 <= i < sequence.len() ==> #[trigger] sequence[i] >= 0 && sequence[i] < m) &&\n    all_distinct(Seq::new(1, |x: int| 1).add(prefix_products(sequence, m))) &&\n    no_forbidden_products(sequence, forbidden, m)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8, m: u8, forbidden: Vec<u8>) -> (result: (u8, Vec<u8>))\n  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))\n  ensures ({\n      let (length, sequence) = result;\n      length == sequence.len() as u8 &&\n      length >= 0 &&\n      (m == 1 ==> length == 0 && sequence@ == Seq::<u8>::empty()) &&\n      (m > 1 ==> valid_sequence(sequence@.map(|i, x: u8| x as nat), m as nat, forbidden@.map(|i, x: u8| x as nat))) &&\n      (n == 0 && m > 1 ==> length > 0)\n  })", "vc-code": "{\n    assume(false);\n    (0, Vec::new())\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0437", "language": "verus", "source": "apps", "source_id": "apps_test_2451", "vc-description": "Given a building with n towers and h floors each, find minimum travel time between pairs of locations.\nHorizontal passages exist between adjacent towers only on floors a through b (inclusive).\nMoving between adjacent floors or towers takes exactly 1 minute.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {\n    n >= 1 && h >= 1 && 1 <= a <= b <= h\n}\n\nspec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {\n    1 <= query.0 <= n && 1 <= query.1 <= h &&\n    1 <= query.2 <= n && 1 <= query.3 <= h\n}\n\nspec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> #[trigger] valid_query(queries[i], n, h)\n}\n\nspec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {\n    if t1 == t2 {\n        if f1 >= f2 { f1 - f2 } else { f2 - f1 }\n    } else if f1 >= a && f1 <= b {\n        (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= f1 { f2 - f1 } else { f1 - f2 })\n    } else if f1 < a {\n        (a - f1) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= a { f2 - a } else { a - f2 })\n    } else {\n        (f1 - b) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= b { f2 - b } else { b - f2 })\n    }\n}\n\nspec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> {\n        let (t1, f1, t2, f2) = queries[i];\n        #[trigger] results[i] == min_travel_time(t1, f1, t2, f2, a, b)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, h: i8, a: i8, b: i8, queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)\n    requires\n        valid_building_params(n as int, h as int, a as int, b as int),\n        valid_queries(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), n as int, h as int),\n    ensures\n        correct_results(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), results@.map_values(|x: i8| x as int), a as int, b as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0438", "language": "verus", "source": "apps", "source_id": "apps_test_2456", "vc-description": "Given integers n and r, determine the number of distinct shapes that can be formed\nby painting n consecutive days on calendars where a week can have k days (1 ≤ k ≤ r).\nDays are arranged left-to-right in rows, wrapping to the next row when reaching \nthe end of a week. All painted cells must be connected by sides. Two shapes are \nconsidered the same if one can be moved to exactly overlap the other using only \nparallel translations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, r: int) -> bool {\n    n >= 1 && r >= 1\n}\n\nspec fn expected_result(n: int, r: int) -> int {\n    if valid_input(n, r) {\n        let k = if r < n - 1 { r } else { n - 1 };\n        k * (k + 1) / 2 + if r >= n { 1int } else { 0int }\n    } else {\n        0int\n    }\n}\n\nfn solve_shapes(n: i8, r: i8) -> (result: i8)\n    requires valid_input(n as int, r as int)\n    ensures result as int == expected_result(n as int, r as int)", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0440", "language": "verus", "source": "apps", "source_id": "apps_test_2465", "vc-description": "Given an angle measurement in degrees, find the minimum number of vertices n for a regular n-gon \nthat contains three vertices a, b, c such that the angle ∠abc equals the given angle. \nIf no such n-gon exists, return -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(angles: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < angles.len() ==> #[trigger] angles[i] >= 1 && #[trigger] angles[i] < 180\n}\n\nspec fn gcd(a: int, b: int) -> int;\n\nspec fn compute_answer(angle: int) -> int {\n    let g = gcd(angle, 180int);\n    let de_over_g = angle / g;\n    let n180_over_g = 180int / g;\n    if de_over_g == n180_over_g - 1 { n180_over_g * 2 } else { n180_over_g }\n}\n\nspec fn correct_output(angles: Seq<int>, result: Seq<int>) -> bool {\n    valid_input(angles) ==> (\n        result.len() == angles.len() &&\n        forall|i: int| 0 <= i < angles.len() ==> #[trigger] result[i] == compute_answer(#[trigger] angles[i])\n    )\n}", "vc-helpers": "", "vc-spec": "fn solve(angles: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(angles@.map(|i, x: i8| x as int))\n    ensures correct_output(angles@.map(|i, x: i8| x as int), result@.map(|i, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0442", "language": "verus", "source": "apps", "source_id": "apps_test_2467", "vc-description": "Find all unique combinations of exactly k distinct numbers from the range [1, 9] that sum to n.\nEach number must be from 1 to 9, used at most once per combination, with no duplicate combinations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn is_distinct(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j]\n}\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i + 1]\n}\n\nspec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool {\n    combo.len() == k &&\n    sum(combo) == n &&\n    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&\n    is_distinct(combo) &&\n    is_sorted(combo)\n}\n\nspec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n    combo.len() == k &&\n    sum(combo) == n &&\n    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&\n    is_distinct(combo) &&\n    is_sorted(combo) &&\n    combo.len() >= temp.len() &&\n    (forall|i: int| 0 <= i < temp.len() ==> #[trigger] temp[i] == #[trigger] combo[i]) &&\n    (forall|i: int| temp.len() <= i < combo.len() ==> #[trigger] combo[i] >= start)\n}", "vc-helpers": "spec fn to_int_seq(v: Vec<i8>) -> Seq<int> {\n    v@.map(|i: int, x: i8| x as int)\n}\n", "vc-spec": "fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)\n    requires k > 0 && n > 0 && k <= 9\n    ensures \n        (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == k as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> sum(to_int_seq(#[trigger] result[i])) == n as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < #[trigger] result[i].len() ==> 1 <= #[trigger] result[i][j] as int <= 9) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_distinct(to_int_seq(#[trigger] result[i]))) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_sorted(to_int_seq(#[trigger] result[i]))) &&\n        (forall|i: int, j: int| 0 <= i < j < result.len() ==> to_int_seq(#[trigger] result[i]) != to_int_seq(#[trigger] result[j])) &&\n        (forall|combo: Seq<int>| is_valid_combination(combo, k as int, n as int) ==> exists|i: int| 0 <= i < result.len() && to_int_seq(#[trigger] result[i]) == combo) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(#[trigger] result[i]), k as int, n as int))", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0443", "language": "verus", "source": "apps", "source_id": "apps_test_2486", "vc-description": "Given N cards with positive integers, determine how many cards are \"unnecessary.\"\nA subset of cards is \"good\" if the sum of its numbers is at least K.\nA card is \"unnecessary\" if for every good subset containing this card, \nremoving the card from that subset still results in a good subset.\nCount the number of unnecessary cards.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int\n  recommends\n    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],\n    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,\n    k >= 1\n{\n  if sorted.len() == 0 {\n    0\n  } else {\n    unnecessary_cards_count_helper(sorted, k, 0, 0, 0)\n  }\n}\n\nspec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int\n  recommends\n    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],\n    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,\n    k >= 1,\n    0 <= i <= sorted.len(),\n    temp >= 0,\n    ans >= 0\n  decreases sorted.len() - i\n{\n  if i >= sorted.len() {\n    ans\n  } else {\n    let x = sorted[i];\n    if temp + x < k {\n      unnecessary_cards_count_helper(sorted, k, temp + x, ans + 1, i + 1)\n    } else {\n      unnecessary_cards_count_helper(sorted, k, 0, 0, i + 1)\n    }\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    n >= 1,\n    k >= 1,\n    a.len() == n as usize,\n    forall|i: int| 0 <= i < a.len() ==> a[i] as int >= 1\n  ensures\n    result >= 0,\n    result as int <= n as int,\n    exists|sorted: Seq<int>|\n      sorted.len() == a@.len() &&\n      sorted.to_multiset() == a@.map(|i: int, x: i8| x as int).to_multiset() &&\n      (forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j]) &&\n      (forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1) &&\n      result as int == unnecessary_cards_count(sorted, k as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0445", "language": "verus", "source": "apps", "source_id": "apps_test_2516", "vc-description": "Given a string S of length N containing only digits 0-9 and a prime number P,\ncount how many contiguous substrings of S are divisible by P when interpreted\nas base-10 integers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_prime(p: int) -> bool {\n    p >= 2 && forall|k: int| 2 <= k < p ==> #[trigger] (p % k) != 0\n}\n\nspec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {\n    n >= 1 &&\n    p >= 2 &&\n    is_prime(p) &&\n    s.len() == n &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn substring_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        substring_to_int(s.subrange(0, s.len() as int - 1)) * 10 + ((s[s.len() as int - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn valid_result(result: int, n: int) -> bool {\n    result >= 0 && result <= n * (n + 1) / 2\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, p: i8, s: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, p as int, s@)\n    ensures valid_result(result as int, n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0447", "language": "verus", "source": "apps", "source_id": "apps_test_2548", "vc-description": "Given an array of n integers (each from 0 to 9), count the number of subarrays \nwhere the sum of elements equals the length of the subarray.\nA subarray from index l to r is \"good\" if: sum(a[l] + a[l+1] + ... + a[r]) = (r - l + 1)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(digits: Seq<int>) -> bool {\n    digits.len() >= 1 && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= 0 && #[trigger] digits[i] <= 9\n}\n\nspec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool\n    recommends 0 <= start <= end < digits.len()\n{\n    let subarray_sum = sum(digits.subrange(start, end + 1));\n    let subarray_length = end - start + 1;\n    subarray_sum == subarray_length\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.drop_first()) }\n}\n\nspec fn count_good_subarrays(digits: Seq<int>) -> int\n    recommends valid_input(digits)\n{\n    count_good_subarrays_helper(digits, 0, map![0 => 1], 0, 0)\n}\n\nspec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, \n                                  current_sum: int, current_count: int) -> int\n    recommends \n        0 <= pos <= digits.len() &&\n        valid_input(digits) &&\n        current_count == pos &&\n        current_sum >= 0 &&\n        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&\n        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)\n    decreases digits.len() - pos\n{\n    if pos >= digits.len() { 0 }\n    else {\n        let new_sum = current_sum + digits[pos];\n        let new_count = current_count + 1;\n        let diff = new_count - new_sum;\n        let contribution = if freq_map.dom().contains(diff) { freq_map[diff] } else { 0 };\n        let new_freq_map = freq_map.insert(diff, if freq_map.dom().contains(diff) { freq_map[diff] + 1 } else { 1 });\n        contribution + count_good_subarrays_helper(digits, pos + 1, new_freq_map, new_sum, new_count)\n    }\n}", "vc-helpers": "", "vc-spec": "fn count_good_subarrays_in_array(digits: Vec<i8>) -> (count: i8)\n    requires \n        valid_input(digits@.map(|i, x| x as int)),\n    ensures \n        count >= 0,\n        count as int == count_good_subarrays(digits@.map(|i, x| x as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0448", "language": "verus", "source": "apps", "source_id": "apps_test_2550", "vc-description": "Given n students with scores between 0 and m, redistribute scores to maximize student 1's score\nwhile preserving the total sum and keeping all scores within [0, m].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && scores.len() == n &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 0 && #[trigger] scores[i] <= m\n}\n\nspec fn sum(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 { \n        0 \n    } else { \n        nums[0] + sum(nums.subrange(1, nums.len() as int)) \n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {\n    redistributed.len() == original.len() &&\n    sum(redistributed) == sum(original) &&\n    forall|i: int| 0 <= i < redistributed.len() ==> #[trigger] redistributed[i] >= 0 && #[trigger] redistributed[i] <= m\n}\n\nspec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {\n    min(sum(scores), m)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, scores: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n    ensures \n        result as int == max_possible_first_score(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n        result as int == min(sum(scores@.map(|_i: int, x: i8| x as int)), m as int),\n        exists|redistributed: Seq<int>| (valid_redistribution(scores@.map(|_i: int, x: i8| x as int), redistributed, m as int) && \n            redistributed[0] == result as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0451", "language": "verus", "source": "apps", "source_id": "apps_test_2560", "vc-description": "Given a target sum n and a range of coin denominations [l, r], determine if it's possible \nto make exactly the sum n using coins with denominations between l and r (inclusive).\nYou have unlimited coins of each valid denomination.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn can_make_sum(n: int, l: int, r: int) -> bool {\n    l > 0 && l <= r && n > 0 && n % l <= (r - l) * (n / l)\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 0\n}\n\nspec fn correct_solution(input: Seq<char>, result: Seq<char>) -> bool {\n    /* Implementation would require string parsing functions like split_lines, parse_int, etc.\n       For now, we'll use a simplified specification */\n    true\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        valid_output(result@),\n        correct_solution(input@, result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0452", "language": "verus", "source": "apps", "source_id": "apps_test_2568", "vc-description": "Given a string of '+' and '-' characters, simulate finding the minimum initial value\nneeded to keep a running sum non-negative throughout the string. Count the total\nnumber of characters processed across all attempts until finding a successful initial value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'\n}\n\nspec fn compute_result(s: Seq<char>) -> int {\n    compute_result_helper(s, 0, 0, 0, s.len() as int)\n}\n\nspec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        ans\n    } else if s[i] == '+' {\n        compute_result_helper(s, i + 1, cur + 1, pm, ans)\n    } else {\n        let new_cur = cur - 1;\n        if new_cur < pm {\n            compute_result_helper(s, i + 1, new_cur, new_cur, ans + i + 1)\n        } else {\n            compute_result_helper(s, i + 1, new_cur, pm, ans)\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(s@),\n        s.len() <= 127\n    ensures \n        result as int >= s@.len(),\n        result as int == compute_result(s@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0453", "language": "verus", "source": "apps", "source_id": "apps_test_2583", "vc-description": "Two players play a game starting with integer n. Players alternate turns, with the first player moving first.\nOn each turn, a player must make exactly one of these moves:\n1. Divide n by any odd divisor of n greater than 1\n2. Subtract 1 from n (only if n > 1)\nThe player unable to make a move loses. Determine the winner assuming both players play optimally.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn determine_winner(n: int) -> &'static str\n    recommends n >= 1\n{\n    if n == 1 { \"FastestFinger\" }\n    else if n == 2 { \"Ashishgup\" }\n    else if is_power_of_two(n) { \"FastestFinger\" }\n    else if n % 4 != 2 { \"Ashishgup\" }\n    else if is_limited_prime(n / 2) { \"FastestFinger\" }\n    else { \"Ashishgup\" }\n}\n\nspec fn is_power_of_two(n: int) -> bool\n    recommends n >= 1\n    decreases n\n{\n    if n <= 0 { false }\n    else { n == 1 || (n % 2 == 0 && is_power_of_two(n / 2)) }\n}\n\nspec fn is_limited_prime(p: int) -> bool\n    recommends p >= 1\n{\n    if p <= 1 { false }\n    else if p == 2 { true }\n    else if p % 2 == 0 { false }\n    else { true /* simplified primality check */ }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<i8>) -> (result: Vec<&'static str>)\n    requires\n        input.len() >= 1,\n        input[0] as int >= 1,\n        input.len() == input[0] as int + 1,\n        forall|i: int| #![auto] 1 <= i < input.len() ==> input[i as int] as int >= 1\n    ensures\n        result.len() == input[0] as int,\n        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int] == \"FastestFinger\" || result[i as int] == \"Ashishgup\",\n        forall|i: int| #![auto] 1 <= i < input.len() ==> result[(i-1) as int] == determine_winner(input[i as int] as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0455", "language": "verus", "source": "apps", "source_id": "apps_test_2602", "vc-description": "Given vanilla cookies (a), chocolate cookies (b), type-1 guests (n), and type-2 guests (m),\ndetermine if there exists an ordering of all guests such that no guest gets angry.\nType-1 guests choose vanilla if v > c, else chocolate.\nType-2 guests choose chocolate if v > c, else vanilla.\nA guest gets angry if their chosen cookie type has 0 cookies available.\n\n/* First check: must have enough total cookies */\n\n/* Second check: type-2 guests are the limiting factor */\n\n/* They will take from the minority cookie type, so we need */\n\n/* enough of the minority type to satisfy all type-2 guests */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_test_case(a: nat, b: nat, n: nat, m: nat) -> bool\n{\n    n + m > 0\n}\n\nspec fn can_satisfy_all_guests(a: nat, b: nat, n: nat, m: nat) -> bool\n{\n    a + b >= n + m &&\n    m <= min(a, b)\n}\n\nspec fn min(x: nat, y: nat) -> nat\n{\n    if x <= y { x } else { y }\n}", "vc-helpers": "", "vc-spec": "fn solve_cookie_distribution(a: u8, b: u8, n: u8, m: u8) -> (result: bool)\n    requires\n        valid_test_case(a as nat, b as nat, n as nat, m as nat),\n    ensures\n        result == can_satisfy_all_guests(a as nat, b as nat, n as nat, m as nat),\n        result ==> ((a as nat) + (b as nat) >= (n as nat) + (m as nat) && (m as nat) <= min(a as nat, b as nat)),\n        !result ==> ((a as nat) + (b as nat) < (n as nat) + (m as nat) || (m as nat) > min(a as nat, b as nat)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0456", "language": "verus", "source": "apps", "source_id": "apps_test_2612", "vc-description": "Find the maximum number of models that can be selected to form a \"beautiful arrangement.\"\nA beautiful arrangement is a subsequence of models arranged in increasing order of their indices,\nwhere for any two adjacent models with indices i and j (i < j), j must be divisible by i\nand the size of model i must be strictly less than the size of model j.\n\n/* All indices are distinct */\n\n/* Indices are in increasing order */\n\n/* Adjacent elements satisfy divisibility constraint */\n\n/* Adjacent elements satisfy size constraint */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_beautiful_arrangement(arrangement: Seq<int>, sizes: Seq<int>) -> bool {\n    arrangement.len() >= 1 &&\n    (forall|i: int, j: int| #![trigger arrangement[i], arrangement[j]] 0 <= i < j < arrangement.len() ==> arrangement[i] != arrangement[j]) &&\n    (forall|i: int| #![trigger arrangement[i]] 0 <= i < arrangement.len() - 1 ==> arrangement[i] < arrangement[i + 1]) &&\n    (forall|i: int| #![trigger arrangement[i]] 0 <= i < arrangement.len() - 1 ==> arrangement[i + 1] % arrangement[i] == 0) &&\n    (forall|i: int| #![trigger arrangement[i]] 0 <= i < arrangement.len() - 1 ==> \n        0 <= arrangement[i] - 1 < sizes.len() && \n        0 <= arrangement[i + 1] - 1 < sizes.len() &&\n        sizes[arrangement[i] - 1] < sizes[arrangement[i + 1] - 1])\n}\n\nspec fn valid_input(n: int, sizes: Seq<int>) -> bool {\n    n >= 1 && sizes.len() == n && forall|i: int| #![trigger sizes[i]] 0 <= i < n ==> sizes[i] >= 1\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, sizes: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, sizes@.map(|x: int, v: i8| v as int))\n    ensures 1 <= result as int <= n as int", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0459", "language": "verus", "source": "apps", "source_id": "apps_test_2622", "vc-description": "Given two maps: First map N × M grid, Second map M × N grid.\nFind positions i and j such that the M × M section from the first map \nstarting at row i equals the M × M section from the second map starting at column j.\nOutput the 1-indexed positions i and j.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = parse_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let first_line = parse_ints_func(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 1 && m <= n &&\n            lines.len() >= 1 + n + m &&\n            (forall|k: int| 1 <= k <= n ==> k < lines.len() && lines[k].len() >= m) &&\n            (forall|k: int| 1 + n <= k < 1 + n + m ==> k < lines.len() && lines[k].len() >= n)\n        }\n    }\n}\n\nspec fn valid_solution(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = parse_lines_func(input);\n    if lines.len() < 3 { \n        true \n    } else {\n        let first_line = parse_ints_func(lines[0]);\n        if first_line.len() < 2 { \n            true \n        } else {\n            let n = first_line[0];\n            let m = first_line[1];\n            if n <= 0 || m <= 0 || m > n { \n                true \n            } else {\n                let result_parts = parse_ints_func(result);\n                if result_parts.len() < 2 { \n                    false \n                } else {\n                    let i = result_parts[0];\n                    let j = result_parts[1];\n                    1 <= i <= n - m + 1 && 1 <= j <= n - m + 1 &&\n                    if lines.len() >= 1 + n + m { \n                        correct_sub_matrices_match(lines, n, m, i - 1, j - 1) \n                    } else { \n                        false \n                    }\n                }\n            }\n        }\n    }\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        false \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        exists|i: int, j: int| 0 <= i <= n - m && 0 <= j <= n - m &&\n            correct_sub_matrices_match(lines, n, m, i, j)\n    }\n}\n\nspec fn solution_found(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_solution(input, result) &&\n    if !valid_input_format(input) { \n        false \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let i = result_parts[0] - 1;\n            let j = result_parts[1] - 1;\n            correct_sub_matrices_match(lines, n, m, i, j)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        true \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let i = result_parts[0] - 1;\n            let j = result_parts[1] - 1;\n            0 <= i <= n - m && 0 <= j <= n - m &&\n            (forall|r: int, c: int| \n                #![trigger r + c]\n                (0 <= r < m && 0 <= c < m) ==> true)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn always_returns_first_match(input: Seq<char>, result: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        true \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let result_i = result_parts[0] - 1;\n            let result_j = result_parts[1] - 1;\n            forall|i: int, j: int| \n                #![trigger correct_sub_matrices_match(lines, n, m, i, j)]\n                (0 <= i <= n - m && 0 <= j <= n - m &&\n                (i < result_i || (i == result_i && j < result_j))) ==>\n                !correct_sub_matrices_match(lines, n, m, i, j)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool\n    recommends \n        lines.len() >= 1 + n + m,\n        0 <= i <= n - m && 0 <= j <= n - m\n{\n    forall|r: int, c: int| \n        #![trigger r + c]\n        (0 <= r < m && 0 <= c < m) ==> true\n}\n\nspec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]\n}\n\nspec fn parse_ints_func(line: Seq<char>) -> Seq<int> {\n    seq![1, 1]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else { seq!['1', '0'] }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        result@.len() > 0,\n        exists|i: int, j: int| i >= 1 && j >= 1 && result@ == int_to_string_func(i) + seq![' '] + int_to_string_func(j),\n        valid_solution(stdin_input@, result@),\n        solution_exists(stdin_input@) ==> solution_found(stdin_input@, result@),\n        correct_matrix_matching(stdin_input@, result@),\n        always_returns_first_match(stdin_input@, result@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0460", "language": "verus", "source": "apps", "source_id": "apps_test_2627", "vc-description": "Given a 2D binary matrix containing only \"0\"s and \"1\"s, find the area of the largest rectangle that contains only \"1\"s.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_matrix(matrix: Seq<Seq<&str>>) -> bool {\n    (forall|i: int| 0 <= i < matrix.len() ==> #[trigger] matrix[i].len() == (if matrix.len() == 0 { 0 } else { matrix[0].len() as int })) &&\n    (forall|i: int, j: int| 0 <= i < matrix.len() && 0 <= j < matrix[i].len() ==> #[trigger] matrix[i][j] == \"0\" || matrix[i][j] == \"1\")\n}\n\nspec fn max_possible_area(matrix: Seq<Seq<&str>>) -> int {\n    (matrix.len() as int) * (if matrix.len() == 0 { 0 } else { matrix[0].len() as int })\n}\n\nspec fn empty_matrix(matrix: Seq<Seq<&str>>) -> bool {\n    matrix.len() == 0 || matrix[0].len() == 0\n}", "vc-helpers": "", "vc-spec": "fn maximal_rectangle(matrix: Vec<Vec<&str>>) -> (result: i32)\n    requires\n        valid_matrix(matrix@.map(|i: int, row: Vec<&str>| row@)),\n    ensures\n        result >= 0,\n        empty_matrix(matrix@.map(|i: int, row: Vec<&str>| row@)) ==> result == 0,\n        result <= max_possible_area(matrix@.map(|i: int, row: Vec<&str>| row@)),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0461", "language": "verus", "source": "apps", "source_id": "apps_test_2629", "vc-description": "Given a positive integer n, create an n×n matrix filled with integers from 1 to n² \narranged in clockwise spiral order, starting from the top-left corner.\n\n/* Top row of current layer */\n\n/* Right column of current layer */\n\n/* Bottom row of current layer */\n\n/* Left column of current layer */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn spiral_order(row: int, col: int, n: int) -> int\n    recommends 0 <= row < n && 0 <= col < n && n >= 1\n    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1\n{\n    let layer = min(min(row, col), min(n-1-row, n-1-col));\n    let layer_start = 4 * layer * (n - layer - 1) + layer;\n\n    if row == layer {\n        /* Top row of current layer */\n        layer_start + (col - layer)\n    } else if col == n - 1 - layer {\n        /* Right column of current layer */\n        layer_start + (n - 2 * layer - 1) + (row - layer)\n    } else if row == n - 1 - layer {\n        /* Bottom row of current layer */\n        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)\n    } else {\n        /* Left column of current layer */\n        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {\n    matrix.len() == n &&\n    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)\n}", "vc-helpers": "", "vc-spec": "fn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)\n    requires \n        valid_input(n as int)\n    ensures \n        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0462", "language": "verus", "source": "apps", "source_id": "apps_test_2630", "vc-description": "Given an m×n grid where 0 represents empty cell and 1 represents obstacle,\nfind the number of unique paths from top-left (0,0) to bottom-right (m-1,n-1).\nMovement is restricted to right and down only, cannot pass through obstacles.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && grid[0].len() > 0 &&\n    (forall|i: int| #![trigger grid[i].len(), grid[0].len()] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()) &&\n    (forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn binomial(n: int, k: int) -> int\n    decreases n, k\n{\n    if k > n || n < 0 || k < 0 {\n        0int\n    } else if k == 0 || k == n {\n        1int\n    } else if k == 1 {\n        n\n    } else {\n        binomial(n-1, k-1) + binomial(n-1, k)\n    }\n}\n\nspec fn dp_path_count(grid: Seq<Seq<int>>) -> int\n    recommends valid_grid(grid)\n{\n    let m = grid.len();\n    let n = grid[0].len();\n    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {\n        0int\n    } else if m == 1 && n == 1 {\n        1int\n    } else if m == 1 {\n        if forall|j: int| #![trigger grid[0][j]] 0 <= j < n ==> grid[0][j] == 0 { 1int } else { 0int }\n    } else if n == 1 {\n        if forall|i: int| #![trigger grid[i][0]] 0 <= i < m ==> grid[i][0] == 0 { 1int } else { 0int }\n    } else if forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 {\n        binomial(m + n - 2, m - 1)\n    } else {\n        0int  /* placeholder for complex case */\n    }\n}", "vc-helpers": "", "vc-spec": "exec fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i8>>) -> (result: i8)\n    requires \n        valid_grid(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n    ensures \n        result >= 0,\n        obstacle_grid@[0][0] == 1 ==> result == 0,\n        obstacle_grid@[obstacle_grid@.len()-1][obstacle_grid@[0].len()-1] == 1 ==> result == 0,\n        obstacle_grid@.len() == 1 && obstacle_grid@[0].len() == 1 ==> \n            result == (if obstacle_grid@[0][0] == 0 { 1i8 } else { 0i8 }),\n        result as int == dp_path_count(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n        (forall|i: int, j: int| #![trigger obstacle_grid@[i][j]] 0 <= i < obstacle_grid@.len() && 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[i][j] == 0) ==> \n            result as int == binomial(obstacle_grid@.len() + obstacle_grid@[0].len() - 2, obstacle_grid@.len() - 1),\n        obstacle_grid@.len() == 1 ==> \n            (result > 0 <==> (forall|j: int| #![trigger obstacle_grid@[0][j]] 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[0][j] == 0)),\n        obstacle_grid@[0].len() == 1 ==> \n            (result > 0 <==> (forall|i: int| #![trigger obstacle_grid@[i][0]] 0 <= i < obstacle_grid@.len() ==> obstacle_grid@[i][0] == 0))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0463", "language": "verus", "source": "apps", "source_id": "apps_test_2632", "vc-description": "Given an m×n grid of non-negative integers, find the minimum sum path from the top-left corner \nto the bottom-right corner. You can only move right or down.\n\n/* right */\n\n/* down */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {\n    path.len() >= 1 &&\n    path[0] == (0int, 0int) &&\n    path[path.len() - 1] == (m - 1, n - 1) &&\n    (forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&\n    forall|i: int| #![trigger path[i]] 0 <= i < path.len() - 1 ==> \n        (path[i + 1].0 == path[i].0 && path[i + 1].1 == path[i].1 + 1) ||\n        (path[i + 1].0 == path[i].0 + 1 && path[i + 1].1 == path[i].1)\n}\n\nspec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int\n    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()\n    decreases path.len()\n{\n    if path.len() == 0 { \n        0 \n    } else { \n        grid[path[0].0][path[0].1] as int + path_sum(path.subrange(1, path.len() as int), grid)\n    }\n}\n\nspec fn valid_input(grid: Seq<Vec<i32>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (grid.len() > 0 ==> (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len())) &&\n    forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] >= 0\n}", "vc-helpers": "", "vc-spec": "fn min_path_sum(grid: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        valid_input(grid@),\n    ensures \n        result >= 0,\n        grid.len() == 1 && grid[0].len() == 1 ==> result == grid[0][0],", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0464", "language": "verus", "source": "apps", "source_id": "apps_test_2633", "vc-description": "Find the minimum initial health required for a character to travel from the top-left \ncorner to the bottom-right corner of an M x N grid. The character can only move right \nor down, and dies if health drops to 0 or below at any point.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {\n    dungeon.len() > 0 &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() > 0) &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() == dungeon[0].len())\n}\n\nspec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool\n    recommends valid_dungeon(dungeon)\n{\n    path.len() > 0 &&\n    path[0] == (0int, 0int) &&\n    path[path.len()-1] == (dungeon.len()-1, dungeon[0].len()-1) &&\n    (forall|i: int| 0 <= i < path.len() ==> {\n        let (r, c) = #[trigger] path[i];\n        0 <= r < dungeon.len() && 0 <= c < dungeon[0].len()\n    }) &&\n    forall|i: int| 0 <= i < path.len()-1 ==> {\n        (#[trigger] path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||\n        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)\n    }\n}\n\nspec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int\n    recommends \n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path),\n        0 <= step < path.len()\n    decreases step when step >= 0\n{\n    if step == 0 {\n        let (r, c) = path[0];\n        initial_health + dungeon[r][c]\n    } else {\n        let (r, c) = path[step];\n        health_at_step(dungeon, path, (step-1) as int, initial_health) + dungeon[r][c]\n    }\n}\n\nspec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool\n    recommends\n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path)\n{\n    forall|i: int| 0 <= i < path.len() ==> \n        #[trigger] health_at_step(dungeon, path, i, initial_health) > 0\n}", "vc-helpers": "", "vc-spec": "fn calculate_minimum_hp(dungeon: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures result >= 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0466", "language": "verus", "source": "apps", "source_id": "apps_test_2659", "vc-description": "Given S(n) as the sum of digits in decimal notation of integer n, an integer n is called a \"Snuke number\" \nif for all positive integers m > n, the inequality n/S(n) ≤ m/S(m) holds.\nGiven an integer K, find the K smallest Snuke numbers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_of_digits(n: int) -> int\n  recommends n >= 0\n  decreases n\n{\n  if n < 10 { n }\n  else { (n % 10) + sum_of_digits(n / 10) }\n}\n\nspec fn valid_output(result: Seq<int>, k: int) -> bool {\n  &&& result.len() == k\n  &&& (forall|i: int| 0 <= i < k ==> result[i] > 0)\n  &&& (forall|i: int| #![trigger result.index(i)] 0 <= i < k - 1 ==> result.index(i) < result.index(i + 1))\n  &&& (k >= 1 ==> result[0] == 1)\n  &&& (k >= 2 ==> result[1] == 2)\n  &&& (k >= 3 ==> result[2] == 3)\n  &&& (k >= 4 ==> result[3] == 4)\n  &&& (k >= 5 ==> result[4] == 5)\n  &&& (k >= 6 ==> result[5] == 6)\n  &&& (k >= 7 ==> result[6] == 7)\n  &&& (k >= 8 ==> result[7] == 8)\n  &&& (k >= 9 ==> result[8] == 9)\n  &&& (k >= 10 ==> result[9] == 19)\n}", "vc-helpers": "", "vc-spec": "fn solve(k: i8) -> (result: Vec<i8>)\n  requires k as int >= 1\n  ensures valid_output(result@.map(|i: int, x: i8| x as int), k as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0467", "language": "verus", "source": "apps", "source_id": "apps_test_3805", "vc-description": "Two wires run from left to right between a wall and device. Given a string of '+' and '-' \nrepresenting wire crossings, determine if wires can be untangled by free movement without\nunplugging. Uses stack algorithm where same adjacent characters cancel out.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn extract_first_line(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        Seq::empty()\n    } else if input[0] == '\\n' {\n        Seq::empty()\n    } else {\n        seq![input[0]] + extract_first_line(input.subrange(1, input.len() as int))\n    }\n}\n\nspec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        stack\n    } else {\n        let c = input[0];\n        let new_stack = if stack.len() > 0 && stack[stack.len() - 1] == c {\n            stack.subrange(0, stack.len() - 1)\n        } else {\n            stack.push(c)\n        };\n        process_string(input.subrange(1, input.len() as int), new_stack)\n    }\n}\n\nspec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool\n{\n    let stack = process_string(input, Seq::empty());\n    stack.len() == 0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    ensures result@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0468", "language": "verus", "source": "apps", "source_id": "apps_test_4088", "vc-description": "Given a string s of lowercase letters and an array b, find a string t such that:\n1. t is formed by removing some characters from s and rearranging the remaining characters\n2. For each position i in t, b[i] equals the sum of distances |i-j| to all positions j where t[j] > t[i] lexicographically\nProcess multiple test cases from stdin input and return formatted results", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* TODO: Implement full validation logic for:\n     * - Lines parsing and validation\n     * - Test case count validation  \n     * - String and integer array parsing\n     * - Character and bounds validation\n     */\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> output.len() > 0\n    /* TODO: Implement validation for:\n     * - Output lines matching test cases\n     * - Correct string lengths\n     * - Valid lowercase characters\n     */\n}\n\nspec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement constraint validation for:\n     * - Distance sum calculations\n     * - Character ordering requirements\n     */\n}\n\nspec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement character count preservation:\n     * - Character frequency validation\n     * - Subset usage validation\n     */\n}\n\nspec fn contains_newline_terminated_results(output: Seq<char>) -> bool {\n    output.len() > 0 ==> output[output.len() - 1] == '\\n'\n}\n\nspec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {\n    0\n    /* TODO: Implement distance sum calculation:\n     * - Compare characters lexicographically\n     * - Calculate absolute differences\n     * - Sum all applicable distances\n     */\n}\n\nspec fn abs_diff(i: int, j: int) -> int {\n    if i >= j { i - j } else { j - i }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: String) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        valid_output_format(result@, stdin_input@),\n        output_satisfies_constraints(result@, stdin_input@),\n        preserves_character_usage(result@, stdin_input@),\n        result@.len() > 0 ==> contains_newline_terminated_results(result@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0469", "language": "verus", "source": "apps", "source_id": "apps_test_4111", "vc-description": "Given n candies with weights, determine how many candies can be given to dad\nsuch that when the remaining n-1 candies are eaten in numerical order (one per day),\nthe sum of weights eaten on even-numbered days equals the sum on odd-numbered days.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < n ==> arr[i] >= 1\n}\n\nspec fn sum_even_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 0 { arr[start] } else { 0 };\n        contribution + sum_even_indices(arr, start + 1)\n    }\n}\n\nspec fn sum_odd_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 1 { arr[start] } else { 0 };\n        contribution + sum_odd_indices(arr, start + 1)\n    }\n}\n\nspec fn count_balanced_removals(arr: Seq<int>) -> int {\n    let n = arr.len();\n    if n == 0 {\n        0\n    } else {\n        count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)\n    }\n}\n\nspec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int\n    decreases arr.len() - i when 0 <= i <= arr.len()\n{\n    if i == arr.len() {\n        0\n    } else {\n        let contribution: int = \n            if i % 2 == 0 {\n                let val1 = temp1 + count2 - temp2;\n                let val2 = temp2 + count1 - temp1 - arr[i];\n                if val1 == val2 { 1 } else { 0 }\n            } else {\n                let val1 = temp1 + count2 - temp2 - arr[i];\n                let val2 = temp2 + count1 - temp1;\n                if val1 == val2 { 1 } else { 0 }\n            };\n        let new_temp1 = if i % 2 == 0 { temp1 + arr[i] } else { temp1 };\n        let new_temp2 = if i % 2 == 1 { temp2 + arr[i] } else { temp2 };\n        contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, arr: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, arr@.map(|i: int, x: i8| x as int)),\n    ensures \n        0 <= result as int <= n as int,\n        result as int == count_balanced_removals(arr@.map(|i: int, x: i8| x as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0470", "language": "verus", "source": "apps", "source_id": "apps_test_4115", "vc-description": "Find the minimum number of character changes needed to make a string a palindrome.\nIn each operation, you can change any character to any other lowercase letter.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1\n}\n\nspec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int\n    decreases limit\n{\n    if limit <= 0 || s.len() < 1 { \n        0 \n    } else {\n        let n = s.len() as int - 1;\n        let mismatch: int = if limit > 0 && limit <= s.len() && s[limit-1] != s[n - (limit-1)] { 1 } else { 0 };\n        count_mismatches_up_to(s, limit-1) + mismatch\n    }\n}\n\nspec fn count_mismatches(s: Seq<char>) -> int {\n    if s.len() >= 1 {\n        count_mismatches_up_to(s, s.len() as int)\n    } else {\n        0\n    }\n}\n\nspec fn valid_result(s: Seq<char>, result: int) -> bool {\n    if valid_input(s) {\n        result >= 0 && result <= s.len() / 2 && result == (count_mismatches(s) / 2)\n    } else {\n        false\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures valid_result(s@, result as int)", "vc-code": "{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0471", "language": "verus", "source": "apps", "source_id": "apps_test_4142", "vc-description": "Given a string containing only 'L', 'R', 'U', 'D' characters, determine if it is \"easily playable\".\nA string is easily playable if odd positions (1-indexed) contain no 'L' and even positions contain no 'R'.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'\n}\n\nspec fn easily_playable(s: Seq<char>) -> bool {\n    (forall|i: int| 0 <= i < s.len() && i % 2 == 0 ==> s[i] != 'L') &&\n    (forall|i: int| 0 <= i < s.len() && i % 2 == 1 ==> s[i] != 'R')\n}", "vc-helpers": "", "vc-spec": "fn solve(s: String) -> (result: String)\n    requires valid_input(s@)\n    ensures result@ == seq!['Y', 'e', 's'] <==> easily_playable(s@)", "vc-code": "{\n    assume(false);\n    \"No\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0472", "language": "verus", "source": "apps", "source_id": "apps_test_4143", "vc-description": "Given N people starting at City 1, find the minimum time for all people to reach City 6\nthrough a sequential 5-segment transportation system with different capacities per segment.\nEach transport departs at integer times with specified capacity. Transfer time is negligible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n}\n\nspec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int\n    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n{\n    let temp1 = if a <= b { a } else { b };\n    let temp2 = if temp1 <= c { temp1 } else { c };\n    let temp3 = if temp2 <= d { temp2 } else { d };\n    if temp3 <= e { temp3 } else { e }\n}\n\nspec fn ceil_div(a: int, b: int) -> int\n    recommends a >= 0 && b >= 1\n{\n    (a + b - 1) / b\n}\n\nspec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool\n    recommends valid_input(n, a, b, c, d, e)\n{\n    let min_cap = min_capacity(a, b, c, d, e);\n    let groups = ceil_div(n, min_cap);\n    result == 4 + groups\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8, c: i8, d: i8, e: i8) -> (result: i8)\n    requires \n        valid_input(n as int, a as int, b as int, c as int, d as int, e as int)\n    ensures \n        correct_result(n as int, a as int, b as int, c as int, d as int, e as int, result as int) &&\n        result >= 5", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0475", "language": "verus", "source": "apps", "source_id": "apps_test_4159", "vc-description": "Given three integers A, B, and K, where Takahashi has A cookies and Aoki has B cookies initially.\nTakahashi performs exactly K actions, where each action follows this priority:\n1. If Takahashi has cookies, he eats one of his own cookies\n2. Otherwise, if Aoki has cookies, Takahashi eats one of Aoki's cookies  \n3. Otherwise, do nothing\nDetermine how many cookies Takahashi and Aoki have after all K actions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, k: int) -> bool {\n    a >= 0 && b >= 0 && k >= 0\n}\n\nspec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { a - k }\n    else { 0 }\n}\n\nspec fn expected_aoki_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { b }\n    else if k - a < b { b - (k - a) }\n    else { 0 }\n}\n\nspec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool\n    recommends valid_input(a, b, k)\n{\n    takahashi == expected_takahashi_cookies(a, b, k) &&\n    aoki == expected_aoki_cookies(a, b, k) &&\n    takahashi >= 0 && aoki >= 0\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, k: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, k as int)\n    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0476", "language": "verus", "source": "apps", "source_id": "apps_test_4160", "vc-description": "Find the minimum number of years needed for a bank balance to reach a target amount.\nStarting with 100 yen, the balance grows each year by adding 1% interest (rounded down).\nGiven a target amount X, determine how many years it takes for the balance to reach X yen or above.\nThe yearly calculation is: new_balance = current_balance + floor(current_balance / 100)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn calculate_deposit(initial: int, years: int) -> int\n    decreases years\n{\n    if years <= 0 { \n        initial \n    } else { \n        let prev_deposit = calculate_deposit(initial, years - 1);\n        prev_deposit + prev_deposit / 100\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8) -> (years: i8)\n    requires x >= 101\n    ensures \n        years >= 0 &&\n        calculate_deposit(100, years as int) >= x as int &&\n        (years == 0 || calculate_deposit(100, (years - 1) as int) < x as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0478", "language": "verus", "source": "apps", "source_id": "apps_test_4167", "vc-description": "Count ordered triples (a,b,c) where 1 ≤ a,b,c ≤ N and a+b, b+c, c+a are all divisible by K", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool\n    recommends k >= 1\n{\n    1 <= a <= n && 1 <= b <= n && 1 <= c <= n &&\n    (a + b) % k == 0 && (b + c) % k == 0 && (c + a) % k == 0\n}\n\nspec fn count_valid_triples(n: int, k: int) -> int\n    recommends n >= 1 && k >= 1\n{\n    if k % 2 == 1 {\n        let cnt1 = n / k;\n        cnt1 * cnt1 * cnt1\n    } else {\n        let cnt1 = n / k;\n        let cnt2 = n / k + (if n % k >= k / 2 { 1int } else { 0int });\n        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1\n}\n\nspec fn count_divisible_by_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k }\n}\n\nspec fn count_with_remainder_half_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k + (if n % k >= k / 2 { 1int } else { 0int }) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= 0,\n        result as int == count_valid_triples(n as int, k as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0479", "language": "verus", "source": "apps", "source_id": "apps_test_4173", "vc-description": "Find the minimum cost to purchase exactly n liters of water using 1-liter bottles \n(costing a burles each) and 2-liter bottles (costing b burles each), with infinite \nsupply of both types available. Process multiple queries efficiently.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_query(query: (int, int, int)) -> bool {\n    query.0 > 0 && query.1 > 0 && query.2 > 0\n}\n\nspec fn min_cost_for_query(n: int, a: int, b: int) -> int\n    recommends n > 0 && a > 0 && b > 0\n{\n    if n % 2 == 0 {\n        if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n    } else {\n        if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(queries: Vec<(i8, i8, i8)>) -> (results: Vec<i8>)\n    requires \n        forall|i: int| 0 <= i < queries@.len() ==> #[trigger] valid_query((queries@[i].0 as int, queries@[i].1 as int, queries@[i].2 as int))\n    ensures \n        results@.len() == queries@.len() &&\n        forall|i: int| 0 <= i < queries@.len() ==> {\n            let n = queries@[i].0 as int;\n            let a = queries@[i].1 as int;\n            let b = queries@[i].2 as int;\n            #[trigger] results@[i] as int == (if n % 2 == 0 {\n                if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n            } else {\n                if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n            })\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0481", "language": "verus", "source": "apps", "source_id": "apps_test_4176", "vc-description": "Given two integers A and B representing possible numbers of guests at a party,\nfind the minimum number of snack pieces that can be evenly distributed among\nthe guests in both scenarios (A guests or B guests). Each piece must go to\nexactly one guest, and each guest must receive the same number of pieces\nwithin each scenario. This is equivalent to finding the LCM of A and B.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|space_index: int| 0 <= space_index < input.len() && \n        input[space_index] == ' ' &&\n    forall|i: int| 0 <= i < input.len() ==> \n        (input[i] == ' ' || ('0' <= input[i] <= '9'))\n}\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n    if valid_input(s) { (1, 1) } else { (1, 1) }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 { (a * b) / spec_gcd(a, b) } else { 1 }\n}\n\nspec fn spec_gcd(a: int, b: int) -> int\n    decreases b\n{\n    if a > 0 && b > 0 {\n        if b == 0 { a } else { spec_gcd(b, a % b) }\n    } else { 1 }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    forall|i: int| 0 <= i < output.len() ==> #[trigger] output[i] >= '0' && #[trigger] output[i] <= '9'\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures ({\n        let nums = parse_two_ints(input@);\n        let a = nums.0;\n        let b = nums.1;\n        a > 0 && b > 0\n    }) && valid_output(result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0482", "language": "verus", "source": "apps", "source_id": "apps_test_4177", "vc-description": "Given a string S consisting of lowercase English letters, replace every character with 'x' and output the result.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> 'a' <= s[i] && s[i] <= 'z'\n}\n\nspec fn valid_output(s: Seq<char>, result: Seq<char>) -> bool {\n    result.len() == s.len() && forall|i: int| 0 <= i < result.len() ==> result[i] == 'x'\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures valid_output(s@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0483", "language": "verus", "source": "apps", "source_id": "apps_test_4178", "vc-description": "Given N squares with heights, determine if it's possible to make heights non-decreasing\nfrom left to right. For each square, you can decrease its height by 1 or leave unchanged.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn max_height_up_to(heights: Seq<int>, index: int) -> int\n    decreases index + 1\n{\n    if heights.len() > 0 && -1 <= index < heights.len() {\n        if index < 0 {\n            0\n        } else if index == 0 {\n            heights[0]\n        } else if heights[index] > max_height_up_to(heights, index - 1) {\n            heights[index]\n        } else {\n            max_height_up_to(heights, index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n >= 1 && heights.len() == n && (forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1)\n}\n\nspec fn can_make_non_decreasing(heights: Seq<int>) -> bool {\n    if heights.len() > 0 {\n        forall|i: int| 0 <= i < heights.len() ==> heights[i] >= max_height_up_to(heights, i) - 1\n    } else {\n        true\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, heights: Vec<i8>) -> (result: String)\n    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))\n    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0484", "language": "verus", "source": "apps", "source_id": "apps_test_4180", "vc-description": "Given a cost N yen, calculate the change received when paying with the minimum number of 1000-yen bills.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 10000\n}\n\nspec fn valid_change(change: int) -> bool {\n    0 <= change <= 999\n}\n\nspec fn correct_change(n: int) -> int\n    recommends valid_input(n)\n{\n    (1000 - n % 1000) % 1000\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (change: i8)\n    requires valid_input(n as int)\n    ensures \n        valid_change(change as int) &&\n        change as int == correct_change(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0485", "language": "verus", "source": "apps", "source_id": "apps_test_4182", "vc-description": "Two empires A and B have capitals at coordinates X and Y respectively.\nEmpire A wants to control cities at coordinates x₁, x₂, ..., xₙ, and \nEmpire B wants to control cities at coordinates y₁, y₂, ..., yₘ.\nThey reach agreement if there exists integer Z such that X < Z ≤ Y,\nall xᵢ < Z, and all yᵢ ≥ Z. Otherwise war breaks out.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, x: int, y: int, xx: Seq<int>, yy: Seq<int>) -> bool {\n    xx.len() == n && yy.len() == m && n >= 1 && m >= 1 && x < y\n}\n\nspec fn agreement_possible(n: int, m: int, x: int, y: int, xx: Seq<int>, yy: Seq<int>) -> bool \n    recommends valid_input(n, m, x, y, xx, yy)\n{\n    let combined_x = xx.push(x);\n    let combined_y = yy.push(y);\n    exists|max_val: int| combined_x.contains(max_val) && \n                         (forall|v: int| combined_x.contains(v) ==> v <= max_val) &&\n    exists|min_val: int| combined_y.contains(min_val) && \n                         (forall|v: int| combined_y.contains(v) ==> v >= min_val) &&\n                         max_val < min_val\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, x: i8, y: i8, xx: Vec<i8>, yy: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, m as int, x as int, y as int, xx@.map(|_i: int, v: i8| v as int), yy@.map(|_i: int, v: i8| v as int)),\n    ensures \n        result@ == seq!['N','o',' ','W','a','r'] || result@ == seq!['W','a','r'],\n        (result@ == seq!['N','o',' ','W','a','r']) == agreement_possible(n as int, m as int, x as int, y as int, xx@.map(|_i: int, v: i8| v as int), yy@.map(|_i: int, v: i8| v as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0486", "language": "verus", "source": "apps", "source_id": "apps_test_4183", "vc-description": "Given N clocks where clock i completes one rotation in T_i seconds,\nfind the minimum positive time when all clocks return to their starting position.\nThis is equivalent to finding the LCM of all rotation periods.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn gcd(a: int, b: int) -> int\n    decreases b when b >= 0\n{\n    if a > 0 && b >= 0 {\n        if b == 0 { a } else { gcd(b, a % b) }\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 {\n        (a * b) / gcd(a, b)\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() > 0 {\n        if nums.len() == 1 { \n            nums[0] \n        } else { \n            lcm(nums[0], lcm_seq(nums.skip(1)))\n        }\n    } else {\n        1  /* default for empty sequence */\n    }\n}\n\nspec fn valid_input(periods: Seq<int>) -> bool {\n    periods.len() > 0 && periods.len() <= 100 &&\n    forall|i: int| 0 <= i < periods.len() ==> periods[i] > 0\n}\n\nspec fn correct_result(periods: Seq<int>, result: int) -> bool {\n    valid_input(periods) ==> result == lcm_seq(periods)\n}", "vc-helpers": "", "vc-spec": "fn find_minimum_time(periods: Vec<i8>) -> (result: i8)\n    requires valid_input(periods@.map(|i: int, v: i8| v as int))\n    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0487", "language": "verus", "source": "apps", "source_id": "apps_test_4188", "vc-description": "Given 16 facts with numerical claims, determine whether each fact is true (1) or false (0) in reality.\nEach fact is numbered from 1 to 16 based on order of appearance. Input n specifies which fact to check.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 16\n}\n\nspec fn fact_truth_values() -> Seq<int> {\n    seq![1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0]\n}\n\nspec fn valid_output(result: int) -> bool {\n    result == 0 || result == 1\n}\n\nspec fn expected_output(n: int) -> int\n    recommends valid_input(n)\n{\n    fact_truth_values()[n - 1]\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int)\n    ensures \n        valid_output(result as int),\n        result as int == expected_output(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0488", "language": "verus", "source": "apps", "source_id": "apps_test_4192", "vc-description": "Determine if Takahashi can travel D meters in T minutes at a speed of S meters per minute.\nPrint \"Yes\" if he can travel the distance in the given time, otherwise print \"No\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(d: int, t: int, s: int) -> bool {\n    1 <= d <= 10000 && 1 <= t <= 10000 && 1 <= s <= 10000\n}\n\nspec fn can_travel(d: int, t: int, s: int) -> bool {\n    d <= t * s\n}", "vc-helpers": "", "vc-spec": "fn solve(d: i8, t: i8, s: i8) -> (result: &'static str)\n    requires \n        valid_input(d as int, t as int, s as int),\n    ensures \n        can_travel(d as int, t as int, s as int) ==> result == \"Yes\",\n        !can_travel(d as int, t as int, s as int) ==> result == \"No\",", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0489", "language": "verus", "source": "apps", "source_id": "apps_test_4194", "vc-description": "Given N vacation days and M assignments where assignment i takes A_i days to complete,\nfind the maximum number of days available for hanging out. Each assignment must be\ncompleted on consecutive days, and no hanging out is allowed on assignment days.\nIf all assignments cannot be completed within the vacation period, return -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 0 && m >= 0 && m == a.len()\n}\n\nspec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {\n    sum_seq(a) <= n\n}\n\nspec fn total_assignment_days(a: Seq<int>) -> int {\n    sum_seq(a)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else { \n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a@.map(|i, x: i8| x as int))\n    ensures \n        m as int == 0 ==> result as int == n as int,\n        m as int > 0 && can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == n as int - total_assignment_days(a@.map(|i, x: i8| x as int)),\n        m as int > 0 && !can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == -1,\n        result as int >= -1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0491", "language": "verus", "source": "apps", "source_id": "apps_test_4206", "vc-description": "Given a string of digits representing a positive integer, find the maximum number of valid numbers \ndivisible by 3 that can be obtained by making vertical cuts between adjacent digits.\nNumbers cannot have leading zeros (except single digit \"0\"), and a number is divisible by 3 \nif the sum of its digits is divisible by 3.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() - 1] == '\\n' &&\n    input.len() >= 2 &&\n    (forall|i: int| 0 <= i < input.len() - 1 ==> ('0' <= input[i] && input[i] <= '9')) &&\n    (input[0] != '0' || input.len() == 2)\n}\n\nspec fn max_divisible_by_3_segments(s: Seq<char>) -> int {\n    if s.len() <= 0 {\n        0\n    } else if forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9') {\n        /* Placeholder for max segments computation helper call */\n        0\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "exec fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0492", "language": "verus", "source": "apps", "source_id": "apps_test_4211", "vc-description": "Given an integer sequence B of length N-1, find the maximum possible sum of an integer sequence A of length N \nthat satisfies the constraint: B_i >= max(A_i, A_{i+1}) for all valid i.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, b: Seq<int>) -> bool {\n  n >= 2 && b.len() == n - 1 && forall|i: int| 0 <= i < b.len() ==> b[i] >= 0\n}\n\nspec fn sum_mins(b: Seq<int>, len: int) -> int\n  decreases len\n{\n  if len <= 0 {\n    0\n  } else {\n    b[len - 1] + sum_mins(b, len - 1)\n  }\n}\n\nspec fn correct_result(n: int, b: Seq<int>, result: int) -> bool {\n  valid_input(n, b) ==> {\n    if n == 2 {\n      result == 2 * b[0]\n    } else {\n      result == b[0] + b[n-2] + sum_mins(b, n-2)\n    }\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, b: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, b@.map(|i: int, x: i8| x as int))\n  ensures correct_result(n as int, b@.map(|i: int, x: i8| x as int), result as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0493", "language": "verus", "source": "apps", "source_id": "apps_test_4215", "vc-description": "Given a window of width A and two curtains each of horizontal length B,\ndetermine the minimum total horizontal length of the uncovered part when \nthe curtains are optimally positioned to minimize uncovered area.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100\n}\n\nspec fn uncovered_length(a: int, b: int) -> int {\n    if a - 2 * b > 0 { a - 2 * b } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int)\n    ensures \n        result >= 0,\n        result as int == uncovered_length(a as int, b as int),\n        result as int == if a as int > 2 * (b as int) { a as int - 2 * (b as int) } else { 0 }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0494", "language": "verus", "source": "apps", "source_id": "apps_test_4216", "vc-description": "Given a positive integer N, find the minimum value of F(A,B) over all pairs of positive integers (A,B) \nsuch that A × B = N, where F(A,B) is defined as the maximum of the number of digits in A and the number of digits in B.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn num_digits(n: int) -> int\n  recommends n >= 1\n  decreases n\n{\n  if n < 10 { 1 } else { 1 + num_digits(n / 10) }\n}\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn f(a: int, b: int) -> int\n  recommends a >= 1 && b >= 1\n{\n  let digits_a = num_digits(a);\n  let digits_b = num_digits(b);\n  if digits_a > digits_b { digits_a } else { digits_b }\n}\n\nspec fn is_factor_pair(a: int, b: int, n: int) -> bool {\n  a >= 1 && b >= 1 && a * b == n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n  requires \n    valid_input(n as int)\n  ensures \n    result >= 1,\n    exists|a: int, b: int| is_factor_pair(a, b, n as int) && result as int == f(a, b),\n    forall|a: int, b: int| is_factor_pair(a, b, n as int) ==> result as int <= f(a, b),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0495", "language": "verus", "source": "apps", "source_id": "apps_test_4220", "vc-description": "Given an integer K and a string S of lowercase English letters, output S unchanged if its length is at most K.\nOtherwise, output the first K characters of S followed by \"...\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    (exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n') &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        is_valid_positive_integer(k_str)\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        let k = string_to_int(k_str);\n        1 <= k <= 100\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n        let s = if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest };\n        1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n    })\n}\n\nspec fn extract_k(stdin_input: Seq<char>) -> int\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let k_str = stdin_input.subrange(0, newline_pos as int);\n    string_to_int(k_str)\n}\n\nspec fn extract_s(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n    if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest }\n}\n\nspec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(stdin_input)\n{\n    let k = extract_k(stdin_input);\n    let s = extract_s(stdin_input);\n    k >= 1 && k <= 100 &&\n    s.len() >= 1 && s.len() <= 100 &&\n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z') &&\n    (s.len() <= k ==> result == s.add(seq!['\\n'])) &&\n    (s.len() > k ==> result == s.subrange(0, k).add(seq!['.', '.', '.']).add(seq!['\\n']))\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> nat\n    recommends start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { \n        s.len() \n    } else if s[start as int] == '\\n' { \n        start \n    } else { \n        find_newline(s, start + 1) \n    }\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9') && \n    s != seq!['0']\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_positive_integer(s)\n{\n    string_to_int_helper(s, 0, 0)\n}\n\nspec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int\n    recommends\n        pos <= s.len(),\n        acc >= 0,\n        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',\n        is_valid_positive_integer(s)\n    decreases s.len() - pos\n{\n    if pos >= s.len() { \n        if acc == 0 { 1 } else { acc }\n    } else if s[pos as int] >= '0' && s[pos as int] <= '9' {\n        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos as int] as int - '0' as int))\n    } else {\n        if acc == 0 { 1 } else { acc }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0496", "language": "verus", "source": "apps", "source_id": "apps_test_4221", "vc-description": "Convert a singular noun string containing only lowercase English letters to plural form.\nIf the string does not end with 's', append 's'.\nIf the string ends with 's', append 'es'.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> 'a' <= s[i] && s[i] <= 'z'\n}\n\nspec fn correct_plural(s: Seq<char>, result: Seq<char>) -> bool {\n    if s.len() > 0 && s[s.len() - 1] == 's' {\n        result == s + seq!['e', 's']\n    } else {\n        result == s + seq!['s']\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: &Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures correct_plural(s@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0497", "language": "verus", "source": "apps", "source_id": "apps_test_4224", "vc-description": "Given an array of positive integers, find the maximum number of operations possible where each operation\nallows dividing elements by 2 (if even) or multiplying by 3, with at least one division by 2 required per operation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > 0\n}\n\nspec fn count_factors_of_two(n: int) -> int\n    decreases n when n > 0\n{\n    if n > 0 && n % 2 == 0 { 1 + count_factors_of_two(n / 2) }\n    else { 0 }\n}\n\nspec fn sum_factors(a: Seq<int>, i: int) -> int\n    decreases a.len() - i when 0 <= i <= a.len()\n{\n    if 0 <= i < a.len() && (forall|j: int| 0 <= j < a.len() ==> a[j] > 0) {\n        count_factors_of_two(a[i]) + sum_factors(a, i + 1)\n    } else if i == a.len() {\n        0\n    } else {\n        0\n    }\n}\n\nspec fn max_operations(a: Seq<int>) -> int {\n    if valid_input(a) { sum_factors(a, 0) } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result >= 0,\n        result as int == max_operations(a@.map(|i, x| x as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0498", "language": "verus", "source": "apps", "source_id": "apps_test_4225", "vc-description": "Given A cards with value 1, B cards with value 0, and C cards with value -1,\nfind the maximum possible sum when picking exactly K cards.\nThe optimal strategy is to pick cards with highest values first.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, k: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && k >= 1 && k <= a + b + c\n}\n\nspec fn max_sum(a: int, b: int, c: int, k: int) -> int\n    recommends valid_input(a, b, c, k)\n{\n    if k <= a + b {\n        if k <= a { k } else { a }\n    } else {\n        a - (k - a - b)\n    }\n}\n\nspec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {\n    exists|parts: Seq<Seq<char>>| parts.len() >= 4 && \n        parts == split_string_pure(input) &&\n        a == string_to_int_pure(parts[0]) &&\n        b == string_to_int_pure(parts[1]) &&\n        c == string_to_int_pure(parts[2]) &&\n        k == string_to_int_pure(parts[3]) &&\n        valid_input(a, b, c, k)\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char>\n    recommends n >= -2000000000 && n <= 2000000000\n{\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'] + int_to_string_pure_helper(-n) }\n    else { int_to_string_pure_helper(n) }\n}\n\nspec fn int_to_string_pure_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 { seq![('0' as u8 + n as u8) as char] }\n    else { int_to_string_pure_helper(n / 10) + seq![('0' as u8 + (n % 10) as u8) as char] }\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { seq![] }\n    else { split_string_helper(s, 0, seq![], seq![]) }\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if current.len() > 0 { parts + seq![current] } else { parts }\n    } else if s[i] == ' ' || s[i] == '\\n' {\n        if current.len() > 0 { \n            split_string_helper(s, i+1, seq![], parts + seq![current])\n        } else { \n            split_string_helper(s, i+1, seq![], parts)\n        }\n    } else {\n        split_string_helper(s, i+1, current + seq![s[i]], parts)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s[0] == '-' { -string_to_int_helper(s, 1) }\n    else { string_to_int_helper(s, 0) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, start: int) -> int\n    recommends 0 <= start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { 0 }\n    else if '0' <= s[start] <= '9' {\n        (s[start] as u8 - '0' as u8) as int + 10 * string_to_int_helper(s, start + 1)\n    } else {\n        string_to_int_helper(s, start + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input@.len() > 0\n    ensures \n        result@.len() > 0 &&\n        result@[result@.len() as int - 1] == '\\n' &&\n        ((exists|a: int, b: int, c: int, k: int| \n            parsed_values(input@, a, b, c, k) &&\n            ({\n                let max_sum_val = max_sum(a, b, c, k);\n                max_sum_val >= -2000000000 && max_sum_val <= 2000000000 &&\n                result@ == int_to_string_pure(max_sum_val) + seq!['\\n']\n            })) ||\n        (forall|a: int, b: int, c: int, k: int| !parsed_values(input@, a, b, c, k) ==> result@ == seq!['0', '\\n']))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0500", "language": "verus", "source": "apps", "source_id": "apps_test_4231", "vc-description": "Given an H×W grid of white cells, choose h rows and w columns to paint black.\nAll cells that are either in a chosen row OR in a chosen column will be painted black.\nDetermine how many white cells remain after painting.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(h: int, w: int, h_selected: int, w_selected: int) -> bool {\n    1 <= h <= 20 && 1 <= w <= 20 && 1 <= h_selected <= h && 1 <= w_selected <= w\n}\n\nspec fn white_cells_remaining(h: int, w: int, h_selected: int, w_selected: int) -> int\n    recommends valid_input(h, w, h_selected, w_selected)\n{\n    (h - h_selected) * (w - w_selected)\n}", "vc-helpers": "", "vc-spec": "fn solve(h: i8, w: i8, h_selected: i8, w_selected: i8) -> (result: i8)\n    requires \n        valid_input(h as int, w as int, h_selected as int, w_selected as int),\n    ensures \n        result as int == white_cells_remaining(h as int, w as int, h_selected as int, w_selected as int),\n        result >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0502", "language": "verus", "source": "apps", "source_id": "apps_test_4234", "vc-description": "Given a string of lowercase letters, delete the minimum number of characters to make it \"good\".\nA string is \"good\" if its length is even and each character at odd positions (1st, 3rd, 5th, ...)\ndiffers from the character at the next even position (2nd, 4th, 6th, ...).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n == s.len() && n >= 0\n}\n\nspec fn is_good_string(s: Seq<char>) -> bool {\n    s.len() % 2 == 0 && forall|i: int| 0 <= i < s.len() / 2 ==> #[trigger] s[2*i] != #[trigger] s[2*i+1]\n}", "vc-helpers": "", "vc-spec": "fn solve(n: usize, s: Vec<char>) -> (result: (usize, Vec<char>))\n    requires \n        valid_input(n as int, s@),\n    ensures \n        result.0 >= 0,\n        result.0 == s@.len() - result.1@.len(),\n        is_good_string(result.1@),\n        result.0 + result.1@.len() == s@.len(),", "vc-code": "{\n    assume(false);\n    (0, Vec::new())\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0503", "language": "verus", "source": "apps", "source_id": "apps_test_4237", "vc-description": "Given four integers A, B, C, and D, find the count of integers in the range [A, B] (inclusive) \nthat are divisible by neither C nor D.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n  a >= 1 && b >= a && c >= 1 && d >= 1\n}\n\nspec fn not_divisible_by_either(x: int, c: int, d: int) -> bool\n  recommends c > 0 && d > 0\n{\n  x % c != 0 && x % d != 0\n}\n\nspec fn count_not_divisible(a: int, b: int, c: int, d: int) -> int\n  recommends valid_input(a, b, c, d)\n{\n  /* Count of integers in range [a, b] not divisible by either c or d */\n  (Set::new(|x: int| a <= x <= b && not_divisible_by_either(x, c, d))).len() as int\n}\nspec fn f(n: int, c: int, d: int) -> int {\n  /* Helper function f referenced in postcondition */\n  0 as int  /* Placeholder specification */\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n  requires\n      valid_input(a as int, b as int, c as int, d as int),\n  ensures\n      result as int >= 0,\n      result as int == f(b as int, c as int, d as int) - f((a as int) - 1, c as int, d as int),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0504", "language": "verus", "source": "apps", "source_id": "apps_test_4242", "vc-description": "Given positive integers A and B, find the K-th largest positive integer that divides both A and B.\nThe K-th largest common divisor is guaranteed to exist for the given inputs.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn common_divisors(a: int, b: int) -> Set<int>\n{\n  Set::new(|d: int| 1 <= d <= a && a % d == 0 && b % d == 0)\n}\n\nspec fn valid_input(a: int, b: int, k: int) -> bool\n{\n  a > 0 && b > 0 && k >= 1 && common_divisors(a, b).len() >= k\n}\n\nspec fn is_kth_largest_common_divisor(a: int, b: int, k: int, result: int) -> bool\n{\n  valid_input(a, b, k) ==> (\n    result > 0 &&\n    a % result == 0 && b % result == 0 &&\n    common_divisors(a, b).contains(result) &&\n    Set::new(|d: int| common_divisors(a, b).contains(d) && d > result).len() == (k - 1)\n  )\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, k: i8) -> (result: i8)\n  requires valid_input(a as int, b as int, k as int)\n  ensures is_kth_largest_common_divisor(a as int, b as int, k as int, result as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0505", "language": "verus", "source": "apps", "source_id": "apps_test_4245", "vc-description": "Given a single socket that can be extended using power strips, find the minimum number of power strips needed to have at least B empty sockets. Each power strip has A sockets and when plugged into an empty socket, it replaces that 1 socket with A sockets (net gain of A-1 sockets).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 1 && b >= 0\n}\n\nspec fn sockets_after_strips(strips: int, a: int) -> int\n    recommends a > 1 && strips >= 0\n{\n    1 + strips * (a - 1)\n}\n\nspec fn ceiling_division(x: int, y: int) -> int\n    recommends y > 0\n{\n    if x % y == 0 {\n        x / y\n    } else if x >= 0 {\n        x / y + 1\n    } else {\n        x / y\n    }\n}\n\nspec fn min_strips_needed(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n    if b <= 1 {\n        0\n    } else {\n        ceiling_division(b - 1, a - 1)\n    }\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n    recommends valid_input(a, b)\n{\n    result >= 0 &&\n    sockets_after_strips(result, a) >= b &&\n    (result == 0 || sockets_after_strips(result - 1, a) < b)\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures correct_result(a as int, b as int, result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0506", "language": "verus", "source": "apps", "source_id": "apps_test_4246", "vc-description": "Given two strings S and T, each of length 3, representing weather forecasts and actual weather \nrespectively for 3 consecutive days, count how many days the forecast was correct.\nEach character represents weather: 'S' = sunny, 'C' = cloudy, 'R' = rainy.\nInput: Two lines with strings of length 3 containing only 'S', 'C', 'R' characters.\nOutput: Integer representing the number of days where forecast matched actual weather.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['S', 'C', 'R'], seq!['S', 'C', 'R']]\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else { seq!['3'] }\n}\nspec fn is_valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    lines.len() >= 2 && lines[0].len() == 3 && lines[1].len() == 3\n}\n\nspec fn count_matches_from_input(input: Seq<char>) -> int\n    recommends input.len() > 0 && is_valid_input(input)\n{\n    let lines = parse_lines(input);\n    count_matches(lines[0], lines[1])\n}\n\nspec fn count_matches(s: Seq<char>, t: Seq<char>) -> int\n    recommends s.len() == 3 && t.len() == 3\n{\n    (if s[0] == t[0] { 1int } else { 0int }) +\n    (if s[1] == t[1] { 1int } else { 0int }) +\n    (if s[2] == t[2] { 1int } else { 0int })\n}\n\nspec fn compute_result(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    if lines.len() < 2 {\n        seq!['0', '\\n']\n    } else if lines[0].len() != 3 || lines[1].len() != 3 {\n        seq!['0', '\\n']\n    } else {\n        int_to_string(count_matches(lines[0], lines[1])).add(seq!['\\n'])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        input.len() > 0,\n    ensures\n        result@ == compute_result(input@),\n        result.len() >= 2 && result[result.len() - 1] == '\\n',\n        result[0] == '0' || result[0] == '1' || result[0] == '2' || result[0] == '3',", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0507", "language": "verus", "source": "apps", "source_id": "apps_test_4247", "vc-description": "Given a permutation p of integers {1, 2, ..., n}, count how many elements p_i \n(where 1 < i < n) are the median (second smallest) value among the three \nconsecutive elements p_{i-1}, p_i, and p_{i+1}.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, p: Seq<int>) -> bool {\n    p.len() == n && n >= 3\n}\n\nspec fn count_median_elements(p: Seq<int>, n: int) -> nat {\n    if valid_input(n, p) {\n        Set::new(|i: int| 0 <= i < n - 2 && is_median_of_three(p[i], p[i + 1], p[i + 2])).len()\n    } else {\n        0\n    }\n}\n\nspec fn is_median_of_three(a: int, b: int, c: int) -> bool {\n    (a < b && b < c) || (a > b && b > c)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8, p: Vec<i8>) -> (result: u8)\n    requires\n        valid_input(n as int, p@.map(|i: int, x: i8| x as int)),\n    ensures\n        result <= n - 2,\n        result as nat == count_median_elements(p@.map(|i: int, x: i8| x as int), n as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0508", "language": "verus", "source": "apps", "source_id": "apps_test_4252", "vc-description": "Given a string of lowercase Latin letters, find the minimum number of characters \nto remove so that the resulting string does not contain \"xxx\" (three consecutive x's) \nas a substring. Characters can be removed from any positions. If the string initially \ndoesn't contain \"xxx\", return 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3\n}\n\nspec fn count_excessive_positions(s: Seq<char>) -> int {\n    count_excessive_positions_helper(s, 0, 0)\n}\n\nspec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let new_consecutive_x = if s[pos] == 'x' { consecutive_x + 1 } else { 0 };\n        let current_contribution: int = if new_consecutive_x > 2 { 1 } else { 0 };\n        current_contribution + count_excessive_positions_helper(s, pos + 1, new_consecutive_x)\n    }\n}\n\nspec fn consecutive_x_count(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos == 0 {\n        0\n    } else if pos > 0 && pos <= s.len() && s[pos - 1] == 'x' {\n        1 + consecutive_x_count(s, pos - 1)\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures \n        result >= 0,\n        result as int <= s@.len(),\n        result as int == count_excessive_positions(s@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0509", "language": "verus", "source": "apps", "source_id": "apps_test_4253", "vc-description": "Calculate the area of a regular dodecagon inscribed in a circle of radius r.\nThe area formula is 3r². Input is an integer r (1 ≤ r ≤ 100).\nOutput is the integer area.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(r: int) -> bool {\n    1 <= r <= 100\n}\n\nspec fn dodecagon_area(r: int) -> int {\n    3 * r * r\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10) + int_to_string(n % 10)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() > 1 {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (output: String)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0510", "language": "verus", "source": "apps", "source_id": "apps_test_4254", "vc-description": "Given the number of sheep S and wolves W, determine if the situation is \"safe\" or \"unsafe\".\nOutput \"unsafe\" if the number of wolves is greater than or equal to the number of sheep,\notherwise output \"safe\". Input is a string containing two integers separated by space.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let trimmed = trim_newlines(input);\n    let space_index = find_space(trimmed);\n    space_index >= 0 && space_index < trimmed.len() - 1 &&\n    is_valid_integer(trimmed.subrange(0, space_index)) &&\n    is_valid_integer(trimmed.subrange(space_index + 1, trimmed.len() as int))\n}\n\nspec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {\n    valid_input_format(input) &&\n    {\n        let trimmed = trim_newlines(input);\n        let space_index = find_space(trimmed);\n        let s_str = trimmed.subrange(0, space_index);\n        let w_str = trimmed.subrange(space_index + 1, trimmed.len() as int);\n        string_to_int(s_str) == s && string_to_int(w_str) == w\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    if s.len() == 0 {\n        false\n    } else if s[0] == '-' {\n        s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    } else {\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    }\n}\n\nspec fn trim_newlines(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s[s.len() - 1] == '\\n' {\n        trim_newlines(s.subrange(0, s.len() - 1))\n    } else {\n        s\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    find_space_helper(s, 0)\n}\n\nspec fn find_space_helper(s: Seq<char>, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        -1\n    } else if s[index] == ' ' {\n        index\n    } else {\n        find_space_helper(s, index + 1)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' && s.len() > 1 {\n        -string_to_int_helper(s.subrange(1, s.len() as int), 0, 0)\n    } else {\n        string_to_int_helper(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        acc\n    } else {\n        let digit = (s[index] as int) - ('0' as int);\n        string_to_int_helper(s, index + 1, acc * 10 + digit)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0511", "language": "verus", "source": "apps", "source_id": "apps_test_4255", "vc-description": "Given a right triangle with a 90° angle at vertex B, and the lengths of all three sides AB, BC, and CA,\ncalculate the area of the triangle. The area is computed as (AB * BC) / 2 where AB and BC are the two\nlegs of the right triangle. Input consists of three integers representing the side lengths, and output\nis the integer area.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(ab: int, bc: int, ca: int) -> bool {\n    1 <= ab <= 100 && 1 <= bc <= 100 && 1 <= ca <= 100\n}\n\nspec fn triangle_area(ab: int, bc: int) -> int\n    recommends ab >= 1 && bc >= 1\n{\n    (ab * bc) / 2\n}\n\nspec fn valid_area(ab: int, bc: int, area: int) -> bool\n    recommends ab >= 1 && bc >= 1\n{\n    area == triangle_area(ab, bc) && area >= 0 && area <= 5000\n}", "vc-helpers": "", "vc-spec": "fn solve(ab: i8, bc: i8, ca: i8) -> (result: String)\n    requires valid_input(ab as int, bc as int, ca as int)\n    ensures exists|area: int| valid_area(ab as int, bc as int, area)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0512", "language": "verus", "source": "apps", "source_id": "apps_test_4256", "vc-description": "Given three integers A (cost per drink), B (available money), and C (maximum drinks desired),\ndetermine how many drinks will be purchased. The number of drinks purchased is the minimum of:\n- How many drinks can be afforded: B // A  \n- The satisfaction limit: C", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|i: int, j: int| 0 <= i < j < input.len() && input[i] == ' ' && input[j] == ' ' &&\n    ({\n        let parts = split_string_spec(input);\n        parts.len() >= 3 && \n        is_valid_integer(parts[0]) && is_valid_integer(parts[1]) && is_valid_integer(parts[2]) &&\n        ({\n            let a = string_to_int_spec(parts[0]);\n            let b = string_to_int_spec(parts[1]);\n            let c = string_to_int_spec(parts[2]);\n            1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n        })\n    })\n}\n\nspec fn compute_drinks(a: int, b: int, c: int) -> int {\n    if b / a < c { b / a } else { c }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn string_to_int_spec(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 { \n        s[0] as int - '0' as int\n    } else if s.len() > 1 { \n        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    } else {\n        0\n    }\n}\n\nspec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { \n        seq![] \n    } else {\n        split_helper(s, 0, seq![])\n    }\n}\n\nspec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        if current.len() > 0 { seq![current] } else { seq![] }\n    } else if s[index] == ' ' || s[index] == '\\n' || s[index] == '\\t' {\n        if current.len() > 0 { \n            seq![current] + split_helper(s, index + 1, seq![])\n        } else { \n            split_helper(s, index + 1, seq![])\n        }\n    } else {\n        split_helper(s, index + 1, current.push(s[index]))\n    }\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 { \n        seq!['0'] \n    } else if n < 10 && n > 0 { \n        seq![('0' as int + n) as char]\n    } else if n > 0 { \n        int_to_string_spec(n / 10) + seq![('0' as int + (n % 10)) as char]\n    } else {\n        seq!['0']\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let parts = split_string_spec(input@);\n            let a = string_to_int_spec(parts[0]);\n            let b = string_to_int_spec(parts[1]);\n            let c = string_to_int_spec(parts[2]);\n            let drinks = compute_drinks(a, b, c);\n            result@ == int_to_string_spec(drinks) + seq!['\\n']\n        }),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0513", "language": "verus", "source": "apps", "source_id": "apps_test_4258", "vc-description": "A machine produces B biscuits at regular intervals of A seconds, starting at time A seconds.\nProductions occur at times A, 2A, 3A, 4A, ... seconds after activation.\nCalculate the total number of biscuits produced within the first T + 0.5 seconds.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, t: int) -> bool {\n    1 <= a <= 20 && 1 <= b <= 20 && 1 <= t <= 20\n}\n\nspec fn production_count(a: int, t: int) -> int {\n    if a > 0 { t / a } else { 0 }\n}\n\nspec fn total_biscuits(a: int, b: int, t: int) -> int {\n    if a > 0 { b * production_count(a, t) } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, t: i8) -> (result: i8)\n    requires valid_input(a as int, b as int, t as int)\n    ensures result as int == total_biscuits(a as int, b as int, t as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0514", "language": "verus", "source": "apps", "source_id": "apps_test_4261", "vc-description": "Given two bottles where Bottle 1 has capacity A milliliters and currently contains B milliliters,\nand Bottle 2 currently contains C milliliters, transfer as much water as possible from Bottle 2\nto Bottle 1 and determine how much water remains in Bottle 2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= b <= a <= 20 && 1 <= c <= 20\n}\n\nspec fn remaining_water(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let available_space = a - b;\n    let remaining = c - available_space;\n    if remaining >= 0 { remaining } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<i8>) -> (result: Vec<i8>)\n    requires input.len() > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0515", "language": "verus", "source": "apps", "source_id": "apps_test_4267", "vc-description": "Given a room temperature in degrees Celsius, determine whether to turn on an air conditioner.\nThe air conditioner should be turned on if and only if the temperature is 30°C or higher.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_temperature(temp: int) -> bool {\n    -40 <= temp <= 40\n}\n\nspec fn expected_output(temp: int) -> Seq<char> {\n    if temp >= 30 { seq!['Y', 'e', 's', '\\n'] } else { seq!['N', 'o', '\\n'] }\n}\n\nspec fn correct_output(temp: int, output: Seq<char>) -> bool {\n    output == expected_output(temp)\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8) -> (result: Vec<u8>)\n    requires valid_temperature(x as int)\n    ensures correct_output(x as int, result@.map(|i: int, b: u8| b as char))", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0516", "language": "verus", "source": "apps", "source_id": "apps_test_4269", "vc-description": "Given a 4-digit security code, determine if it is \"hard to enter\". A code is hard to enter\nif it contains any two consecutive digits that are the same. Output \"Bad\" if the code is \nhard to enter, \"Good\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_hard_to_enter(s: Seq<char>) -> bool\n    recommends s.len() == 4\n{\n    s[0] == s[1] || s[1] == s[2] || s[2] == s[3]\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires s@.len() == 4\n    ensures \n        result@.len() > 0,\n        (result@ == seq!['B', 'a', 'd'] <==> is_hard_to_enter(s@)),\n        (result@ == seq!['G', 'o', 'o', 'd'] <==> !is_hard_to_enter(s@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0519", "language": "verus", "source": "apps", "source_id": "apps_test_4275", "vc-description": "Given a string of length 6 consisting of lowercase English letters, determine if it is \"coffee-like\".\nA string is coffee-like if characters at positions 3 and 4 are equal, AND characters at positions 5 and 6 are equal (using 1-based indexing).", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 6 && forall|i: int| 0 <= i < 6 ==> 'a' <= #[trigger] s[i] <= 'z'\n}\n\nspec fn is_coffee_like(s: Seq<char>) -> bool \nrecommends valid_input(s)\n{\n    s[2] == s[3] && s[4] == s[5]\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: String)\n    requires \n        valid_input(s@)\n    ensures \n        result@ =~= seq!['Y', 'e', 's'] || result@ =~= seq!['N', 'o'],\n        is_coffee_like(s@) <==> result@ =~= seq!['Y', 'e', 's']", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0520", "language": "verus", "source": "apps", "source_id": "apps_test_4277", "vc-description": "Given N people traveling together, determine the minimum cost between two transportation options:\nTrain costs A yen per person (total: N*A), Taxi costs B yen total (fixed cost).\nFind the minimum total travel expense.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int) -> bool {\n    1 <= n <= 20 && 1 <= a <= 50 && 1 <= b <= 50\n}\n\nspec fn train_cost(n: int, a: int) -> int {\n    n * a\n}\n\nspec fn minimum_cost(n: int, a: int, b: int) -> int {\n    let train_cost_val = train_cost(n, a);\n    if train_cost_val < b { train_cost_val } else { b }\n}\n\nspec fn correct_result(input: Vec<i8>, result: Vec<i8>) -> bool {\n    /* Implementation would require string parsing functions that are not available in this context */\n    true\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<i8>) -> (result: Vec<i8>)\n    requires input.len() > 0\n    ensures correct_result(input, result)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0521", "language": "verus", "source": "apps", "source_id": "apps_test_4284", "vc-description": "Given q queries with battery charge k, n turns, and two actions with costs a and b (where b < a),\nfind the maximum number of Action A turns possible while completing exactly n turns and keeping\ncharge > 0 at the end, or return -1 if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_query(k: int, n: int, a: int, b: int) -> bool {\n    k > 0 && n > 0 && a > 0 && b > 0 && b < a\n}\n\nspec fn max_action_a_turns(k: int, n: int, a: int, b: int) -> int {\n    if n * b > k { \n        -1\n    } else { \n        let max_possible = (k - n * b - 1) / (a - b);\n        if n <= max_possible { n } else { max_possible }\n    }\n}\n\nspec fn valid_result(result: int, k: int, n: int, a: int, b: int) -> bool {\n    result == -1 || (0 <= result <= n)\n}", "vc-helpers": "", "vc-spec": "fn solve(queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)\n    requires \n        queries.len() > 0,\n        forall|i: int| 0 <= i < queries.len() ==> valid_query(#[trigger] queries[i as int].0 as int, queries[i as int].1 as int, queries[i as int].2 as int, queries[i as int].3 as int),\n    ensures \n        results.len() == queries.len(),\n        forall|i: int| 0 <= i < queries.len() ==> results[i as int] as int == max_action_a_turns(#[trigger] queries[i as int].0 as int, queries[i as int].1 as int, queries[i as int].2 as int, queries[i as int].3 as int),\n        forall|i: int| 0 <= i < results.len() ==> valid_result(#[trigger] results[i as int] as int, queries[i as int].0 as int, queries[i as int].1 as int, queries[i as int].2 as int, queries[i as int].3 as int),", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0522", "language": "verus", "source": "apps", "source_id": "apps_test_4294", "vc-description": "Given two integers X and A (both between 0 and 9 inclusive), output 0 if X is less than A, otherwise output 10.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, a: int) -> bool {\n    0 <= x <= 9 && 0 <= a <= 9\n}\n\nspec fn correct_output(x: int, a: int, result: int) -> bool {\n    result == (if x < a { 0nat as int } else { 10nat as int })\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8, a: i8) -> (result: i8)\n    requires valid_input(x as int, a as int)\n    ensures correct_output(x as int, a as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0523", "language": "verus", "source": "apps", "source_id": "apps_test_4295", "vc-description": "Given integers N and K, repeatedly perform the operation N := |N - K| to find\nthe minimum possible value N can achieve after zero or more operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 0 && k >= 1\n}\n\nspec fn min_value(n: int, k: int) -> int\n    recommends valid_input(n, k)\n{\n    let remainder = n % k;\n    let complement = k - remainder;\n    if remainder <= complement { remainder } else { complement }\n}\n\nspec fn is_correct_result(n: int, k: int, result: int) -> bool\n    recommends valid_input(n, k)\n{\n    result == min_value(n, k) &&\n    result >= 0 &&\n    result < k\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires valid_input(n as int, k as int)\n    ensures is_correct_result(n as int, k as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0524", "language": "verus", "source": "apps", "source_id": "apps_test_4297", "vc-description": "Given a positive integer N, find the smallest positive integer that is divisible by both 2 and N.\nThis is equivalent to finding the least common multiple of 2 and N.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn divisible_by_both(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    result % 2 == 0 && result % n == 0\n}\n\nspec fn is_smallest(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    forall|k: int| 1 <= k < result ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n) == 0)\n}\n\nspec fn lcm(a: int, b: int) -> int\n    recommends a >= 1 && b >= 1\n{\n    if a % b == 0 {\n        a\n    } else if b % a == 0 {\n        b\n    } else {\n        a * b\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires \n        n >= 1,\n    ensures \n        result >= 1,\n        result as int % 2 == 0 && result as int % n as int == 0,\n        forall|k: int| 1 <= k < result as int ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n as int) == 0),\n        (n as int % 2 == 0 ==> result as int == n as int) && (n as int % 2 != 0 ==> result as int == n as int * 2),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0525", "language": "verus", "source": "apps", "source_id": "apps_test_4298", "vc-description": "Given N apple trees numbered 1 to N in a row, find the minimum number of inspectors\nneeded to inspect all trees. Each inspector at position i covers trees from (i-D) to (i+D).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, d: int) -> bool {\n    n >= 1 && n <= 20 && d >= 1 && d <= 20\n}\n\nspec fn coverage_range(position: int, d: int) -> (int, int) {\n    (position - d, position + d)\n}\n\nspec fn trees_covered(n: int, d: int, inspectors: int) -> bool {\n    inspectors >= 1 && inspectors <= n && inspectors == ((n - 1) / (2 * d + 1)) + 1\n}", "vc-helpers": "", "vc-spec": "fn min_inspectors(n: i8, d: i8) -> (result: i8)\n    requires valid_input(n as int, d as int)\n    ensures trees_covered(n as int, d as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0526", "language": "verus", "source": "apps", "source_id": "apps_test_4299", "vc-description": "Given a positive integer N (1 ≤ N ≤ 999), determine the pronunciation of the Japanese counter word \"本\" \nbased on the ones digit of N. The pronunciation rules are: \"hon\" for ones digits 2,4,5,7,9; \n\"pon\" for ones digits 0,1,6,8; and \"bon\" for ones digit 3.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 999\n}\n\nspec fn is_hon_digit(digit: int) -> bool {\n    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9\n}\n\nspec fn is_pon_digit(digit: int) -> bool {\n    digit == 0 || digit == 1 || digit == 6 || digit == 8\n}\n\nspec fn is_bon_digit(digit: int) -> bool {\n    digit == 3\n}\n\nspec fn correct_pronunciation(n: int) -> Seq<char> {\n    let ones_digit = n % 10;\n    if is_hon_digit(ones_digit) {\n        seq!['h', 'o', 'n', '\\n']\n    } else if is_pon_digit(ones_digit) {\n        seq!['p', 'o', 'n', '\\n']\n    } else {\n        seq!['b', 'o', 'n', '\\n']\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<char>)\n    requires valid_input(n as int)\n    ensures result@ == correct_pronunciation(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0527", "language": "verus", "source": "apps", "source_id": "apps_test_4301", "vc-description": "Given a sequence of N integers, for each position i, find the maximum value \namong all N-1 elements excluding the element at position i.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn max_of_seq(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        if s[0] >= s[1] {\n            s[0]\n        } else {\n            s[1]\n        }\n    }\n}\n\nspec fn max_excluding(s: Seq<int>, exclude_idx: int) -> int\n    recommends 0 <= exclude_idx < s.len() && s.len() >= 2\n{\n    if exclude_idx == 0 {\n        max_of_seq(s.subrange(1, s.len() as int))\n    } else if exclude_idx == s.len() - 1 {\n        max_of_seq(s.subrange(0, s.len() - 1))\n    } else {\n        max_of_seq(s.subrange(0, exclude_idx).add(s.subrange(exclude_idx + 1, s.len() as int)))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<i8>) -> (result: Vec<i8>)\n    requires input@.len() >= 2", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0528", "language": "verus", "source": "apps", "source_id": "apps_test_4304", "vc-description": "Given uncovered heights of two adjacent towers after snowfall, find the snow depth.\nTowers have triangular number heights: 1, 3, 6, 10, ... (i-th tower height = i*(i+1)/2).\nSnow covers uniformly to same depth everywhere.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int) -> bool {\n  a >= 1 && b > a && b < 499500\n}\n\nspec fn valid_snow_depth(a: int, b: int, depth: int) -> bool {\n  depth >= 1 &&\n  ((b - a) * (b - a) - (a + b)) >= 2 &&\n  ((b - a) * (b - a) - (a + b)) % 2 == 0\n}\n\nspec fn snow_depth_formula(a: int, b: int) -> int\n  recommends valid_input(a, b) && valid_snow_depth(a, b, ((b - a) * (b - a) - (a + b)) / 2)\n{\n  ((b - a) * (b - a) - (a + b)) / 2\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n  requires valid_input(a as int, b as int) && valid_snow_depth(a as int, b as int, ((b as int - a as int) * (b as int - a as int) - (a as int + b as int)) / 2)\n  ensures result as int >= 1 && result as int == snow_depth_formula(a as int, b as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0529", "language": "verus", "source": "apps", "source_id": "apps_test_4305", "vc-description": "Given a monster with health H and attack damage A, find the minimum number of attacks needed to reduce the monster's health to 0 or below.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(h: int, a: int) -> bool {\n    h >= 1 && a >= 1\n}\n\nspec fn is_minimum_attacks(attacks: int, h: int, a: int) -> bool {\n    attacks >= 1 &&\n    attacks * a >= h &&\n    (attacks - 1) * a < h\n}\n\nspec fn ceil_div(h: int, a: int) -> int\n    recommends a > 0\n{\n    (h + a - 1) / a\n}", "vc-helpers": "", "vc-spec": "fn solve(h: i8, a: i8) -> (attacks: i8)\n    requires \n        valid_input(h as int, a as int)\n    ensures \n        is_minimum_attacks(attacks as int, h as int, a as int),\n        attacks as int == ceil_div(h as int, a as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0530", "language": "verus", "source": "apps", "source_id": "apps_test_4306", "vc-description": "Given two time intervals [A, B) and [C, D), find the length of their intersection.\nAlice holds a button from time A to time B (exclusive).\nBob holds a button from time C to time D (exclusive).\nCalculate how many seconds both are holding their buttons simultaneously.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    0 <= a < b <= 100 && 0 <= c < d <= 100\n}\n\nspec fn min(x: int, y: int) -> int {\n    if x < y { x } else { y }\n}\n\nspec fn max(x: int, y: int) -> int {\n    if x > y { x } else { y }\n}\n\nspec fn interval_overlap_length(a: int, b: int, c: int, d: int) -> int {\n    if min(b, d) - max(a, c) > 0 { min(b, d) - max(a, c) } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n    requires\n        valid_input(a as int, b as int, c as int, d as int),\n    ensures\n        result >= 0,\n        result as int == interval_overlap_length(a as int, b as int, c as int, d as int),\n        result <= 100,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0532", "language": "verus", "source": "apps", "source_id": "apps_test_4308", "vc-description": "Distribute N crackers to K users as evenly as possible and find the minimum \npossible absolute difference between the maximum and minimum number of crackers \nreceived by any user.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1 && n <= 100 && k <= 100\n}\n\nspec fn min_cracker_difference(n: int, k: int) -> int\n    recommends k > 0\n{\n    if n % k == 0 { 0 } else { 1 }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result as int == min_cracker_difference(n as int, k as int),\n        result as int == 0 <==> (n as int) % (k as int) == 0,\n        result as int == 1 <==> (n as int) % (k as int) != 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0533", "language": "verus", "source": "apps", "source_id": "apps_test_4310", "vc-description": "Given three tasks with integer values A1, A2, A3, find the minimum cost to complete all tasks.\nRules: Complete any one task first at cost 0, then completing task i followed by task j costs |Aj - Ai|.\nAll tasks must be completed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a1: int, a2: int, a3: int) -> bool {\n    1 <= a1 <= 100 && 1 <= a2 <= 100 && 1 <= a3 <= 100\n}\n\nspec fn max_of_three(a1: int, a2: int, a3: int) -> int {\n    if a1 >= a2 && a1 >= a3 { a1 } else if a2 >= a3 { a2 } else { a3 }\n}\n\nspec fn min_of_three(a1: int, a2: int, a3: int) -> int {\n    if a1 <= a2 && a1 <= a3 { a1 } else if a2 <= a3 { a2 } else { a3 }\n}\n\nspec fn minimum_cost(a1: int, a2: int, a3: int) -> int {\n    max_of_three(a1, a2, a3) - min_of_three(a1, a2, a3)\n}", "vc-helpers": "", "vc-spec": "fn solve(a1: i8, a2: i8, a3: i8) -> (result: i8)\n    requires \n        valid_input(a1 as int, a2 as int, a3 as int)\n    ensures \n        result as int >= 0,\n        result as int == minimum_cost(a1 as int, a2 as int, a3 as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0534", "language": "verus", "source": "apps", "source_id": "apps_test_4312", "vc-description": "Two monsters battle in turns. Takahashi's monster (health A, strength B) attacks first,\nthen they alternate. Each attack reduces opponent's health by attacker's strength.\nFirst monster to reach 0 or below health loses. Determine if Takahashi wins.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100 && 1 <= d <= 100\n}\n\nspec fn turns_to_defeat(health: int, strength: int) -> int\n    recommends strength > 0\n{\n    (health + strength - 1) / strength\n}\n\nspec fn takahashi_wins(a: int, b: int, c: int, d: int) -> bool\n    recommends valid_input(a, b, c, d)\n{\n    let takahashi_turns = turns_to_defeat(c, b);\n    let aoki_turns = turns_to_defeat(a, d);\n    aoki_turns >= takahashi_turns\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: String)\n    requires valid_input(a as int, b as int, c as int, d as int)\n    ensures result@ == (if takahashi_wins(a as int, b as int, c as int, d as int) { \"Yes\"@ } else { \"No\"@ })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0535", "language": "verus", "source": "apps", "source_id": "apps_test_4313", "vc-description": "Given N gems with values and costs, select a subset to maximize total profit\n(sum of selected values minus sum of selected costs). Only gems with positive\nprofit should be selected to achieve maximum profit.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_of_positive_profits(values: Seq<int>, costs: Seq<int>, n: int) -> int\n    decreases n\n    when n >= 0 && values.len() >= n && costs.len() >= n\n{\n    if n == 0 { \n        0 as int\n    } else { \n        let profit = values[n-1] - costs[n-1];\n        sum_of_positive_profits(values, costs, n-1) + (if profit > 0 { profit } else { 0 as int })\n    }\n}\n\nspec fn valid_input(n: int, values: Seq<int>, costs: Seq<int>) -> bool\n{\n    values.len() == n && costs.len() == n && n >= 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, values: Vec<i8>, costs: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, values@.map(|i, x| x as int), costs@.map(|i, x| x as int))\n    ensures \n        result >= 0 &&\n        result as int == sum_of_positive_profits(values@.map(|i, x| x as int), costs@.map(|i, x| x as int), n as int)", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0536", "language": "verus", "source": "apps", "source_id": "apps_test_4317", "vc-description": "Given two integers A and B, find the maximum value among A + B, A - B, and A × B.\nInput constraints: -100 ≤ A, B ≤ 100", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 3 &&\n    exists|space_pos: int| 0 < space_pos < input.len() - 1 && input[space_pos] == ' ' &&\n    (forall|i: int| 0 <= i < space_pos ==> input[i] != ' ') &&\n    (forall|i: int| space_pos + 1 <= i < input.len() ==> input[i] != ' ' || input[i] == '\\n') &&\n    is_valid_integer(get_a_string(input)) && is_valid_integer(get_b_string(input)) &&\n    -100 <= get_a(input) <= 100 && -100 <= get_b(input) <= 100\n}\n\nspec fn get_a(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(0, space_index))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(0, space_index))\n    }\n}\n\nspec fn get_b(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(space_index + 1, trimmed.len() as int))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(space_index + 1, input.len() as int))\n    }\n}\n\nspec fn get_a_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(0, space_index)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(0, space_index)\n    }\n}\n\nspec fn get_b_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(space_index + 1, trimmed.len() as int)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(space_index + 1, input.len() as int)\n    }\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c {\n        a\n    } else if b >= c {\n        b\n    } else {\n        c\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    0  /* placeholder for finding space position */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true  /* placeholder for integer validation */\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0  /* placeholder for parsing integer */\n}\n\nspec fn int_to_string(i: int) -> Seq<char> {\n    seq!['0']  /* placeholder for integer to string conversion */\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(input@.map_values(|b: u8| b as char))\n    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0537", "language": "verus", "source": "apps", "source_id": "apps_test_4318", "vc-description": "Given N mountains indexed from west to east with heights, count how many mountain inns \nallow ocean visibility. Mountain 1 (westmost) always has visibility. Mountain i (i ≥ 2) \nhas visibility if and only if its height is greater than or equal to the maximum height \nof all mountains to its west.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int\n    decreases up_to_index\n{\n    if 0 <= up_to_index < heights.len() {\n        if up_to_index == 0 {\n            heights[0]\n        } else if heights[up_to_index] >= max_height_up_to(heights, up_to_index - 1) {\n            heights[up_to_index]\n        } else {\n            max_height_up_to(heights, up_to_index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool {\n    if 0 <= mountain_index < heights.len() {\n        mountain_index == 0 || heights[mountain_index] >= max_height_up_to(heights, mountain_index - 1)\n    } else {\n        false\n    }\n}\n\nspec fn count_visible_mountains(heights: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n <= 0 {\n        0\n    } else if has_ocean_visibility(heights, n - 1) {\n        1 + count_visible_mountains(heights, n - 1)\n    } else {\n        count_visible_mountains(heights, n - 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u32, heights: Vec<i32>) -> (result: u32)\n    requires \n        n > 0,\n        heights.len() == n,\n        n <= 20,\n        forall|i: int| 0 <= i < heights.len() ==> 1 <= #[trigger] heights[i] as int <= 100,\n    ensures \n        1 <= result <= n,\n        result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0538", "language": "verus", "source": "apps", "source_id": "apps_test_4326", "vc-description": "Given N students, divide them into groups such that the number of groups \ncontaining 3 or more students is maximized. Groups with 2 or fewer students \nare not counted toward the result.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n    spec fn valid_input(n: int) -> bool {\n        1 <= n <= 1000\n    }\n    \n    spec fn max_groups_with_at_least_three(n: int) -> int\n        recommends valid_input(n)\n    {\n        n / 3\n    }\n    \n    spec fn valid_solution(n: int, result: int) -> bool\n        recommends valid_input(n)\n    {\n        result == max_groups_with_at_least_three(n) &&\n        result >= 0 &&\n        result <= n\n    }\n\n    fn solve_groups(n: i8) -> (result: i8)\n        requires valid_input(n as int)\n        ensures valid_solution(n as int, result as int)", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0539", "language": "verus", "source": "apps", "source_id": "apps_test_4327", "vc-description": "Given A whole apples and P apple pieces, determine the maximum number of apple pies that can be made.\nEach whole apple can be cut into 3 pieces, and each apple pie requires 2 pieces to make.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, p: int) -> bool {\n    0 <= a <= 100 && 0 <= p <= 100\n}\n\nspec fn total_pieces(a: int, p: int) -> int\n    recommends valid_input(a, p)\n{\n    a * 3 + p\n}\n\nspec fn max_pies(a: int, p: int) -> int\n    recommends valid_input(a, p)\n{\n    total_pieces(a, p) / 2\n}", "vc-helpers": "", "vc-spec": "fn calculate_max_pies(a: i8, p: i8) -> (pies: i8)\n    requires \n        valid_input(a as int, p as int)\n    ensures \n        pies as int == max_pies(a as int, p as int) &&\n        pies >= 0 &&\n        pies as int == (a as int * 3 + p as int) / 2", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0540", "language": "verus", "source": "apps", "source_id": "apps_test_4331", "vc-description": "Given a three-digit integer N, determine if it contains the digit 7.\nReturn \"Yes\" if N contains the digit 7, \"No\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    100 <= n <= 999\n}\n\nspec fn contains_seven(n: int) -> bool\n    recommends valid_input(n)\n{\n    (n % 10) == 7 || ((n / 10) % 10) == 7 || (n / 100) == 7\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result == \"Yes\\n\"@ || result == \"No\\n\"@\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<char>)\n    requires valid_input(n as int)\n    ensures \n        valid_output(result@) &&\n        ((result@ == \"Yes\\n\"@) <==> contains_seven(n as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0541", "language": "verus", "source": "apps", "source_id": "apps_test_4332", "vc-description": "Given an integer N, determine if the sum of its digits divides N evenly.\nLet S(N) be the sum of all digits in the decimal representation of N.\nCheck if N is divisible by S(N).\nInput: A single integer N (1 ≤ N ≤ 10^9)\nOutput: \"Yes\" if S(N) divides N, \"No\" otherwise", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn digit_value(c: char) -> int\n    recommends is_digit(c)\n{\n    c as int - '0' as int\n}\n\nspec fn sum_of_digits(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if is_digit(s[0]) {\n        digit_value(s[0]) + sum_of_digits(s.subrange(1, s.len() as int))\n    } else {\n        sum_of_digits(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if is_digit(s[0]) {\n        string_to_int(s.subrange(1, s.len() as int)) + digit_value(s[0]) * power_10((s.len() - 1) as int)\n    } else {\n        string_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn power_10(n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 { 1 } else { 10 * power_10(n - 1) }\n}\n\nspec fn clean_input(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        seq![]\n    } else if input[input.len() - 1] == '\\n' || input[input.len() - 1] == ' ' {\n        clean_input(input.subrange(0, input.len() - 1))\n    } else {\n        input\n    }\n}\n\nspec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| #![auto] 0 <= i < s.len() ==> is_digit(s[i])) && \n    (s.len() > 1 ==> s[0] != '0') && \n    string_to_int(s) > 0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    valid_positive_integer_string(clean_input(input))\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']", "vc-code": "{\n    assume(false);\n    \"No\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0542", "language": "verus", "source": "apps", "source_id": "apps_test_4333", "vc-description": "Given two adjacent vertices of a square in counter-clockwise order, find the coordinates of the remaining two vertices.\nThe input consists of four integers representing coordinates (x1,y1) and (x2,y2) of two adjacent vertices.\nThe output should be four integers representing coordinates (x3,y3) and (x4,y4) of the remaining vertices in counter-clockwise order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {\n    (x1, y1) != (x2, y2) &&\n    -100 <= x1 <= 100 && -100 <= y1 <= 100 &&\n    -100 <= x2 <= 100 && -100 <= y2 <= 100\n}\n\nspec fn compute_third_vertex(x1: int, y1: int, x2: int, y2: int) -> (int, int) {\n    (x2 - (y2 - y1), y2 + (x2 - x1))\n}\n\nspec fn compute_fourth_vertex(x1: int, y1: int, x2: int, y2: int) -> (int, int) {\n    (x1 - (y2 - y1), y1 + (x2 - x1))\n}\n\nspec fn valid_output(x1: int, y1: int, x2: int, y2: int, result: Seq<int>) -> bool {\n    result.len() == 4 &&\n    result[0] == compute_third_vertex(x1, y1, x2, y2).0 &&\n    result[1] == compute_third_vertex(x1, y1, x2, y2).1 &&\n    result[2] == compute_fourth_vertex(x1, y1, x2, y2).0 &&\n    result[3] == compute_fourth_vertex(x1, y1, x2, y2).1\n}", "vc-helpers": "", "vc-spec": "fn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)\n    requires valid_input(x1 as int, y1 as int, x2 as int, y2 as int)\n    ensures valid_output(x1 as int, y1 as int, x2 as int, y2 as int, result@.map(|i, v: i8| v as int))", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0545", "language": "verus", "source": "apps", "source_id": "apps_test_4340", "vc-description": "Transform an array of integers where odd numbers remain unchanged and even numbers are decremented by 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn transform_element(x: int) -> int {\n    if x % 2 == 0 { x - 1 } else { x }\n}\n\nspec fn valid_transformation(input: Seq<int>, output: Seq<int>) -> bool {\n    output.len() == input.len() &&\n    forall|i: int| 0 <= i < input.len() ==> output[i] == transform_element(input[i])\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>) -> (result: Vec<i8>)\n    ensures valid_transformation(a@.map(|_i, x| x as int), result@.map(|_i, x| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0546", "language": "verus", "source": "apps", "source_id": "apps_test_4343", "vc-description": "Given two strings s and t of length k consisting of lowercase Latin letters,\nwhere s is lexicographically less than t, find the median string in the\nlexicographically ordered list of all strings of length k that are\nlexicographically between s and t (inclusive).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> {\n    let s_val = string_to_base26(s);\n    let t_val = string_to_base26(t);\n    let median_val = (s_val + t_val) / 2;\n    base26_to_string(median_val, k)\n}\n\nspec fn string_to_base26(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { ((s[0] as int - 'a' as int) * pow26((s.len() - 1) as nat) + string_to_base26(s.subrange(1, s.len() as int))) as nat }\n}\n\nspec fn base26_to_string(val: nat, k: int) -> Seq<char>\n    decreases k when k >= 1\n{\n    if k == 1 { seq![((val % 26) + ('a' as int)) as char] }\n    else { base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }\n}\n\nspec fn pow26(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 26 * pow26((n - 1) as nat) }\n}", "vc-helpers": "", "vc-spec": "fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)\n    requires \n        k >= 1,\n        s.len() == k,\n        t.len() == k,\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] s[i] <= 'z',\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] t[i] <= 'z',\n    ensures \n        result.len() == k,\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] result[i] <= 'z',\n        result@ == median_string(s@, t@, k as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0548", "language": "verus", "source": "apps", "source_id": "apps_test_4347", "vc-description": "Given n people where n is even, find the number of ways to divide them into exactly two \nindistinguishable round dances, each containing exactly n/2 people. A round dance is a \ncircular arrangement where rotations are considered identical, and both the rotations \nwithin each dance and the two dances themselves are indistinguishable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 2 && n % 2 == 0 && n <= 20\n}\n\nspec fn factorial(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\nspec fn expected_result(n: int) -> int {\n    if valid_input(n) {\n        let half = n / 2;\n        let fact_n = factorial(n);\n        let fact_half = factorial(half);\n        let fact_half_minus_1 = factorial(half - 1);\n        let binomial = fact_n / (fact_half * fact_half);\n        let arrangements = fact_half_minus_1 * fact_half_minus_1;\n        (binomial * arrangements) / 2\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures result as int == expected_result(n as int) && result > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0549", "language": "verus", "source": "apps", "source_id": "apps_test_4351", "vc-description": "Given a three-digit positive integer N (100 ≤ N ≤ 999), determine if it is palindromic\n(reads the same forwards and backwards in decimal notation).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n  100 <= n <= 999\n}\n\nspec fn is_palindromic(n: int) -> bool\n  recommends valid_input(n)\n{\n  let hundreds = n / 100;\n  let units = n % 10;\n  hundreds == units\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n  requires stdin_input@.len() > 0", "vc-code": "{\n  // impl-start\n  assume(false);\n  \"\".to_string()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0550", "language": "verus", "source": "apps", "source_id": "apps_test_4353", "vc-description": "Given a string containing comma-separated words, replace all commas with spaces.\nThe input string has length 19 with format: 5 lowercase letters, comma, 7 lowercase letters, comma, 5 lowercase letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n  s.len() == 19 && \n  s.len() >= 2 && s[5] == ',' && s[13] == ',' &&\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == ',' || ('a' <= s[i] <= 'z'))\n}\n\nspec fn commas_to_spaces(s: Seq<char>) -> Seq<char>\n  recommends valid_input(s)\n{\n  Seq::new(s.len(), |i: int| { if s[i] == ',' { ' ' } else { s[i] } })\n}\n\nspec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool\n  recommends valid_input(s)\n{\n  result.len() == s.len() + 1 &&\n  result[result.len() - 1] == '\\n' &&\n  forall|i: int| 0 <= i < s.len() ==> \n    (s[i] == ',' ==> result[i] == ' ') &&\n    (s[i] != ',' ==> result[i] == s[i])\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n  requires valid_input(s@)\n  ensures correct_output(s@, result@)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0551", "language": "verus", "source": "apps", "source_id": "apps_test_4362", "vc-description": "Given a single English letter (either uppercase A-Z or lowercase a-z), \noutput \"A\" if the input letter is uppercase, or \"a\" if the input letter is lowercase.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_lowercase_letter(c: char) -> bool {\n    'a' <= c && c <= 'z'\n}\n\nspec fn all_lowercase(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> is_lowercase_letter(s[i])\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result =~= seq!['A'] || result =~= seq!['a']\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    ensures \n        valid_output(result@) &&\n        (all_lowercase(input@) ==> result@ =~= seq!['a']) &&\n        ((input@.len() == 0 || !all_lowercase(input@)) ==> result@ =~= seq!['A'])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0552", "language": "verus", "source": "apps", "source_id": "apps_test_4363", "vc-description": "Given two integers K and S, count the number of ordered triples (X, Y, Z) where\neach of X, Y, Z is an integer in the range [0, K] and X + Y + Z = S.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int, s: int) -> bool {\n    k >= 0 && s >= 0 && s <= 3 * k\n}\n\nspec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {\n    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s\n}\n\nspec fn count_valid_triples(k: int, s: int) -> int\n    recommends k >= 0\n{\n    count_valid_triples_helper(k, s, 0)\n}\n\nspec fn count_valid_triples_helper(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n    decreases if k >= z { k + 1 - z } else { 0 }\n{\n    if z > k { 0 }\n    else { count_valid_triples_for_z(k, s, z) + count_valid_triples_helper(k, s, z + 1) }\n}\n\nspec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n{\n    count_valid_triples_for_z_helper(k, s, z, 0)\n}\n\nspec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int\n    recommends k >= 0, z >= 0, y >= 0\n    decreases if k >= y { k + 1 - y } else { 0 }\n{\n    if y > k { 0 }\n    else { \n        let x = s - y - z;\n        let this_count: int = if 0 <= x <= k { 1 } else { 0 };\n        this_count + count_valid_triples_for_z_helper(k, s, z, y + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn count_triples(k: i8, s: i8) -> (count: i8)\n    requires\n        valid_input(k as int, s as int),\n    ensures\n        count as int == count_valid_triples(k as int, s as int),\n        count >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0554", "language": "verus", "source": "apps", "source_id": "apps_test_4365", "vc-description": "Given an integer K (2 ≤ K ≤ 100), count the number of ways to choose one even number and one odd number from the integers 1 through K (inclusive). Order of selection does not matter.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int) -> bool {\n    2 <= k <= 100\n}\n\nspec fn count_odd_numbers(k: int) -> int\n    recommends k >= 1\n{\n    (k + 1) / 2\n}\n\nspec fn count_even_numbers(k: int) -> int\n    recommends k >= 1\n{\n    k / 2\n}\n\nspec fn expected_result(k: int) -> int\n    recommends valid_input(k)\n{\n    count_odd_numbers(k) * count_even_numbers(k)\n}\n\nspec fn correct_result(k: int, result: int) -> bool\n    recommends valid_input(k)\n{\n    result == expected_result(k)\n}", "vc-helpers": "", "vc-spec": "fn count_even_odd_pairs(k: i8) -> (result: i8)\n    requires\n        valid_input(k as int),\n    ensures\n        correct_result(k as int, result as int),\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0555", "language": "verus", "source": "apps", "source_id": "apps_test_4366", "vc-description": "Given current time A (0-23) and hours B until contest begins (0-23), \ndetermine the contest start time in 24-hour format using modular arithmetic.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else if n == 12 { seq!['1', '2'] }\n    else if n == 13 { seq!['1', '3'] }\n    else if n == 14 { seq!['1', '4'] }\n    else if n == 15 { seq!['1', '5'] }\n    else if n == 16 { seq!['1', '6'] }\n    else if n == 17 { seq!['1', '7'] }\n    else if n == 18 { seq!['1', '8'] }\n    else if n == 19 { seq!['1', '9'] }\n    else if n == 20 { seq!['2', '0'] }\n    else if n == 21 { seq!['2', '1'] }\n    else if n == 22 { seq!['2', '2'] }\n    else if n == 23 { seq!['2', '3'] }\n    else { seq!['0'] }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b))\n}\n\nspec fn contest_start_time(a: int, b: int) -> int {\n    (a + b) % 24\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) ==> \n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b)) &&\n    result == int_to_string(contest_start_time(a, b)) + seq!['\\n']\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    ensures correct_output(input@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0556", "language": "verus", "source": "apps", "source_id": "apps_test_4370", "vc-description": "Given a circular cake divided into 16 equal pieces, determine if two people can take A and B pieces \nrespectively such that neither person takes two adjacent pieces. The maximum number of non-adjacent \npieces any person can take from 16 pieces arranged in a circle is 8.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    1 <= a <= 16 && 1 <= b <= 16 && a + b <= 16\n}\n\nspec fn can_take_non_adjacent(pieces: int, total: int) -> bool {\n    pieces <= total / 2\n}\n\nspec fn both_can_take(a: int, b: int) -> bool {\n    can_take_non_adjacent(a, 16) && can_take_non_adjacent(b, 16)\n}", "vc-helpers": "", "vc-spec": "fn solve_cake_problem(a: i8, b: i8) -> (result: &'static str)\n    requires \n        valid_input(a as int, b as int),\n    ensures \n        both_can_take(a as int, b as int) <==> (result == \"Yay!\"),\n        (!both_can_take(a as int, b as int)) <==> (result == \":(\"),\n        (result == \"Yay!\") || (result == \":(\"),", "vc-code": "{\n    assume(false);\n    \"\"\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0557", "language": "verus", "source": "apps", "source_id": "apps_test_4371", "vc-description": "Given a string S of digits (1-9), find the minimum absolute difference between 753 and any 3-digit number formed by taking three consecutive digits from S.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '1' && #[trigger] s.index(i) <= '9'\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    100 * ((s.index(0) as int) - ('0' as int)) + \n    10 * ((s.index(1) as int) - ('0' as int)) + \n    ((s.index(2) as int) - ('0' as int))\n}\n\nspec fn abs_diff(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {\n    s.subrange(i, i + 3)\n}\n\nspec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {\n    valid_input(s) ==> (\n        result >= 0 &&\n        (exists|i: int| 0 <= i <= s.len() - 3 && result == abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i)))) &&\n        (forall|i: int| 0 <= i <= s.len() - 3 ==> result <= abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i))))\n    )\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i32)\n    requires valid_input(s@)\n    ensures is_minimum_difference(s@, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0558", "language": "verus", "source": "apps", "source_id": "apps_test_4380", "vc-description": "Given two integers A and B (each between 1 and 3 inclusive), determine if there exists \nan integer C (also between 1 and 3 inclusive) such that the product A × B × C is odd.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    1 <= a <= 3 && 1 <= b <= 3\n}\n\nspec fn is_odd(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn exists_odd_product(a: int, b: int) -> bool {\n    valid_input(a, b) ==> exists|c: int| 1 <= c <= 3 && #[trigger] is_odd(a * b * c)\n}\n\nspec fn should_answer_yes(a: int, b: int) -> bool {\n    valid_input(a, b) ==> (a != 2 && b != 2)\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: Seq<char>)\n  requires valid_input(a as int, b as int)\n  ensures result == (if should_answer_yes(a as int, b as int) { \"Yes\"@ } else { \"No\"@ })", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0559", "language": "verus", "source": "apps", "source_id": "apps_test_4381", "vc-description": "Calculate the total cost to travel from Station A to Station C using a special discount ticket.\nGiven train fare X yen (A to B) and bus fare Y yen (B to C), if you take the train first then the bus,\nthe bus fare becomes half price. Find the total cost A to C.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(train_fare: int, bus_fare: int) -> bool {\n    1 <= train_fare <= 100 && 1 <= bus_fare <= 100 && bus_fare % 2 == 0\n}\n\nspec fn total_cost(train_fare: int, bus_fare: int) -> int\n    recommends valid_input(train_fare, bus_fare)\n{\n    train_fare + bus_fare / 2\n}", "vc-helpers": "", "vc-spec": "fn solve(train_fare: i8, bus_fare: i8) -> (result: i8)\n    requires valid_input(train_fare as int, bus_fare as int)\n    ensures result as int == total_cost(train_fare as int, bus_fare as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0561", "language": "verus", "source": "apps", "source_id": "apps_test_4384", "vc-description": "Given an integer N (1 ≤ N ≤ 1998), determine the first three characters of the N-th AtCoder Beginner Contest label.\nContest labeling system: Rounds 1-999 use \"ABC\", rounds 1000-1998 use \"ABD\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 1998\n}\n\nspec fn expected_result(n: int) -> Seq<char> {\n    if n < 1000 { seq!['A', 'B', 'C'] } else { seq!['A', 'B', 'D'] }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i32) -> (result: Vec<char>)\n    requires valid_input(n as int)\n    ensures result@ == expected_result(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0563", "language": "verus", "source": "apps", "source_id": "apps_test_4386", "vc-description": "Given an integer a and a string s of lowercase English letters, \noutput s if a >= 3200, otherwise output \"red\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n') &&\n    (forall|i: int| #![trigger input[i]] 0 <= i < input.len() ==> input[i] == '\\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n' && (forall|j: int| #![trigger input[j]] 0 <= j < i ==> '0' <= input[j] <= '9'))\n}\n\nspec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {\n    2800 <= a < 5000 &&\n    1 <= s.len() <= 10 &&\n    (forall|j: int| #![trigger s[j]] 0 <= j < s.len() ==> 'a' <= s[j] <= 'z')\n}\n\nspec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {\n    (a >= 3200 ==> result == s + seq!['\\n']) &&\n    (a < 3200 ==> result == seq!['r', 'e', 'd', '\\n'])\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {\n    (0, seq!['a'])\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n'", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0564", "language": "verus", "source": "apps", "source_id": "apps_test_4387", "vc-description": "Given a contestant's rating R, determine which contest they are eligible for:\nABC for ratings less than 1200, ARC for ratings from 1200 to less than 2800,\nand AGC for ratings 2800 and above.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_rating(r: int) -> bool {\n    0 <= r <= 4208\n}\n\nspec fn contest_for_rating(r: int) -> Seq<char> {\n    if r < 1200 {\n        seq!['A', 'B', 'C', '\\n']\n    } else if r < 2800 {\n        seq!['A', 'R', 'C', '\\n']\n    } else {\n        seq!['A', 'G', 'C', '\\n']\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(r: i8) -> (result: Vec<char>)\n    requires \n        valid_rating(r as int)\n    ensures \n        result@ == contest_for_rating(r as int),\n        r < 1200 ==> result@ == seq!['A', 'B', 'C', '\\n'],\n        1200 <= r < 2800 ==> result@ == seq!['A', 'R', 'C', '\\n'],\n        r >= 2800 ==> result@ == seq!['A', 'G', 'C', '\\n']", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0565", "language": "verus", "source": "apps", "source_id": "apps_test_4388", "vc-description": "Given a three-digit string containing only digits '1' and '9', swap each '1' with '9' \nand each '9' with '1', then return the transformed string with a newline appended.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 3 &&\n    forall|i: int| 0 <= i < 3 ==> (input[i] == '1' || input[i] == '9')\n}\n\nspec fn swap_digit(c: char) -> char {\n    if c == '1' { '9' } else { '1' }\n}\n\nspec fn transform_string(s: Seq<char>) -> Seq<char> {\n    seq![swap_digit(s[0]), swap_digit(s[1]), swap_digit(s[2])]\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool {\n    result.len() == 4 &&\n    result[3] == '\\n' &&\n    forall|i: int| 0 <= i < 3 ==> \n        (input[i] == '1' ==> result[i] == '9') && \n        (input[i] == '9' ==> result[i] == '1')\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(input@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0566", "language": "verus", "source": "apps", "source_id": "apps_test_4390", "vc-description": "Given two positive integers a and b, find the minimum number of increments needed \nto make a divisible by b. In each move, you can increase a by 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < test_cases.len() ==> \n        test_cases[i].0 > 0 && test_cases[i].1 > 0\n}\n\nspec fn min_moves_to_divisible(a: int, b: int) -> int\n    recommends a > 0 && b > 0\n{\n    (b - a % b) % b\n}\n\nspec fn valid_output(test_cases: Seq<(int, int)>, results: Seq<int>) -> bool\n    recommends valid_input(test_cases)\n{\n    results.len() == test_cases.len() &&\n    forall|i: int| 0 <= i < results.len() ==> \n        results[i] == min_moves_to_divisible(test_cases[i].0, test_cases[i].1) &&\n        results[i] >= 0\n}", "vc-helpers": "", "vc-spec": "fn solve(test_cases: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires valid_input(test_cases@.map(|i, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))\n    ensures valid_output(test_cases@.map(|i, pair: (i8, i8)| (pair.0 as int, pair.1 as int)), results@.map(|i, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0567", "language": "verus", "source": "apps", "source_id": "apps_test_4392", "vc-description": "Given an array and a set of allowed swap positions, determine if the array can be sorted \nin non-decreasing order using only adjacent swaps at the allowed positions. An allowed swap\nexchanges elements at positions i and i+1 if position i is in the allowed set.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {\n    a.len() > 1 && allowed_pos.len() == a.len()\n}\n\nspec fn is_sorted(a: Seq<int>) -> bool\n    decreases a.len()\n{\n    if a.len() <= 1 {\n        true\n    } else {\n        a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))\n    }\n}\n\nspec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {\n    original.len() == target.len() && target.len() == allowed.len() &&\n    original.to_multiset() == target.to_multiset()\n}\n\nspec fn sort_sequence(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_seq(s)\n    }\n}\n\nspec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_helper(s, s.len() as nat)\n    }\n}\n\nspec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>\n    decreases passes\n{\n    if passes == 0 {\n        s\n    } else {\n        bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)\n    }\n}\n\nspec fn bubble_pass(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_pass_helper(s, 0)\n    }\n}\n\nspec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>\n    decreases if pos <= s.len() { s.len() - pos } else { 0 }\n{\n    if pos >= s.len() || pos >= s.len() - 1 {\n        s\n    } else if s[pos as int] > s[(pos + 1) as int] {\n        bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)\n    } else {\n        bubble_pass_helper(s, pos + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn can_sort(a: &mut Vec<i8>, allowed_pos: &[bool]) -> (result: bool)\n    requires \n        valid_input(old(a)@.map_values(|x: i8| x as int), allowed_pos@),\n    ensures \n        a@.map_values(|x: i8| x as int).to_multiset() == old(a)@.map_values(|x: i8| x as int).to_multiset(),\n        result == is_sorted(a@.map_values(|x: i8| x as int)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0569", "language": "verus", "source": "apps", "source_id": "apps_test_4399", "vc-description": "Given a string of length 3 representing railway companies ('A' or 'B') operating 3 stations,\ndetermine if any bus service will exist. Bus services connect stations operated by different companies.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() == 3 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'A' || input[i] == 'B'\n}\n\nspec fn bus_service_exists(input: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    input[0] != input[1] || input[1] != input[2]\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        result@ == seq!['Y', 'e', 's'] <==> bus_service_exists(input@),\n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0570", "language": "verus", "source": "apps", "source_id": "apps_test_4400", "vc-description": "Given a string S of length 3 representing weather records for 3 consecutive days\n(where 'S' means sunny and 'R' means rainy), find the maximum number of consecutive rainy days.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'S' || s[i] == 'R'\n}\n\nspec fn max_consecutive_rainy_days(s: Seq<char>) -> int {\n    if valid_input(s) {\n        if s == seq!['R', 'R', 'R'] {\n            3\n        } else if s.subrange(0, 2) == seq!['R', 'R'] || s.subrange(1, 3) == seq!['R', 'R'] {\n            2\n        } else if s.contains('R') {\n            1\n        } else {\n            0\n        }\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: i8)\n    requires \n        valid_input(input@),\n    ensures \n        result as int == max_consecutive_rainy_days(input@),\n        0 <= result && result <= 3,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0571", "language": "verus", "source": "apps", "source_id": "apps_test_4403", "vc-description": "Given a string of exactly 4 characters containing only '+' and '-',\ncalculate the sum where each '+' contributes +1 and each '-' contributes -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 4 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat as int\n    } else {\n        (if s[0] == c { 1nat as int } else { 0nat as int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn calculate_sum(s: Seq<char>) -> int {\n    count_char(s, '+') - count_char(s, '-')\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures result as int == calculate_sum(s@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0572", "language": "verus", "source": "apps", "source_id": "apps_test_4404", "vc-description": "Given a string representing a valid date in 2019 in format yyyy/mm/dd,\ndetermine if the date is on or before April 30, 2019.\nReturn \"Heisei\" if on or before April 30, 2019, otherwise return \"TBD\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {\n    s.len() >= 10 && \n    s[4] == '/' && s[7] == '/' &&\n    string_to_int(s.subrange(0, 4)) == y &&\n    string_to_int(s.subrange(5, 7)) == m &&\n    string_to_int(s.subrange(8, 10)) == d\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 { char_to_digit(s[0]) }\n    else if s.len() == 2 { char_to_digit(s[0]) * 10 + char_to_digit(s[1]) }\n    else if s.len() == 4 { char_to_digit(s[0]) * 1000 + char_to_digit(s[1]) * 100 + char_to_digit(s[2]) * 10 + char_to_digit(s[3]) }\n    else { 0 }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    if '0' <= c && c <= '9' { (c as int) - ('0' as int) } else { 0 }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31\n}\n\nspec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && \n    ((m < 4 || (m == 4 && d <= 30)) ==> result == seq!['H', 'e', 'i', 's', 'e', 'i']) && \n    ((m > 4 || (m == 4 && d > 30)) ==> result == seq!['T', 'B', 'D'])\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0573", "language": "verus", "source": "apps", "source_id": "apps_test_4413", "vc-description": "Given n students with distinct programming skills, divide them into the minimum number of teams \nsuch that no two students with skills differing by exactly 1 are on the same team.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(skills: Seq<int>) -> bool {\n    skills.len() >= 0\n}\n\nspec fn has_adjacent_skills(skills: Seq<int>) -> bool {\n    exists|i: int, j: int| 0 <= i < j < skills.len() && (skills[i] - skills[j] == 1 || skills[j] - skills[i] == 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(skills: Vec<i8>) -> (teams: i8)\n    requires \n        valid_input(skills@.map(|i, x| x as int))\n    ensures \n        teams == 1 || teams == 2,\n        teams == 2 <==> has_adjacent_skills(skills@.map(|i, x| x as int)),\n        teams == 1 <==> !has_adjacent_skills(skills@.map(|i, x| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0575", "language": "verus", "source": "apps", "source_id": "apps_test_4426", "vc-description": "Given a day of the week as a string, determine how many days until the next Sunday.\nInput is one of \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", or \"SAT\".\nOutput is the number of days until the next Sunday (1-7, where 7 means next Sunday is in a week).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_day(day: &str) -> bool {\n    day == \"SUN\" || day == \"MON\" || day == \"TUE\" || day == \"WED\" || day == \"THU\" || day == \"FRI\" || day == \"SAT\"\n}\n\nspec fn days_until_sunday(day: &str) -> int {\n    if day == \"SUN\" { 7 }\n    else if day == \"MON\" { 6 }\n    else if day == \"TUE\" { 5 }\n    else if day == \"WED\" { 4 }\n    else if day == \"THU\" { 3 }\n    else if day == \"FRI\" { 2 }\n    else { 1 }\n}", "vc-helpers": "", "vc-spec": "fn days_to_next_sunday(day: &str) -> (result: i8)\n    requires \n        valid_day(day)\n    ensures \n        result as int >= 1 && result as int <= 7,\n        result as int == days_until_sunday(day)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0576", "language": "verus", "source": "apps", "source_id": "apps_test_4427", "vc-description": "Given a recurrence relation x_{i+1} = r × x_i - D starting from year 2000, \ncalculate the values for years 2001 through 2010.\nInput: Three integers r, D, x_2000 where 2 ≤ r ≤ 5, 1 ≤ D ≤ 100, D < x_2000 ≤ 200\nOutput: 10 lines containing x_{2001}, x_{2002}, ..., x_{2010} respectively", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let tokens = parse_input_pure(input);\n    tokens.len() == 3 && \n    2 <= tokens[0] <= 5 &&\n    1 <= tokens[1] <= 100 &&\n    tokens[1] < tokens[2] && tokens[2] <= 200\n}\n\nspec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int\n    recommends n >= 1\n    decreases n when n >= 1\n{\n    if n == 1 { r * x0 - d }\n    else if n >= 2 { r * calculate_recurrence(r, d, x0, n - 1) - d }\n    else { 0 }\n}\n\nspec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {\n    generate_output_up_to_iteration(r, d, x0, 10)\n}\n\nspec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>\n    recommends iterations >= 0\n    decreases iterations when iterations >= 0\n{\n    if iterations == 0 { \n        Seq::empty() \n    } else if iterations >= 1 { \n        let current_value = calculate_recurrence(r, d, x0, iterations);\n        let previous_output = generate_output_up_to_iteration(r, d, x0, iterations - 1);\n        previous_output + int_to_string(current_value) + seq!['\\n']\n    } else {\n        Seq::empty()\n    }\n}\n\nspec fn parse_input_pure(input: Seq<char>) -> Seq<int> {\n    seq![1, 1, 100]  /* placeholder */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']  /* placeholder */\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@ == generate_expected_output(\n            parse_input_pure(input@)[0], \n            parse_input_pure(input@)[1], \n            parse_input_pure(input@)[2]\n        )", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0577", "language": "verus", "source": "apps", "source_id": "apps_test_4430", "vc-description": "Given n objects with sizes and m boxes of capacity k, find the maximum number of objects\nthat can be packed using a greedy algorithm by potentially removing leftmost objects.\nThe greedy algorithm processes objects from left to right, placing each object in the\ncurrent box if it fits, otherwise using a new empty box.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int\n    recommends\n        boxes >= 1,\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n{\n    greedy_pack_from_end_helper(a, a.len() - 1, boxes, capacity, capacity)\n}\n\nspec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int\n    recommends\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n        boxes_left >= 1,\n        0 <= current_box_space <= capacity,\n    decreases pos + 1,\n{\n    if pos < 0 {\n        0int\n    } else if pos >= a.len() {\n        0int\n    } else if a[pos] > capacity {\n        0int\n    } else if a[pos] <= current_box_space {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])\n    } else if boxes_left > 1 {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])\n    } else {\n        0int\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires\n        n >= 0,\n        m >= 1,\n        k >= 1,\n        a.len() == n as usize,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] as int >= 1 && #[trigger] a[i] as int <= k as int,\n    ensures\n        0 <= result as int <= n as int,\n        result as int == greedy_pack_from_end(a@.map(|i, x| x as int), m as int, k as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0578", "language": "verus", "source": "apps", "source_id": "apps_test_4431", "vc-description": "Given a string of n lowercase Latin letters and k available letters on a broken keyboard,\ncount how many substrings of the string can be typed using only the available letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {\n    n == s.len() &&\n    k == available.len() &&\n    forall|i: int, j: int| 0 <= i < j < available.len() ==> available[i] != available[j]\n}\n\nspec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else {\n        let segments = get_maximal_valid_segments(s, available_set, 0);\n        sum_segment_counts(segments)\n    }\n}\n\nspec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() { Seq::empty() }\n    else {\n        let segment_length = get_next_segment_length(s, available_set, start_idx);\n        if segment_length == 0 {\n            get_maximal_valid_segments(s, available_set, start_idx + 1)\n        } else {\n            let skip_length = skip_invalid_chars(s, available_set, start_idx + segment_length);\n            let next_idx = start_idx + segment_length + skip_length;\n            if next_idx <= s.len() {\n                seq![segment_length].add(get_maximal_valid_segments(s, available_set, next_idx))\n            } else {\n                seq![segment_length]\n            }\n        }\n    }\n}\n\nspec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || !available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + get_next_segment_length(s, available_set, start_idx + 1) }\n}\n\nspec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + skip_invalid_chars(s, available_set, start_idx + 1) }\n}\n\nspec fn sum_segment_counts(segments: Seq<nat>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { 0 }\n    else { segments[0] * (segments[0] + 1) / 2 + sum_segment_counts(segments.subrange(1, segments.len() as int)) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8, k: u8, s: Vec<char>, available: Vec<char>) -> (result: u8)\n    requires valid_input(n as nat, k as nat, s@, available@)\n    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0579", "language": "verus", "source": "apps", "source_id": "apps_test_4441", "vc-description": "Read an integer N from input. If N=1, print \"Hello World\". If N=2, read two additional integers A and B, then print their sum.\nConstraints: N is 1 or 2, A and B are integers between 1 and 9 (inclusive).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {\n    let lines = split_lines_func(stdin_input);\n    if lines.len() >= 1 {\n        let n = string_to_int(lines[0]);\n        if n == 1 {\n            seq!['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\n']\n        } else if n != 1 && lines.len() >= 3 {\n            let a = string_to_int(lines[1]);\n            let b = string_to_int(lines[2]);\n            int_to_string(a + b) + seq!['\\n']\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_func_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i >= s.len() {\n        if current.len() == 0 { acc } else { acc.push(current) }\n    } else if s[i] == '\\n' {\n        split_lines_func_helper(s, i + 1, seq![], acc.push(current))\n    } else {\n        split_lines_func_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -string_to_int_helper(s.subrange(1, s.len() as int))\n    } else {\n        string_to_int_helper(s)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        seq![]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@ == expected_output(stdin_input@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0580", "language": "verus", "source": "apps", "source_id": "apps_test_4443", "vc-description": "Given a lowercase English letter (not 'z'), output the next letter in alphabetical order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && 'a' <= input[0] <= 'y'\n}\n\nspec fn next_char(c: char) -> char\n    recommends 'a' <= c <= 'y'\n{\n    ((c as u8) + 1) as char\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    output.len() == 2 &&\n    output[0] == next_char(input[0]) &&\n    output[1] == '\\n' &&\n    'b' <= output[0] <= 'z'\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(input@, output@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0581", "language": "verus", "source": "apps", "source_id": "apps_test_4444", "vc-description": "Given two strings S and T as space-separated input, concatenate T and S (in that order) and output the result.\nInput format: \"S T\" where S and T contain only lowercase English letters.\nOutput format: \"TS\\n\" (T concatenated with S followed by newline).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 2 &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ') &&\n    (forall|i: int| 0 <= i < input.len() ==> (#[trigger] input[i] == ' ' || input[i] == '\\n' || ('a' <= input[i] <= 'z'))) &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ' && \n     (forall|j: int| 0 <= j < i ==> #[trigger] input[j] != ' ' && input[j] != '\\n') &&\n     (forall|j: int| i+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n'))\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    output[output.len() as int - 1] == '\\n' &&\n    (forall|i: int| 0 <= i < output.len() - 1 ==> ('a' <= #[trigger] output[i] <= 'z'))\n}\n\nspec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)\n    recommends valid_input(input)\n{\n    let space_pos = choose|space_pos: int| 0 < space_pos < input.len() && input[space_pos] == ' ' &&\n                       (forall|j: int| 0 <= j < space_pos ==> #[trigger] input[j] != ' ') &&\n                       (forall|j: int| space_pos+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n');\n    let s = input.subrange(0, space_pos);\n    let t = if input[input.len() as int - 1] == '\\n' { \n        input.subrange(space_pos + 1, input.len() - 1) \n    } else { \n        input.subrange(space_pos + 1, input.len() as int) \n    };\n    (s, t)\n}\n\nspec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let (s, t) = extract_strings(input);\n    output == t.add(s).push('\\n')\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_output(output@),\n        correct_concatenation(input@, output@),", "vc-code": "{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0582", "language": "verus", "source": "apps", "source_id": "apps_test_4446", "vc-description": "Given n monsters with health points, player and opponent take turns attacking until each monster dies.\nPlayer attacks first with damage a, opponent with damage b. Player gets 1 point for killing a monster.\nPlayer can skip opponent's turn at most k times total. Find maximum points achievable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {\n    n > 0 && a > 0 && b > 0 && k >= 0 && h.len() == n && \n    forall|i: int| 0 <= i < h.len() ==> h[i] > 0\n}\n\nspec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>\n    decreases h.len()\n{\n    if h.len() == 0 {\n        seq![]\n    } else {\n        let h_mod = h[0] % (a + b);\n        let h_final = if h_mod == 0 { a + b } else { h_mod };\n        seq![h_final] + process_health_values(h.drop_first(), a, b)\n    }\n}\n\nspec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {\n    count_killable_helper(sorted_health, a, k, 0, 0)\n}\n\nspec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int\n    decreases sorted_health.len() - index\n{\n    if index >= sorted_health.len() {\n        acc\n    } else {\n        let x = sorted_health[index];\n        if x <= a {\n            count_killable_helper(sorted_health, a, remaining_k, index + 1, acc + 1)\n        } else {\n            let needed_skips = (x + a - 1) / a - 1;\n            if remaining_k >= needed_skips {\n                count_killable_helper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)\n            } else {\n                count_killable_helper(sorted_health, a, remaining_k, index + 1, acc)\n            }\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve_core(n: i8, a: i8, b: i8, k: i8, h: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))\n    ensures 0 <= result as int <= n as int", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0584", "language": "verus", "source": "apps", "source_id": "apps_test_4464", "vc-description": "Given three integers A, B, and C, determine if it's possible to select one or more \npositive multiples of A such that their sum is congruent to C modulo B.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 0 <= c < b\n}\n\nspec fn is_solvable(a: int, b: int, c: int) -> bool {\n    exists|i: int| 1 <= i < b && #[trigger] ((i * (a % b)) % b) == c\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8) -> (result: String)\n    requires \n        valid_input(a as int, b as int, c as int)\n    ensures \n        (result@ == \"YES\"@) <==> is_solvable(a as int, b as int, c as int),\n        (result@ == \"NO\"@) || (result@ == \"YES\"@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0585", "language": "verus", "source": "apps", "source_id": "apps_test_4465", "vc-description": "Calculate the remaining area of a rectangular farm after placing one vertical road\nand one horizontal road, each 1 yard wide, that span the entire width/height.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_farm_dimensions(a: int, b: int) -> bool {\n    a >= 2 && b >= 2 && a <= 100 && b <= 100\n}\n\nspec fn remaining_farm_area(a: int, b: int) -> int\n    recommends valid_farm_dimensions(a, b)\n{\n    a * b - a - b + 1\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n    requires \n        valid_farm_dimensions(a as int, b as int)\n    ensures \n        result as int == remaining_farm_area(a as int, b as int),\n        result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0586", "language": "verus", "source": "apps", "source_id": "apps_test_4466", "vc-description": "Given a seat of width X centimeters, determine the maximum number of people that can sit on it.\nEach person occupies Y centimeters, and there must be at least Z centimeters of gap between \nany two people and between each end of the seat and the nearest person.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, y: int, z: int) -> bool {\n    x >= 1 && y >= 1 && z >= 1 && y + 2 * z <= x\n}\n\nspec fn max_people(x: int, y: int, z: int) -> int\n    recommends valid_input(x, y, z)\n{\n    (x - z) / (y + z)\n}\n\nspec fn valid_solution(x: int, y: int, z: int, result: int) -> bool\n    recommends valid_input(x, y, z)\n{\n    result == max_people(x, y, z) &&\n    result >= 0 &&\n    result * (y + z) <= x - z < (result + 1) * (y + z)\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8, y: i8, z: i8) -> (result: i8)\n    requires valid_input(x as int, y as int, z as int)\n    ensures valid_solution(x as int, y as int, z as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0587", "language": "verus", "source": "apps", "source_id": "apps_test_4469", "vc-description": "Given a shelf, process queries of three types:\n- L id: Add book with index id to the leftmost position\n- R id: Add book with index id to the rightmost position  \n- ? id: Find the minimum number of books to remove from either end to make book id leftmost or rightmost\nFor each ? query, output the minimum number of removals needed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(queries: Seq<(char, int)>) -> bool {\n    &&& queries.len() > 0\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].0 == 'L' || queries[i].0 == 'R' || queries[i].0 == '?')\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].1 > 0)\n    &&& (forall|i: int, j: int| 0 <= i < j < queries.len() && (queries[i].0 == 'L' || queries[i].0 == 'R') && (queries[j].0 == 'L' || queries[j].0 == 'R') ==> queries[i].1 != queries[j].1)\n    &&& (forall|i: int| 0 <= i < queries.len() && queries[i].0 == '?' ==> \n        exists|j: int| 0 <= j < i && (queries[j].0 == 'L' || queries[j].0 == 'R') && queries[j].1 == queries[i].1)\n    &&& (exists|i: int| 0 <= i < queries.len() && queries[i].0 == '?')\n}\n\nspec fn count_query_ops(queries: Seq<(char, int)>) -> int\n    decreases queries.len()\n{\n    if queries.len() == 0 {\n        0\n    } else {\n        let head = queries[0];\n        let tail = queries.subrange(1, queries.len() as int);\n        if head.0 == '?' {\n            1 + count_query_ops(tail)\n        } else {\n            count_query_ops(tail)\n        }\n    }\n}\n\nspec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {\n    &&& results.len() == count_query_ops(queries)\n    &&& (forall|i: int| 0 <= i < results.len() ==> results[i] >= 0)\n    &&& (forall|r_idx: int| #[trigger] results[r_idx] == compute_min_removals(queries, r_idx) ==> 0 <= r_idx < results.len() ==> \n        (exists|q_idx: int| 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n    &&& (forall|q_idx: int| #[trigger] queries[q_idx] == queries[q_idx] ==> 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' ==>\n        (exists|r_idx: int| 0 <= r_idx < results.len() &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n}\n\nstruct BookshelfState {\n    positions: Map<int, int>,\n    head: int,\n    tail: int,\n}\n\nspec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {\n    BookshelfState {\n        positions: Map::empty(),\n        head: 0,\n        tail: 0,\n    }\n}\n\nspec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(queries: Vec<(char, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))\n    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0588", "language": "verus", "source": "apps", "source_id": "apps_test_4470", "vc-description": "Given an integer n, find the minimum number of operations to transform it to 1, or return -1 if impossible.\nAllowed operations: 1) n → n/2 if n divisible by 2, 2) n → 2n/3 if n divisible by 3, 3) n → 4n/5 if n divisible by 5.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn can_reach_one(n: nat) -> bool\n    recommends n > 0\n{\n    only_factors_235(n)\n}\n\nspec fn only_factors_235(n: nat) -> bool\n    recommends n > 0\n{\n    reduce_by_factors_235(n) == 1\n}\n\nspec fn reduce_by_factors_235(n: nat) -> nat\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        1\n    } else if n % 2 == 0 {\n        reduce_by_factors_235(n / 2)\n    } else if n % 3 == 0 {\n        reduce_by_factors_235(n / 3)\n    } else if n % 5 == 0 {\n        reduce_by_factors_235(n / 5)\n    } else {\n        n\n    }\n}\n\nspec fn min_moves_to_one(n: nat) -> nat\n    recommends n > 0 && can_reach_one(n)\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        0\n    } else if n % 2 == 0 {\n        1 + min_moves_to_one(n / 2)\n    } else if n % 3 == 0 {\n        2 + min_moves_to_one(n / 3)\n    } else if n % 5 == 0 {\n        3 + min_moves_to_one(n / 5)\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8) -> (result: i8)\n    requires\n        valid_input(n as nat),\n    ensures\n        result >= -1,\n        result == -1 <==> !can_reach_one(n as nat),\n        result >= 0 ==> can_reach_one(n as nat) && result == min_moves_to_one(n as nat) as i8,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0589", "language": "verus", "source": "apps", "source_id": "apps_test_4476", "vc-description": "Given two positive integers a and b, find the minimum number of moves to transform \na into b using these operations: add any positive odd integer to a, or subtract \nany positive even integer from a. It is guaranteed that b can always be obtained from a.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < input.len() ==> input[i].0 >= 1 && input[i].1 >= 1\n}\n\nspec fn min_moves(a: int, b: int) -> int\n    recommends a >= 1 && b >= 1\n{\n    if a == b {\n        0\n    } else if a < b {\n        if (b - a) % 2 == 1 { 1 } else { 2 }\n    } else {\n        if (a - b) % 2 == 0 { 1 } else { 2 }\n    }\n}\n\nspec fn valid_output(input: Seq<(int, int)>, result: Seq<int>) -> bool {\n    valid_input(input) ==> (\n        result.len() == input.len() &&\n        forall|i: int| 0 <= i < input.len() ==> result[i] == min_moves(input[i].0, input[i].1) &&\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0\n    )\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<(i8, i8)>) -> (result: Vec<i8>)\n    requires valid_input(input@.map(|i, x: (i8, i8)| (x.0 as int, x.1 as int)))\n    ensures valid_output(input@.map(|i, x: (i8, i8)| (x.0 as int, x.1 as int)), result@.map(|i, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0590", "language": "verus", "source": "apps", "source_id": "apps_test_4477", "vc-description": "Given an apartment number x consisting of the same repeated digit, calculate the total number of digits pressed when calling all \"boring\" apartments (apartments with all same digits) in a specific order until apartment x answers. The calling order is: All apartments with digit 1 (1, 11, 111, 1111), then digit 2 (2, 22, 222, 2222), and so on through digit 9.\n\n/* Sum digits for all previous complete digit groups (1-9, 11-99, etc.) */\n\n/* Sum digits for current digit group up to and including x */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_boring_apartment(x: int) -> bool {\n    (x >= 1 && x <= 9) ||\n    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||\n    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||\n    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)\n}\n\nspec fn digit_count(n: int) -> int {\n    if n <= 9 { 1 }\n    else if n <= 99 { 2 }\n    else if n <= 999 { 3 }\n    else { 4 }\n}\n\nspec fn boring_apartment_value(digit: int, length: int) -> int {\n    if length == 1 { digit }\n    else if length == 2 { digit * 11 }\n    else if length == 3 { digit * 111 }\n    else { digit * 1111 }\n}\n\nspec fn total_digits_pressed(x: int) -> int {\n    let digit = if x <= 9 { x } \n                 else if x <= 99 { x / 11 }\n                 else if x <= 999 { x / 111 }\n                 else { x / 1111 };\n    let length = digit_count(x);\n\n    let prev_digits = if digit == 1 { 0 } else { (digit - 1) * (1 + 2 + 3 + 4) };\n\n    let current_digits = (length * (length + 1)) / 2;\n\n    prev_digits + current_digits\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i32) -> (result: i32)\n    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999\n    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && \n            (x as int == 1 ==> result as int == 1) &&\n            (x as int == 22 ==> result as int == 13) &&\n            (x as int == 777 ==> result as int == 66) &&\n            (x as int == 9999 ==> result as int == 90)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0591", "language": "verus", "source": "apps", "source_id": "apps_test_4482", "vc-description": "Given N integers, find the minimum cost to make all integers equal by transforming some of them.\nEach integer can be transformed at most once. The cost of transforming integer x to integer y is (x-y)².", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_squares(p: int, a: Seq<int>) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        (p - a[0]) * (p - a[0]) + sum_squares(p, a.subrange(1, a.len() as int))\n    }\n}\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && n <= 100 && a.len() == n && \n    forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= -100 && #[trigger] a[i] <= 100\n}\n\nspec fn is_optimal_cost(result: int, a: Seq<int>) -> bool {\n    result >= 0 &&\n    exists|p: int| -100 <= p <= 100 && result == sum_squares(p, a) &&\n    forall|p: int| -100 <= p <= 100 ==> result <= sum_squares(p, a)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|_i: int, x: i8| x as int))\n    ensures is_optimal_cost(result as int, a@.map(|_i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0592", "language": "verus", "source": "apps", "source_id": "apps_test_4486", "vc-description": "Given a string s of lowercase English letters, extract all characters at odd-numbered positions\n(using 1-based indexing) and concatenate them into a new string. This corresponds to extracting\ncharacters at even indices in 0-based indexing (positions 0, 2, 4, 6, ...).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] <= 'z'\n}\n\nspec fn expected_length(s: Seq<char>) -> nat {\n    (s.len() + 1) / 2\n}\n\nspec fn correct_extraction(s: Seq<char>, result: Seq<char>) -> bool {\n    result.len() == expected_length(s) &&\n    forall|i: int| 0 <= i < result.len() ==> 0 <= 2*i < s.len() && #[trigger] result[i] == s[2*i] &&\n    forall|i: int| 0 <= i < s.len() && i % 2 == 0 ==> exists|j: int| 0 <= j < result.len() && result[j] == #[trigger] s[i] && j == i / 2\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures correct_extraction(s@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0593", "language": "verus", "source": "apps", "source_id": "apps_test_4487", "vc-description": "Given three strings A, B, and C, determine if they form a word chain.\nA word chain exists if the last character of A equals the first character of B\nand the last character of B equals the first character of C.\nOutput \"YES\" if both conditions are true, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {\n    parts.len() == 3 && parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0\n}\n\nspec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {\n    a.len() > 0 && b.len() > 0 && c.len() > 0 &&\n    a[a.len() - 1] == b[0] && b[b.len() - 1] == c[0]\n}\n\nspec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn expected_result(input: Seq<char>) -> Seq<char> {\n    let stripped = if input.len() > 0 && input[input.len() - 1] == '\\n' {\n        input.subrange(0, input.len() - 1)\n    } else {\n        input\n    };\n    let parts = split_on_spaces(stripped);\n    if valid_parsed_input(parts) {\n        if is_word_chain(parts[0], parts[1], parts[2]) {\n            seq!['Y', 'E', 'S', '\\n']\n        } else {\n            seq!['N', 'O', '\\n']\n        }\n    } else {\n        seq![]\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == expected_result(input@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0594", "language": "verus", "source": "apps", "source_id": "apps_test_4488", "vc-description": "Compare two large positive integers A and B and determine their relative magnitude.\nInput consists of two positive integers on separate lines, each up to 100 digits.\nOutput \"GREATER\" if A > B, \"LESS\" if A < B, or \"EQUAL\" if A = B.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_integer(lines[1])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == '\\n' {\n        split_lines_spec(s.subrange(1, s.len() as int))\n    } else {\n        let next_newline = find_next_newline(s, 0);\n        if next_newline == -1 {\n            seq![s]\n        } else if next_newline >= 0 && next_newline < s.len() && next_newline + 1 <= s.len() {\n            seq![s.subrange(0, next_newline)] + split_lines_spec(s.subrange(next_newline + 1, s.len() as int))\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn find_next_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        -1\n    } else if s[start as int] == '\\n' {\n        start as int\n    } else {\n        find_next_newline(s, start + 1)\n    }\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    parse_int_helper(s, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, pos: nat) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() || s[pos as int] == '\\n' || s[pos as int] == '\\r' {\n        0\n    } else if '0' <= s[pos as int] <= '9' {\n        (s[pos as int] as int - '0' as int) + 10 * parse_int_helper(s, pos + 1)\n    } else {\n        parse_int_helper(s, pos + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures ({\n        let input_seq = input@;\n        valid_input(input_seq) ==> {\n            let lines = split_lines_spec(input_seq);\n            let a = parse_int_spec(lines[0]);\n            let b = parse_int_spec(lines[1]);\n            (result@ == \"LESS\\n\"@) == (a < b) &&\n            (result@ == \"GREATER\\n\"@) == (a > b) &&\n            (result@ == \"EQUAL\\n\"@) == (a == b)\n        }\n    }) && ({\n        let input_seq = input@;\n        !valid_input(input_seq) ==> result@ == \"\"@\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0595", "language": "verus", "source": "apps", "source_id": "apps_test_4489", "vc-description": "Given N blue cards and M red cards with strings, find maximum net earnings.\nWhen a string is announced, earn 1 yen per blue card with that string and\nlose 1 yen per red card with that string. Find the optimal string to maximize earnings.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(cards: Seq<&str>, target: &str) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else if cards[0] == target {\n        1 + count_occurrences(cards.subrange(1, cards.len() as int), target)\n    } else {\n        count_occurrences(cards.subrange(1, cards.len() as int), target)\n    }\n}\n\nspec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>\n    decreases all_strings.len()\n{\n    if all_strings.len() == 0 {\n        Seq::empty()\n    } else {\n        let rest_unique = get_unique_strings(all_strings.subrange(1, all_strings.len() as int));\n        if rest_unique.contains(all_strings[0]) {\n            rest_unique\n        } else {\n            seq![all_strings[0]].add(rest_unique)\n        }\n    }\n}\n\nspec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)\n}\n\nspec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n        current_max\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)\n    }\n}\n\nproof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)\n    ensures count_occurrences(cards, target) >= 0\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n    } else if cards[0] == target {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    } else {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    }\n}\n\nproof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)\n    ensures max_net_earnings(blue_cards, red_cards) >= 0\n{\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, 0, 0);\n}\n\nproof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)\n    requires \n        0 <= index <= unique_blue.len(),\n        current_max >= 0\n    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, index + 1, new_max);\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(blue_cards: Vec<&str>, red_cards: Vec<&str>) -> (result: i8)\n    ensures \n        result >= 0,\n        result as int == max_net_earnings(blue_cards@, red_cards@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0596", "language": "verus", "source": "apps", "source_id": "apps_test_4490", "vc-description": "Given a DNA base represented by a single letter (A, C, G, or T), find its complementary base\naccording to the pairing rules: A pairs with T, T pairs with A, C pairs with G, G pairs with C", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_dna_base(c: char) -> bool {\n    c == 'A' || c == 'T' || c == 'C' || c == 'G'\n}\n\nspec fn dna_complement(c: char) -> char\n    recommends valid_dna_base(c)\n{\n    if c == 'A' { 'T' }\n    else if c == 'T' { 'A' }\n    else if c == 'C' { 'G' }\n    else if c == 'G' { 'C' }\n    else { 'A' } /* default case for spec completeness */\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    choose|i: int| 0 <= i < input.len() && input[i] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\\n' {\n        input.subrange(0, find_newline(input))\n    } else {\n        input\n    };\n    input_line.len() == 1 && valid_dna_base(input_line[0])\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures ({\n        let input_seq = stdin_input@;\n        let input_line = if exists|i: int| 0 <= i < input_seq.len() && input_seq[i] == '\\n' {\n            input_seq.subrange(0, find_newline(input_seq))\n        } else {\n            input_seq\n        };\n        if valid_input(input_seq) {\n            result@ == seq![dna_complement(input_line[0]), '\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0597", "language": "verus", "source": "apps", "source_id": "apps_test_4491", "vc-description": "Given a 2×N grid where each cell contains candies, find the maximum number of candies\nthat can be collected when traveling from top-left to bottom-right. You can only move\nright or down, and you collect all candies from visited cells.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a_1: Seq<int>, a_2: Seq<int>) -> bool {\n    n >= 1 &&\n    a_1.len() == n && a_2.len() == n &&\n    forall|i: int| #![trigger a_1[i], a_2[i]] 0 <= i < n ==> 1 <= a_1[i] <= 100 && 1 <= a_2[i] <= 100\n}\n\nspec fn sum_range(s: Seq<int>, start: int, end: int) -> int\n    decreases end - start when 0 <= start <= end <= s.len() && forall|i: int| #![trigger s[i]] start <= i < end ==> s[i] >= 1\n{\n    if start >= end { \n        0 \n    } else { \n        s[start] + sum_range(s, start + 1, end) \n    }\n}\n\nspec fn is_valid_result(n: int, a_1: Seq<int>, a_2: Seq<int>, result: int) -> bool {\n    valid_input(n, a_1, a_2) &&\n    result >= n + 1 &&\n    result <= (n + 1) * 100 &&\n    exists|i: int| 0 <= i < n && result == sum_range(a_1, 0, i + 1) + sum_range(a_2, i, n) &&\n    forall|i: int| 0 <= i < n ==> result >= sum_range(a_1, 0, i + 1) + sum_range(a_2, i, n)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a_1: Vec<i8>, a_2: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a_1@.map_values(|x: i8| x as int), a_2@.map_values(|x: i8| x as int))\n    ensures is_valid_result(n as int, a_1@.map_values(|x: i8| x as int), a_2@.map_values(|x: i8| x as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0599", "language": "verus", "source": "apps", "source_id": "apps_test_4494", "vc-description": "Given the type of contest held last week (\"ABC\" or \"ARC\"), determine the type \nof contest to be held this week. Contests alternate between these two types.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    ({\n        let s = if input[input.len()-1] == '\\n' { \n            input.subrange(0, input.len() - 1)\n        } else { \n            input\n        };\n        s == \"ABC\"@ || s == \"ARC\"@\n    })\n}\n\nspec fn normalize_input(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    if input[input.len()-1] == '\\n' { \n        input.subrange(0, input.len() - 1)\n    } else { \n        input\n    }\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let s = normalize_input(input);\n    if s == \"ABC\"@ { \"ARC\\n\"@ } else { \"ABC\\n\"@ }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == expected_output(input@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0600", "language": "verus", "source": "apps", "source_id": "apps_test_4495", "vc-description": "Given nonnegative integers a and b (where a ≤ b) and a positive integer x,\ncount how many integers in the range [a, b] inclusive are divisible by x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, x: int) -> bool {\n    a >= 0 && b >= a && x > 0\n}\n\nspec fn count_divisible_in_range(a: int, b: int, x: int) -> int\n    recommends valid_input(a, b, x)\n{\n    if a == 0 {\n        b / x + 1\n    } else {\n        b / x - (a - 1) / x\n    }\n}", "vc-helpers": "", "vc-spec": "fn count_divisible(a: i8, b: i8, x: i8) -> (count: i8)\n    requires \n        valid_input(a as int, b as int, x as int),\n    ensures \n        count as int == count_divisible_in_range(a as int, b as int, x as int),\n        count >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0601", "language": "verus", "source": "apps", "source_id": "apps_test_4496", "vc-description": "Given an integer D representing a December date (22-25), output the corresponding Christmas-related string:\nD=25: \"Christmas\", D=24: \"Christmas Eve\", D=23: \"Christmas Eve Eve\", D=22: \"Christmas Eve Eve Eve\"", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(d: int) -> bool {\n    22 <= d <= 25\n}\n\nspec fn expected_output(d: int) -> Seq<char> {\n    if valid_input(d) {\n        let eve_count = 25 - d;\n        let base_string = seq!['C', 'h', 'r', 'i', 's', 't', 'm', 'a', 's'];\n        if eve_count == 0 {\n            base_string\n        } else {\n            base_string + repeat_eve(eve_count)\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn repeat_eve(count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 {\n        seq![]\n    } else {\n        seq![' ', 'E', 'v', 'e'] + repeat_eve(count - 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(d: i8) -> (result: String)\n    requires valid_input(d as int)\n    ensures result@ == expected_output(d as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0602", "language": "verus", "source": "apps", "source_id": "apps_test_4498", "vc-description": "Given three integer positions a, b, c on a number line and an integer communication range d,\ndetermine if positions a and c can communicate either directly (distance ≤ d) or indirectly\nthrough position b (both a-b and b-c distances ≤ d).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100 && 1 <= d <= 100\n}\n\nspec fn can_communicate(a: int, b: int, c: int, d: int) -> bool {\n    (if a - c >= 0 { a - c } else { c - a }) <= d || \n    (((if a - b >= 0 { a - b } else { b - a }) <= d) && \n     ((if b - c >= 0 { b - c } else { c - b }) <= d))\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: String)\n    requires \n        valid_input(a as int, b as int, c as int, d as int),\n    ensures \n        result@ == seq!['Y', 'e', 's'] <==> can_communicate(a as int, b as int, c as int, d as int),\n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0604", "language": "verus", "source": "apps", "source_id": "apps_test_4502", "vc-description": "Given an integer sequence a of length n, simulate n operations on an initially empty sequence b:\nOperation i: Append a[i] to the end of b, then reverse the entire sequence b\nOutput the final sequence b after all n operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n\n}\n\nspec fn simulate_operations(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        seq![a[0]]\n    } else {\n        let shorter = a.subrange(0, (a.len() - 1) as int);\n        let prev = simulate_operations(shorter);\n        reverse_seq(prev.push(a[(a.len() - 1) as int]))\n    }\n}\n\nspec fn compute_result(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    let n = a.len();\n    let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);\n    let e = Seq::new(n / 2, |i: int| a[2*i + 1]);\n    if n % 2 == 0 {\n        reverse_seq(e).add(o)\n    } else {\n        reverse_seq(o).add(e)\n    }\n}\n\nspec fn reverse_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len() when s.len() > 0\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let rest = s.subrange(1, s.len() as int);\n        reverse_seq(rest).push(s[0])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result.len() == n as int,\n        result@.map(|i: int, x: i8| x as int) == compute_result(a@.map(|i: int, x: i8| x as int)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0605", "language": "verus", "source": "apps", "source_id": "apps_test_4504", "vc-description": "Given an even string S, find the length of the longest even string that can be \nobtained by deleting one or more characters from the end of S. An even string\nis one that can be split into two identical halves.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_even_string(s: Seq<char>) -> bool {\n    s.len() >= 2 && s.len() % 2 == 0 && s.subrange(0, s.len() as int / 2) == s.subrange(s.len() as int / 2, s.len() as int)\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 2 && is_even_string(s)\n}\n\nspec fn valid_solution(s: Seq<char>, result: int) -> bool {\n    2 <= result < s.len() && result % 2 == 0 && is_even_string(s.subrange(0, result))\n}\n\nspec fn is_maximal_solution(s: Seq<char>, result: int) -> bool {\n    valid_solution(s, result) && \n    forall|k: int| result < k < s.len() && k % 2 == 0 ==> !is_even_string(s.subrange(0, k))\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@) &&\n        (exists|k: int| valid_solution(s@, k))\n    ensures \n        valid_solution(s@, result as int) &&\n        is_maximal_solution(s@, result as int)", "vc-code": "{\n    assume(false);\n    2\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0606", "language": "verus", "source": "apps", "source_id": "apps_test_4505", "vc-description": "Given a string S of length 3 containing only characters 'a', 'b', and 'c',\ndetermine if S is a permutation of \"abc\" (i.e., contains exactly one occurrence\neach of 'a', 'b', and 'c'). Return \"Yes\\n\" if it is a permutation, \"No\\n\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    (s.len() == 3 || (s.len() == 4 && s[3] == '\\n')) &&\n    forall|i: int| 0 <= i < (if s.len() == 4 { 3 } else { s.len() as int }) ==> \n        (s[i] == 'a' || s[i] == 'b' || s[i] == 'c')\n}\n\nspec fn get_input_chars(s: Seq<char>) -> Seq<char> {\n    if s.len() == 4 { s.subrange(0, 3) } else { s }\n}\n\nspec fn is_permutation_of_abc(input_chars: Seq<char>) -> bool {\n    input_chars.len() == 3 &&\n    (forall|i: int| 0 <= i < input_chars.len() ==> \n        (input_chars[i] == 'a' || input_chars[i] == 'b' || input_chars[i] == 'c')) &&\n    input_chars[0] != input_chars[1] && \n    input_chars[1] != input_chars[2] && \n    input_chars[0] != input_chars[2]\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        s@.len() >= 3,\n        valid_input(s@),\n    ensures \n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'],\n        result@ == seq!['Y', 'e', 's', '\\n'] <==> is_permutation_of_abc(get_input_chars(s@)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0607", "language": "verus", "source": "apps", "source_id": "apps_test_4508", "vc-description": "Given an undirected tree with n vertices, add the minimum number of edges \nsuch that the shortest path from vertex 1 to any other vertex is at most 2.\nLoops and multiple edges are not allowed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 && edges.len() == n - 1 &&\n    forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1\n}\n\nspec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 ==> forall|v: int| 2 <= v <= n ==> shortest_path_distance(n, edges, 1, v) <= 2\n}\n\nspec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { 0 } else { compute_shortest_path(n, edges, start, end) }\n    } else {\n        -1\n    }\n}\n\nspec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        let adj = build_adjacency_list(n, edges);\n        bfs(adj, n, start, end)\n    } else {\n        -1\n    }\n}\n\nspec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {\n    if n >= 1 {\n        let adj = Seq::new((n + 1) as nat, |i: int| Seq::<int>::empty());\n        add_edges_to_adj_list(adj, edges)\n    } else {\n        Seq::<Seq<int>>::empty()\n    }\n}\n\nspec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>\n    decreases edges.len()\n{\n    if adj.len() >= 1 {\n        if edges.len() == 0 {\n            adj\n        } else {\n            let e = edges[0];\n            if 1 <= e.0 < adj.len() && 1 <= e.1 < adj.len() {\n                let new_adj = adj.update(e.0, adj[e.0].push(e.1)).update(e.1, adj[e.1].push(e.0));\n                add_edges_to_adj_list(new_adj, edges.subrange(1, edges.len() as int))\n            } else {\n                add_edges_to_adj_list(adj, edges.subrange(1, edges.len() as int))\n            }\n        }\n    } else {\n        adj\n    }\n}\n\nspec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {\n    if n >= 1 && adj.len() == n + 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { \n            0 \n        } else if adj[start].contains(end) { \n            1 \n        } else if distance_is_2(adj, start, end) { \n            2 \n        } else { \n            3 \n        }\n    } else {\n        -1\n    }\n}\n\nspec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {\n    if adj.len() > 0 && 0 <= start < adj.len() {\n        exists|neighbor: int| adj[start].contains(neighbor) && 0 <= neighbor < adj.len() && adj[neighbor].contains(end)\n    } else {\n        false\n    }\n}\n\nspec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {\n    valid_input(n, original_edges) ==> num_edges_to_add >= 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, edges: Vec<(i8, i8)>) -> (num_edges_to_add: i8)\n    requires n >= 2,\n             edges.len() == (n - 1) as nat,\n             forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1\n    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),\n            all_vertices_within_distance2(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> num_edges_to_add >= 0", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0608", "language": "verus", "source": "apps", "source_id": "apps_test_4528", "vc-description": "Calculate the number of minutes remaining until New Year (00:00) given the current time in 24-hour format.\nInput is a sequence of (hour, minute) pairs representing current times.\nOutput is the corresponding minutes remaining until midnight for each test case.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(test_cases: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < test_cases.len() ==> \n        #[trigger] test_cases[i].0 >= 0 && \n        test_cases[i].0 < 24 && \n        test_cases[i].1 >= 0 && \n        test_cases[i].1 < 60 && \n        !(test_cases[i].0 == 0 && test_cases[i].1 == 0)\n}\n\nspec fn minutes_until_midnight(h: int, m: int) -> int {\n    1440 - (h * 60 + m)\n}\n\nspec fn valid_output(results: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < results.len() ==> \n        1 <= #[trigger] results[i] && results[i] <= 1439\n}", "vc-helpers": "", "vc-spec": "fn solve(test_cases: Vec<(i8, i8)>) -> (results: Vec<i16>)\n    requires \n        valid_input(test_cases@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))\n    ensures \n        results.len() == test_cases.len(),\n        forall|i: int| 0 <= i < results.len() ==> \n            #[trigger] results[i] as int == minutes_until_midnight(test_cases[i].0 as int, test_cases[i].1 as int),\n        valid_output(results@.map(|i: int, x: i16| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0609", "language": "verus", "source": "apps", "source_id": "apps_test_4534", "vc-description": "Given a non-negative integer k where 0 ≤ k ≤ 33, return the kth row of Pascal's triangle \nas a list of integers. Row indexing starts from 0. In Pascal's triangle, each element \nequals the sum of the two elements directly above it in the previous row.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn binomial(n: int, k: int) -> int\n    decreases n when 0 <= k <= n\n{\n    if k == 0 || k == n { 1 }\n    else if k == 1 { n }\n    else { binomial(n-1, k-1) + binomial(n-1, k) }\n}", "vc-helpers": "", "vc-spec": "fn get_row(k: u8) -> (result: Vec<u8>)\n    requires k <= 33\n    ensures \n        result.len() == k + 1,\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] as int == binomial(k as int, i),\n        forall|i: int| 0 <= i < result.len() ==> result[i] > 0,", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0610", "language": "verus", "source": "apps", "source_id": "apps_test_4538", "vc-description": "Given N points in a 2D plane, count how many points are within distance D from the origin (0,0).\nDistance is measured using Euclidean distance, and we check if distance <= D.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, d: int, points: Seq<(int, int)>) -> bool {\n    n >= 0 && d >= 0 && points.len() >= n\n}\n\nspec fn within_distance(point: (int, int), d: int) -> bool {\n    point.0 * point.0 + point.1 * point.1 <= d * d\n}\n\nspec fn count_points_within_distance(n: int, d: int, points: Seq<(int, int)>) -> int\n    recommends valid_input(n, d, points)\n{\n    points.subrange(0, n).filter(|point: (int, int)| within_distance(point, d)).len() as int\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, d: i8, points: Vec<(i8, i8)>) -> (result: i8)\n    requires \n        valid_input(n as int, d as int, points@.map_values(|p: (i8, i8)| (p.0 as int, p.1 as int))),\n    ensures \n        0 <= result as int <= n as int,\n        result as int == count_points_within_distance(n as int, d as int, points@.map_values(|p: (i8, i8)| (p.0 as int, p.1 as int)))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0611", "language": "verus", "source": "apps", "source_id": "apps_test_4539", "vc-description": "Given an integer N, determine if N is divisible by the sum of its digits (when written in base 10).\nReturn \"Yes\" if N is divisible by the sum of its digits, otherwise return \"No\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_of_digits(n: int) -> int\n  decreases n\n{\n  if n <= 0 {\n    0\n  } else {\n    (n % 10) + sum_of_digits(n / 10)\n  }\n}\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn is_divisible_by_digit_sum(n: int) -> bool {\n  n >= 1 && sum_of_digits(n) > 0 && n % sum_of_digits(n) == 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: &'static str)\n  requires valid_input(n as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0612", "language": "verus", "source": "apps", "source_id": "apps_test_4541", "vc-description": "Given a single lowercase English letter, determine if it is a vowel (a, e, i, o, u) or consonant.\nReturn \"vowel\" if the letter is a vowel, otherwise return \"consonant\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() == 1 && 'a' <= input[0] && input[0] <= 'z'\n}\n\nspec fn is_vowel(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    if is_vowel(input[0]) { seq!['v', 'o', 'w', 'e', 'l'] } else { seq!['c', 'o', 'n', 's', 'o', 'n', 'a', 'n', 't'] }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@),\n    ensures \n        result@ == expected_output(input@),\n        result@ == seq!['v', 'o', 'w', 'e', 'l'] || result@ == seq!['c', 'o', 'n', 's', 'o', 'n', 'a', 'n', 't'],", "vc-code": "{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0613", "language": "verus", "source": "apps", "source_id": "apps_test_4542", "vc-description": "Given a string of stones ('B' for black, 'W' for white), find the minimum number \nof stones to place at either end to make all stones the same color. When placing \na stone, all stones of opposite color between the new stone and the nearest \nexisting stone of the same color are flipped.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'B' || s[i] == 'W'\n}\n\nspec fn count_segments(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        1int\n    } else {\n        count_segments(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] != s[s.len() - 2] { 1int } else { 0int })\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(s@),\n    ensures \n        result >= 0,\n        result as int == count_segments(s@) - 1,\n        result as int <= s.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0614", "language": "verus", "source": "apps", "source_id": "apps_test_4543", "vc-description": "Given two positive integers a and b, determine whether their string concatenation \n(a followed by b) forms a perfect square number. Return \"Yes\" if it's a perfect \nsquare, \"No\" otherwise.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\n\nspec fn is_perfect_square(n: int) -> bool\n  recommends n >= 0\n{\n  exists|sqrt_n: int| sqrt_n >= 0 && #[trigger] (sqrt_n * sqrt_n) == n\n}\n/* Helper functions for string/int conversion - these would need implementation */\nfn int_to_string(n: int) -> (result: String)\n  requires n >= 0\n  ensures result@.len() > 0\n{\n  assume(false);\n  unreached()\n}\n\nfn string_to_int(s: String) -> (result: int)\n  requires s@.len() > 0\n  ensures result >= 0\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: String)\n  requires a as int >= 1 && a as int <= 100,\n           b as int >= 1 && b as int <= 100\n  ensures result@ == \"Yes\"@ || result@ == \"No\"@", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0615", "language": "verus", "source": "apps", "source_id": "apps_test_4545", "vc-description": "Given an N×N grid with N² total squares where A squares are painted white,\ndetermine how many squares are painted black (N² - A).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: int) -> bool {\n    1 <= n <= 100 && 0 <= a <= n * n\n}\n\nspec fn black_squares(n: int, a: int) -> int\n    recommends valid_input(n, a)\n{\n    n * n - a\n}\n\nspec fn valid_output(n: int, a: int, result: int) -> bool\n    recommends valid_input(n, a)\n{\n    result == black_squares(n, a) && result >= 0\n}", "vc-helpers": "", "vc-spec": "fn calculate_black_squares(n: i8, a: i8) -> (black_squares: i8)\n    requires valid_input(n as int, a as int)\n    ensures valid_output(n as int, a as int, black_squares as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0617", "language": "verus", "source": "apps", "source_id": "apps_test_4547", "vc-description": "Given a two-digit integer N (10 ≤ N ≤ 99), determine whether the digit 9 appears \nin the decimal representation of N. Return \"Yes\" if 9 appears, \"No\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn clean_input(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        s\n    } else if s[s.len() - 1] == '\\n' || s[s.len() - 1] == '\\r' || s[s.len() - 1] == ' ' { \n        clean_input(s.subrange(0, s.len() - 1))\n    } else { \n        s\n    }\n}\n\nspec fn contains_digit_nine(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == '9'\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures \n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'],\n        result@ == seq!['Y', 'e', 's', '\\n'] <==> contains_digit_nine(clean_input(stdin_input@)),\n        result@ == seq!['N', 'o', '\\n'] <==> !contains_digit_nine(clean_input(stdin_input@))", "vc-code": "{\n    assume(false);\n    \"No\\n\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0619", "language": "verus", "source": "apps", "source_id": "apps_test_4551", "vc-description": "Given four integer weights A, B, C, D, determine the direction a balance scale tips when:\n- Left pan contains masses with weights A and B  \n- Right pan contains masses with weights C and D\nCompare the total weights on each side and output \"Left\", \"Right\", or \"Balanced\"", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_parseable(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4\n}\n\nspec fn all_parts_are_integers(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] <= '9') || (i == 0 && s[i] == '-'))\n}\n\nspec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 && \n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3]) &&\n    string_to_int_pure(parts[0]) == a &&\n    string_to_int_pure(parts[1]) == b &&\n    string_to_int_pure(parts[2]) == c &&\n    string_to_int_pure(parts[3]) == d\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    split_string_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i < 0 || i > s.len() {\n        acc\n    } else if i == s.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\t' {\n        if current.len() > 0 {\n            split_string_helper(s, i + 1, seq![], acc.push(current))\n        } else {\n            split_string_helper(s, i + 1, seq![], acc)\n        }\n    } else {\n        split_string_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if !is_valid_integer(s) {\n        0\n    } else if s.len() > 0 && s[0] == '-' {\n        -string_to_int_helper_unsigned(s, 1, 0)\n    } else {\n        string_to_int_helper_unsigned(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i\n{\n    if i < 0 || i >= s.len() {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        string_to_int_helper_unsigned(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    ensures \n        (forall|a: int, b: int, c: int, d: int| \n            valid_parse(input@, a, b, c, d) ==> \n            ((result@ == \"Left\\n\"@) <==> (a + b > c + d)) &&\n            ((result@ == \"Right\\n\"@) <==> (a + b < c + d)) &&\n            ((result@ == \"Balanced\\n\"@) <==> (a + b == c + d))) &&\n        (valid_parseable(input@) && all_parts_are_integers(input@) ==> \n            (result@ == \"Left\\n\"@ || result@ == \"Right\\n\"@ || result@ == \"Balanced\\n\"@)) &&\n        ((!valid_parseable(input@) || !all_parts_are_integers(input@)) ==> result@ == \"\"@)", "vc-code": "{\n    assume(false);\n    \"\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0620", "language": "verus", "source": "apps", "source_id": "apps_test_4553", "vc-description": "Given integers A and B, and a string S of length A+B+1, determine if S follows \nthe postal code format where the character at position A+1 (1-indexed) is a hyphen '-'\nand all other characters are digits 0-9.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_postal_code(a: int, b: int, s: Seq<char>) -> bool\n    recommends a >= 1 && b >= 1 && a <= 5 && b <= 5,\n              s.len() == a + b + 1,\n              forall|i: int| 0 <= i < s.len() ==> (s[i] == '-' || ('0' <= s[i] <= '9'))\n{\n    s[a] == '-' && forall|i: int| 0 <= i < s.len() && i != a ==> s[i] != '-'\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, s: Vec<char>) -> (result: Vec<char>)\n    requires a as int >= 1 && b as int >= 1,\n             a as int <= 5 && b as int <= 5,\n             s@.len() == a as int + b as int + 1,\n             forall|i: int| 0 <= i < s@.len() ==> (s@[i] == '-' || ('0' <= s@[i] <= '9'))\n    ensures result@.len() >= 2,\n            (result@ =~= seq!['Y', 'e', 's']) || (result@ =~= seq!['N', 'o']),\n            (result@ =~= seq!['Y', 'e', 's']) <==> valid_postal_code(a as int, b as int, s@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0621", "language": "verus", "source": "apps", "source_id": "apps_test_4554", "vc-description": "Given two rectangles with width W, where Rectangle 1 spans horizontally [a, a+W] \nand Rectangle 2 spans horizontally [b, b+W], find the minimum horizontal distance \nRectangle 2 must be moved so that the two rectangles connect (overlap or touch).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(w: int, a: int, b: int) -> bool {\n    w >= 1 && a >= 1 && b >= 1\n}\n\nspec fn abs_diff(x: int, y: int) -> int {\n    if x >= y { x - y } else { y - x }\n}\n\nspec fn min_move_distance(w: int, a: int, b: int) -> int\n    recommends valid_input(w, a, b)\n{\n    let distance = abs_diff(a, b);\n    if distance <= w { 0 }\n    else { distance - w }\n}\n\nspec fn rectangles_connect(w: int, a: int, b: int) -> bool\n    recommends valid_input(w, a, b)\n{\n    abs_diff(a, b) <= w\n}", "vc-helpers": "", "vc-spec": "fn solve(w: i8, a: i8, b: i8) -> (result: i8)\n    requires valid_input(w as int, a as int, b as int)\n    ensures \n        result as int == min_move_distance(w as int, a as int, b as int) &&\n        result >= 0 &&\n        (rectangles_connect(w as int, a as int, b as int) <==> result == 0)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0622", "language": "verus", "source": "apps", "source_id": "apps_test_4556", "vc-description": "Given a contest name in the format \"AtCoder s Contest\" where s is a string of length 1 to 100 characters \nstarting with an uppercase English letter followed by lowercase English letters, output the abbreviation \"AxC\" \nwhere x is the first character of s.\n\n/* Minimum: \"AtCoder X Contest\\n\" */\n\n/* Input ends with newline */\n\n/* Middle word is non-empty */\n\n/* First char is uppercase */\n\n/* Rest are lowercase */\n\n/* \"AxC\\n\" format */\n\n/* Second char is first char of middle word */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& input.len() >= 18\n    &&& input[input.len() as int - 1] == '\\n'\n    &&& input.subrange(0, 7) == seq!['A', 't', 'C', 'o', 'd', 'e', 'r']\n    &&& input[7] == ' '\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        input.subrange(space_pos + 1, space_pos + 8) == seq!['C', 'o', 'n', 't', 'e', 's', 't'] &&\n        space_pos + 8 == input.len() - 1\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        space_pos > 8 &&\n        'A' <= input[8] <= 'Z' &&\n        forall|k: int| 9 <= k < space_pos ==> 'a' <= #[trigger] input.index(k) <= 'z'\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& result.len() == 4\n    &&& result[0] == 'A'\n    &&& result[2] == 'C'\n    &&& result[3] == '\\n'\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        result[1] == input[8]\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(input@, result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0623", "language": "verus", "source": "apps", "source_id": "apps_test_4557", "vc-description": "Given A animals that are definitely cats and B animals of unknown type (could be cats or dogs),\ndetermine if it's possible to have exactly X cats in total among the A + B animals.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, x: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= x <= 200\n}\n\nspec fn can_have_exactly_cats(a: int, b: int, x: int) -> bool {\n    a <= x <= a + b\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, x: i8) -> (result: String)\n    requires valid_input(a as int, b as int, x as int)\n    ensures result@ =~= seq!['Y', 'E', 'S'] <==> can_have_exactly_cats(a as int, b as int, x as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0624", "language": "verus", "source": "apps", "source_id": "apps_test_4560", "vc-description": "Given A 1-yen coins and unlimited 500-yen coins, determine if you can pay exactly N yen.\nReturn \"Yes\" if exact payment is possible, \"No\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int) -> bool {\n    1 <= n <= 10000 && 0 <= a <= 1000\n}\n\nspec fn can_pay_exactly(n: int, a: int) -> bool {\n    n % 500 <= a\n}\n\nspec fn valid_output(result: String) -> bool {\n    result@ == \"Yes\"@ || result@ == \"No\"@\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8) -> (result: String)\n    requires \n        valid_input(n as int, a as int)\n    ensures \n        valid_output(result) &&\n        ((result@ == \"Yes\"@) <==> can_pay_exactly(n as int, a as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0625", "language": "verus", "source": "apps", "source_id": "apps_test_4561", "vc-description": "Given three integers X, A, and B where X is the maximum number of days past \nbest-by date that won't cause stomachache, A is the number of days before \nbest-by date when food was bought, and B is the number of days after purchase \nwhen food was eaten. Determine if eating the food results in \"delicious\", \n\"safe\", or \"dangerous\" outcome.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_outcome(outcome: &str) -> bool {\n    outcome == \"delicious\" || outcome == \"safe\" || outcome == \"dangerous\"\n}\n\nspec fn days_past_best_by(a: int, b: int) -> int {\n    b - a\n}\n\nspec fn expected_outcome(x: int, a: int, b: int) -> &'static str {\n    let days_past = days_past_best_by(a, b);\n    if days_past <= 0 {\n        \"delicious\"\n    } else if days_past <= x {\n        \"safe\"\n    } else {\n        \"dangerous\"\n    }\n}", "vc-helpers": "", "vc-spec": "fn determine_food_safety(x: i8, a: i8, b: i8) -> (outcome: &'static str)\n    requires \n        x as int >= 0,\n    ensures \n        outcome == expected_outcome(x as int, a as int, b as int),\n        valid_outcome(outcome),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0626", "language": "verus", "source": "apps", "source_id": "apps_test_4567", "vc-description": "Given N questions with scores, find the maximum possible sum of a subset \nsuch that the sum is NOT a multiple of 10. If no such sum exists, return 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(scores: Seq<int>) -> bool {\n    scores.len() > 0 && scores.len() <= 100 &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 1 && #[trigger] scores[i] <= 100\n}\n\nspec fn sum_seq(scores: Seq<int>) -> int\n    decreases scores.len()\n{\n    if scores.len() == 0 {\n        0\n    } else {\n        scores[0] + sum_seq(scores.subrange(1, scores.len() as int))\n    }\n}\n\nspec fn all_multiples_of_10(scores: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] % 10 == 0\n}\n\nspec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {\n    scores.contains(value) && \n    value % 10 != 0 &&\n    forall|x: int| #[trigger] scores.contains(x) && x % 10 != 0 ==> value <= x\n}\n\nspec fn correct_result(scores: Seq<int>, result: int) -> bool {\n    let total_sum = sum_seq(scores);\n    if total_sum % 10 != 0 {\n        result == total_sum\n    } else if all_multiples_of_10(scores) {\n        result == 0\n    } else {\n        exists|smallest_non_multiple: int| \n            is_smallest_non_multiple(scores, smallest_non_multiple) &&\n            result == total_sum - smallest_non_multiple\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(scores: Vec<i8>) -> (result: i8)\n    requires valid_input(scores@.map(|i, x| x as int))\n    ensures correct_result(scores@.map(|i, x| x as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0627", "language": "verus", "source": "apps", "source_id": "apps_test_4569", "vc-description": "Given today's weather from a 3-day repeating cycle (Sunny → Cloudy → Rainy → Sunny → ...), determine tomorrow's weather.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_weather(weather: Seq<char>) -> bool {\n    weather == \"Sunny\"@ || weather == \"Cloudy\"@ || weather == \"Rainy\"@\n}\n\nspec fn trim_newline(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        input.subrange(0, input.len() as int - 1)\n    } else {\n        input\n    }\n}\n\nspec fn next_weather(weather: Seq<char>) -> Seq<char>\n    recommends valid_weather(weather)\n{\n    if weather == \"Sunny\"@ { \"Cloudy\"@ }\n    else if weather == \"Cloudy\"@ { \"Rainy\"@ }\n    else { \"Sunny\"@ }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    ensures ({\n        let trimmed = trim_newline(input@);\n        if valid_weather(trimmed) {\n            result@ == next_weather(trimmed) + seq!['\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0628", "language": "verus", "source": "apps", "source_id": "apps_test_4570", "vc-description": "Given two parking fee plans:\n- Plan 1: A yen per hour (total: A×N yen for N hours)\n- Plan 2: B yen flat rate (regardless of duration)\nFind the minimum cost to park for N hours.\nInput: Three integers N, A, B where N is parking duration in hours (1 ≤ N ≤ 20),\nA is hourly rate for Plan 1 (1 ≤ A ≤ 100), and B is flat rate for Plan 2 (1 ≤ B ≤ 2000).\nOutput: The minimum parking fee (integer)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true /* Simplified for now */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2'], seq!['3']] /* Simplified for now */\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    if s.len() > 0 && s[0] == '1' { 1 }\n    else if s.len() > 0 && s[0] == '2' { 2 }\n    else if s.len() > 0 && s[0] == '3' { 3 }\n    else { 0 }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else { seq!['0'] }\n}\n\nspec fn min_parking_cost(n: int, a: int, b: int) -> int {\n    let plan1_cost = n * a;\n    let plan2_cost = b;\n    if plan1_cost <= plan2_cost { plan1_cost } else { plan2_cost }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        ({\n            let parts = split_string_func(input);\n            let n = string_to_int_func(parts[0]);\n            let a = string_to_int_func(parts[1]);\n            let b = string_to_int_func(parts[2]);\n            result == int_to_string_func(min_parking_cost(n, a, b)) + seq!['\\n']\n        })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0629", "language": "verus", "source": "apps", "source_id": "apps_test_4571", "vc-description": "Given N test cases where M are \"hard\" (1900ms each, 1/2 success probability) \nand (N-M) are \"easy\" (100ms each, always succeed), find the expected total \nexecution time across all submissions until one submission succeeds.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    1 <= n <= 100 && 1 <= m <= n && m <= 5\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp when exp >= 0\n{\n    if exp <= 0 { 1 } else { base * power(base, exp - 1) }\n}\n\nspec fn expected_time(n: int, m: int) -> int {\n    (1900 * m + 100 * (n - m)) * power(2, m)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: i8)\n    requires valid_input(n as int, m as int)\n    ensures result as int == expected_time(n as int, m as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0630", "language": "verus", "source": "apps", "source_id": "apps_test_4575", "vc-description": "Given N participants in a D-day training camp, where participant i eats chocolate on days 1, A_i+1, 2×A_i+1, 3×A_i+1, etc. \n(i.e., day 1 and then every A_i days thereafter). At the end of the camp, X chocolate pieces remain. \nFind the total number of chocolate pieces prepared initially.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_str(input, '\\n');\n    lines.len() >= 2 &&\n    parse_int(lines[0]) >= 1 &&\n    {\n        let n = parse_int(lines[0]);\n        let second_line_parts = split_str(lines[1], ' ');\n        second_line_parts.len() >= 2 &&\n        parse_int(second_line_parts[0]) >= 1 &&\n        parse_int(second_line_parts[1]) >= 0 &&\n        lines.len() >= 2 + n &&\n        forall|i: int| 0 <= i < n ==> #[trigger] parse_int(lines[2 + i]) >= 1\n    }\n}\n\nspec fn compute_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_str(input, '\\n');\n    let n = parse_int(lines[0]);\n    let second_line_parts = split_str(lines[1], ' ');\n    let d = parse_int(second_line_parts[0]);\n    let x = parse_int(second_line_parts[1]);\n    let total_eaten = sum_eaten_for_participants(lines, d, n);\n    int_to_string(x + total_eaten)\n}\n\nspec fn sum_eaten_for_participants(lines: Seq<Seq<char>>, d: int, count: int) -> int \n    recommends lines.len() >= 2 + count && d >= 1 && count >= 0\n    decreases count\n    when count >= 0\n{\n    if count == 0 {\n        0\n    } else {\n        let a = parse_int(lines[2 + count - 1]);\n        let eaten = if a > 0 { (d + a - 1) / a } else { 0 };\n        eaten + sum_eaten_for_participants(lines, d, count - 1)\n    }\n}\n\nspec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_helper(s, delimiter, 0, 0, seq![])\n    }\n}\n\nspec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= start <= current <= s.len()\n    decreases s.len() - current\n    when 0 <= current <= s.len()\n{\n    if current == s.len() {\n        if start == current {\n            acc\n        } else {\n            acc.push(s.subrange(start, current))\n        }\n    } else if s[current] == delimiter {\n        split_helper(s, delimiter, current + 1, current + 1, acc.push(s.subrange(start, current)))\n    } else {\n        split_helper(s, delimiter, start, current + 1, acc)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    recommends 0 <= index <= s.len()\n    decreases s.len() - index\n    when 0 <= index <= s.len()\n{\n    if index == s.len() {\n        acc\n    } else if '0' <= s[index] <= '9' {\n        parse_int_helper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n < 10 {\n        seq![(n + '0' as int) as char]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@ == compute_expected_result(input@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0631", "language": "verus", "source": "apps", "source_id": "apps_test_4579", "vc-description": "Given N strings, count the number of distinct strings.\nInput: A sequence of strings (length >= 1)\nOutput: Integer representing the count of distinct strings", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn distinct_strings(strings: Seq<String>) -> Set<String> {\n    Set::new(|s: String| exists|i: int| 0 <= i < strings.len() && strings[i] == s)\n}\n\nspec fn valid_input(strings: Seq<String>) -> bool {\n    strings.len() >= 1\n}", "vc-helpers": "", "vc-spec": "fn solve(strings: Vec<String>) -> (count: i8)\n    requires \n        valid_input(strings@)\n    ensures \n        count as int >= 1,\n        count as int <= strings@.len(),\n        count as int == distinct_strings(strings@).len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0632", "language": "verus", "source": "apps", "source_id": "apps_test_4581", "vc-description": "Calculate the price of a bowl of ramen based on selected toppings.\nBase price is 700 yen, each topping ('o') adds 100 yen.\nInput is a 3-character string with 'o' (included) or 'x' (not included).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'o' || s[i] == 'x'\n}\n\nspec fn count_o(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == 'o' { 1int } else { 0int }) + count_o(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn calculate_price(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    count_o(s) * 100int + 700int\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        int_to_string_helper_spec(n, seq![])\n    }\n}\n\nspec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n\n    when n >= 0\n{\n    if n == 0 {\n        acc\n    } else {\n        int_to_string_helper_spec(n / 10, seq![((n % 10) + 48) as char] + acc)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@)\n    ensures \n        result@ == int_to_string_spec(calculate_price(s@)) + seq!['\\n'],\n        calculate_price(s@) >= 700", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0633", "language": "verus", "source": "apps", "source_id": "apps_test_4582", "vc-description": "Given two characters representing AtCoDeer's honesty status and claim about TopCoDeer,\ndetermine whether TopCoDeer is actually honest or dishonest.\nAn honest player tells the truth, a dishonest player lies.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 3 &&\n    input[1] == ' ' &&\n    (input[0] == 'H' || input[0] == 'D') &&\n    (input[2] == 'H' || input[2] == 'D') &&\n    (input.len() == 3 || (input.len() > 3 && input[3] == '\\n'))\n}\n\nspec fn correct_output(input: Seq<char>) -> Seq<char> {\n    if (input[0] == 'H' && input[2] == 'H') || (input[0] == 'D' && input[2] == 'D') {\n        seq!['H', '\\n']\n    } else {\n        seq!['D', '\\n']\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == correct_output(input@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0634", "language": "verus", "source": "apps", "source_id": "apps_test_4583", "vc-description": "Given a 4-digit string ABCD, find operators op1, op2, op3 (each + or -) such that\nA op1 B op2 C op3 D = 7. Return the complete equation as \"A op1 B op2 C op3 D=7\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() == 5 && input.subrange(0, 4).len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> ('0' <= #[trigger] input[i] <= '9')) &&\n    input[4] == '\\n'\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as int) - ('0' as int)\n}\n\nspec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {\n    let b_val = if op1 == '+' { b } else { -b };\n    let c_val = if op2 == '+' { c } else { -c };\n    let d_val = if op3 == '+' { d } else { -d };\n    a + b_val + c_val + d_val\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        exists|op1: char, op2: char, op3: char| \n            (op1 == '+' || op1 == '-') &&\n            (op2 == '+' || op2 == '-') &&\n            (op3 == '+' || op3 == '-') &&\n            evaluate_expression(a, b, c, d, op1, op2, op3) == 7\n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& result.len() == 10 \n    &&& result.subrange(7, 9) =~= seq!['=', '7']\n    &&& result[9] == '\\n'\n    &&& result[0] == input[0] && result[2] == input[1] \n    &&& result[4] == input[2] && result[6] == input[3]\n    &&& (result[1] == '+' || result[1] == '-')\n    &&& (result[3] == '+' || result[3] == '-')\n    &&& (result[5] == '+' || result[5] == '-')\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        evaluate_expression(a, b, c, d, result[1], result[3], result[5]) == 7\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@),\n        solution_exists(input@),\n    ensures valid_output(result@, input@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0635", "language": "verus", "source": "apps", "source_id": "apps_test_4584", "vc-description": "Given N company members with ID numbers 1 to N, where each member (except member 1) has exactly one immediate boss with a smaller ID number.\nFor member i (where i > 1), their immediate boss is member A_i. Count the number of immediate subordinates for each member.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, aa: Seq<int>) -> bool {\n    n >= 2 &&\n    aa.len() == n - 1 &&\n    forall|i: int| 0 <= i < aa.len() ==> #[trigger] aa[i] >= 1 && #[trigger] aa[i] < i + 2\n}\n\nspec fn subordinate_count(aa: Seq<int>, boss_id: int) -> int {\n    Set::new(|j: int| 0 <= j < aa.len() && aa[j] == boss_id).len() as int\n}\n\nspec fn valid_output(n: int, aa: Seq<int>, result: Seq<int>) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0 &&\n    forall|i: int| 0 <= i < n ==> #[trigger] result[i] == subordinate_count(aa, i + 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, aa: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(n as int, aa@.map(|i, x| x as int))\n    ensures valid_output(n as int, aa@.map(|i, x| x as int), result@.map(|i, x| x as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0636", "language": "verus", "source": "apps", "source_id": "apps_test_4585", "vc-description": "Find the minimum time needed for a kangaroo to reach position X on a number line.\nThe kangaroo starts at position 0 at time 0. At each time step i (i = 1, 2, 3, ...),\nthe kangaroo can stay at current position or jump exactly i units left or right.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int) -> bool {\n    x >= 1\n}\n\nspec fn triangular_number(n: int) -> int\n    recommends n >= 0\n{\n    n * (n + 1) / 2\n}\n\nspec fn is_minimal_time(t: int, x: int) -> bool\n    recommends x >= 1\n{\n    t >= 1 && \n    triangular_number(t) >= x &&\n    (t == 1 || triangular_number(t - 1) < x)\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8) -> (result: i8)\n    requires valid_input(x as int)\n    ensures is_minimal_time(result as int, x as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0637", "language": "verus", "source": "apps", "source_id": "apps_test_4586", "vc-description": "Given a 4-digit integer N, determine if it is \"good\". \nA 4-digit integer is \"good\" if it contains three or more consecutive identical digits.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1000 <= n <= 9999\n}\n\nspec fn extract_digits(n: int) -> (int, int, int, int) {\n    let d1 = n / 1000;\n    let d2 = (n / 100) % 10;\n    let d3 = (n / 10) % 10;\n    let d4 = n % 10;\n    (d1, d2, d3, d4)\n}\n\nspec fn is_good(n: int) -> bool {\n    let (d1, d2, d3, d4) = extract_digits(n);\n    (d1 == d2 && d2 == d3) || (d2 == d3 && d3 == d4)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: bool)\n    requires \n        valid_input(n as int),\n    ensures \n        result <==> is_good(n as int),", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0638", "language": "verus", "source": "apps", "source_id": "apps_test_4588", "vc-description": "Given two hexadecimal digits X and Y (each being one of A, B, C, D, E, or F representing values 10, 11, 12, 13, 14, 15 respectively), \ncompare their values and output the comparison result: \"<\" if X < Y, \">\" if X > Y, \"=\" if X = Y.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    (input.len() == 3 && input[1] == ' ') || \n    (input.len() == 4 && input[1] == ' ' && input[3] == '\\n')\n}\n\nspec fn valid_hex_digit(c: char) -> bool {\n    c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F'\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() >= 3 &&\n    valid_input(input) &&\n    valid_hex_digit(input[0]) &&\n    valid_hex_digit(input[2])\n}\n\nspec fn correct_comparison(x: char, y: char, result: Seq<char>) -> bool {\n    (result == seq!['<', '\\n'] || result == seq!['>', '\\n'] || result == seq!['=', '\\n']) &&\n    (((x as int) < (y as int)) <==> (result == seq!['<', '\\n'])) &&\n    (((x as int) > (y as int)) <==> (result == seq!['>', '\\n'])) &&\n    (((x as int) == (y as int)) <==> (result == seq!['=', '\\n']))\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input_format(stdin_input@)\n    ensures correct_comparison(stdin_input@[0], stdin_input@[2], result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0639", "language": "verus", "source": "apps", "source_id": "apps_test_4594", "vc-description": "Given N mochi with diameters, find the maximum number of layers in a kagami mochi.\nA kagami mochi is a stack where each layer has a strictly smaller diameter than the layer below it.\nThis is equivalent to counting the number of distinct diameters in the input.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(diameters: Seq<int>) -> bool {\n    diameters.len() > 0 && forall|i: int| 0 <= i < diameters.len() ==> diameters[i] > 0\n}\n\nspec fn num_distinct(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.subrange(1, s.len() as int).contains(s[0]) {\n        num_distinct(s.subrange(1, s.len() as int))\n    } else {\n        1 + num_distinct(s.subrange(1, s.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(diameters: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(diameters@.map(|i, x| x as int)),\n    ensures \n        result as int == num_distinct(diameters@.map(|i, x| x as int)),\n        result as int >= 1,\n        result as int <= diameters@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0641", "language": "verus", "source": "apps", "source_id": "apps_test_4603", "vc-description": "Given costs of ordinary and unlimited tickets for train and bus travel,\nfind the minimum total fare by choosing the cheaper option for each mode.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= c <= 1000 && 1 <= d <= 1000\n}\n\nspec fn min_total_fare(a: int, b: int, c: int, d: int) -> int {\n    (if a < b { a } else { b }) + (if c < d { c } else { d })\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n    requires valid_input(a as int, b as int, c as int, d as int)\n    ensures result as int == min_total_fare(a as int, b as int, c as int, d as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0642", "language": "verus", "source": "apps", "source_id": "apps_test_4605", "vc-description": "Find the sum of all integers i where 1 ≤ i ≤ N and the sum of digits of i (in base 10) is between A and B inclusive.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int) -> bool {\n    n >= 1 && a >= 1 && a <= b && b <= 36\n}\n\nspec fn digit_sum(n: int) -> int \n    decreases n\n{\n    if n <= 0 { 0 }\n    else { (n % 10) + digit_sum(n / 10) }\n}\n\nspec fn sum_in_range(n: int, a: int, b: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 }\n    else if a <= digit_sum(n) && digit_sum(n) <= b { \n        n + sum_in_range(n - 1, a, b) \n    }\n    else { \n        sum_in_range(n - 1, a, b) \n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: i8, b: i8) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int)\n    ensures \n        result as int == sum_in_range(n as int, a as int, b as int) &&\n        result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0643", "language": "verus", "source": "apps", "source_id": "apps_test_4606", "vc-description": "Given an integer N where 100 ≤ N ≤ 999, return the string \"ABC\" concatenated with the string representation of N.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    100 <= n <= 999\n}\n\nspec fn valid_output(n: int, result: Seq<char>) -> bool\n    recommends valid_input(n)\n{\n    result.len() == 6 && result.subrange(0, 3) == seq!['A', 'B', 'C'] && result.subrange(3, result.len() as int) == int_to_string(n)\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as u8 + n as u8) as char]\n    } else {\n        int_to_string(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<char>)\n    requires valid_input(n as int)\n    ensures valid_output(n as int, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0644", "language": "verus", "source": "apps", "source_id": "apps_test_4607", "vc-description": "Count the number of \"Takahashi\" dates from 2018-1-1 through 2018-a-b (inclusive).\nA Takahashi date is one where the month and day numbers are equal (e.g., 1-1, 2-2, 3-3, etc.).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    1 <= a <= 12 && 1 <= b <= 31\n}\n\nspec fn takahashi_count(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n    if a > b { a - 1 } else { a }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures \n        result as int == takahashi_count(a as int, b as int) &&\n        (a > b ==> result as int == a as int - 1) &&\n        (a <= b ==> result as int == a as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0646", "language": "verus", "source": "apps", "source_id": "apps_test_4614", "vc-description": "Given three integers A, B, and C where exactly two are equal and one is different,\nfind the integer that is different from the other two.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn contains_three_space_separated_integers(input: Seq<char>) -> bool {\n    exists|i: int, j: int, k: int| (0 <= i < j < k <= input.len() &&\n    is_valid_integer_substring(input, 0, i) &&\n    input[i] == ' ' &&\n    is_valid_integer_substring(input, i+1, j) &&\n    input[j] == ' ' &&\n    is_valid_integer_substring(input, j+1, k) &&\n    (k == input.len() || input[k] == '\\n'))\n}\n\nspec fn exactly_two_are_equal(input: Seq<char>) -> bool {\n    let nums = parse_three_numbers(input);\n    (nums.0 == nums.1 && nums.0 != nums.2) ||\n    (nums.0 == nums.2 && nums.0 != nums.1) ||\n    (nums.1 == nums.2 && nums.1 != nums.0)\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    if s.len() == 0 { false }\n    else if s.len() == 1 && s[0] == '0' { true }\n    else if s.len() > 0 && s[0] == '-' { \n        s.len() > 1 && is_digit_sequence(s.subrange(1, s.len() as int)) && s[1] != '0'\n    }\n    else { is_digit_sequence(s) && s[0] != '0' }\n}\n\nspec fn is_digit_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool {\n    if start == end { false }\n    else {\n        let substr = s.subrange(start, end);\n        is_valid_integer_string(substr)\n    }\n}\n\nspec fn find_different_number(input: Seq<char>) -> Seq<char> {\n    let nums = parse_three_numbers(input);\n    let different = if nums.0 == nums.1 { nums.2 }\n                    else if nums.0 == nums.2 { nums.1 }\n                    else { nums.0 };\n    int_to_string_pure(different)\n}\nspec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) {\n    (0, 0, 0) /* placeholder for parsing logic */\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char> {\n    Seq::<char>::new(1 as nat, |i: int| '0') /* placeholder for conversion logic */\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        input@.len() > 0,\n        contains_three_space_separated_integers(input@),\n        exactly_two_are_equal(input@),\n    ensures\n        result@.len() > 0,\n        is_valid_integer_string(result@),\n        result@ == find_different_number(input@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0647", "language": "verus", "source": "apps", "source_id": "apps_test_4615", "vc-description": "Find the sugar water mixture with maximum density given constraints on water and sugar operations.\nOperations: add 100A or 100B grams water, add C or D grams sugar.\nE grams sugar can dissolve per 100 grams water. Beaker capacity is F grams.\nMaximize density = (100 × sugar_mass) / (water_mass + sugar_mass).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    1 <= a < b <= 30 &&\n    1 <= c < d <= 30 &&\n    1 <= e <= 100 &&\n    100 * a <= f <= 3000\n}\n\nspec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {\n    total_mass > 0 && sugar_mass >= 0 &&\n    total_mass <= f &&\n    sugar_mass <= total_mass\n}\n\nspec fn density(total_mass: int, sugar_mass: int) -> int\n    recommends total_mass >= 0 && sugar_mass >= 0\n{\n    if total_mass > 0 { (100 * sugar_mass) / total_mass } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)\n    ensures ({\n        let (total_mass, sugar_mass) = result;\n        valid_solution(a as int, b as int, c as int, d as int, e as int, f as int, total_mass as int, sugar_mass as int) &&\n        total_mass as int >= 0 && sugar_mass as int >= 0 &&\n        total_mass as int <= f as int &&\n        sugar_mass as int <= total_mass as int &&\n        (exists|water_units: int| water_units > 0 && total_mass as int == #[trigger] (water_units * 100) + sugar_mass as int) &&\n        (exists|water_units: int| water_units > 0 && sugar_mass as int <= #[trigger] (water_units * e as int)) &&\n        (exists|i1: int, j1: int, i2: int, j2: int| \n            i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&\n            i1 <= 30int / a as int && j1 <= 30int / b as int &&\n            i2 <= 3000int / c as int && j2 <= 3000int / d as int &&\n            total_mass as int == #[trigger] ((a as int * i1 + b as int * j1) * 100 + (c as int * i2 + d as int * j2)) &&\n            sugar_mass as int == #[trigger] (c as int * i2 + d as int * j2) &&\n            a as int * i1 + b as int * j1 > 0) &&\n        total_mass as int > 0\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0648", "language": "verus", "source": "apps", "source_id": "apps_test_4616", "vc-description": "Given a string of at least 3 lowercase English letters, create an abbreviation by replacing\nthe middle characters with their count. Format: first_character + count_of_middle_characters + last_character.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {\n    result.len() >= 3 &&\n    s.len() >= 3 &&\n    result[0] == s[0] &&\n    result[result.len() - 1] == s[s.len() - 1] &&\n    result == seq![s[0]].add(int_to_string(s.len() - 2)).add(seq![s[s.len() - 1]])\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases if n >= 0 { n } else { -n }\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'].add(int_to_string_helper(-n))\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 {\n        Seq::new(0 as nat, |_i: int| ' ')\n    } else {\n        int_to_string_helper(n / 10).add(seq![(('0' as int) + (n % 10)) as char])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures valid_abbreviation(s@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0649", "language": "verus", "source": "apps", "source_id": "apps_test_4617", "vc-description": "Given a 2×3 grid of lowercase English letters, determine if the grid remains identical after a 180-degree rotation.\nInput consists of two lines, each containing 3 characters.\nOutput \"YES\" if unchanged after rotation, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0\n}\n\nspec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {\n    reverse_seq(first_row) == second_row\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> \n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == '\\n' {\n        seq![seq![]] + split_lines(s.subrange(1, s.len() as int))\n    } else {\n        let rest = split_lines(s.subrange(1, s.len() as int));\n        if rest.len() == 0 {\n            seq![seq![s[0]]]\n        } else {\n            seq![rest[0].push(s[0])] + rest.subrange(1, rest.len() as int)\n        }\n    }\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@", "vc-code": "{\n    assume(false);\n    \"NO\\n\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0650", "language": "verus", "source": "apps", "source_id": "apps_test_4635", "vc-description": "Given two integers n and k, construct a string of length n using only the first k letters \nof the alphabet ('a', 'b', ..., k-th letter). Each of the k letters must appear at least once.\nMaximize the minimum frequency among all letters used. The optimal strategy is to distribute\ncharacters as evenly as possible by cycling through the k letters repeatedly.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    (exists|lines: Seq<Seq<char>>| lines == split_by_newline(input) && \n     lines.len() >= 1 && \n     is_valid_integer(lines[0]) &&\n     string_to_int_val(lines[0]) >= 0 &&\n     lines.len() >= string_to_int_val(lines[0]) + 1 &&\n     (forall|i: int| 1 <= i <= string_to_int_val(lines[0]) && i < lines.len() ==> valid_test_case_line(lines[i])))\n}\n\nspec fn valid_test_case_line(line: Seq<char>) -> bool {\n    exists|parts: Seq<Seq<char>>| (parts == split_by_space(line) &&\n                    parts.len() >= 2 &&\n                    is_valid_integer(parts[0]) &&\n                    is_valid_integer(parts[1]) &&\n                    string_to_int_val(parts[0]) > 0 &&\n                    string_to_int_val(parts[1]) > 0 &&\n                    string_to_int_val(parts[1]) <= 26)\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s.len() == 1 || s[0] != '0' || s == seq!['0']) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn string_to_int_val(s: Seq<char>) -> int \n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        (s[0] as int) - 48 \n    } else { \n        string_to_int_val(s.subrange(0, s.len() - 1 as int)) * 10 + ((s[s.len() - 1] as int) - 48)\n    }\n}\n\nspec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool \n    recommends n > 0 && k > 0 && k <= 26\n{\n    output.len() == n &&\n    (forall|j: int| 0 <= j < n ==> (#[trigger] output[j] == ((j % k) + 97) as char))\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]  /* Placeholder implementation for splitting by newlines */\n}\n\nspec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2']]  /* Placeholder implementation for splitting by spaces */\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@.len() >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0651", "language": "verus", "source": "apps", "source_id": "apps_test_4659", "vc-description": "Generate the first numRows rows of Pascal's triangle, where each number is the sum\nof the two numbers directly above it in the previous row.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_pascal_triangle(triangle: Seq<Seq<int>>, num_rows: int) -> bool {\n    triangle.len() == num_rows &&\n    (num_rows == 0 ==> triangle == Seq::<Seq<int>>::empty()) &&\n    (num_rows > 0 ==> (\n        forall|i: int| 0 <= i < triangle.len() ==> #[trigger] triangle[i].len() == i + 1\n    )) &&\n    (num_rows > 0 ==> (\n        forall|i: int| 0 <= i < triangle.len() ==> \n            #[trigger] triangle[i][0] == 1 && #[trigger] triangle[i][triangle[i].len() - 1] == 1\n    )) &&\n    (num_rows > 1 ==> (\n        forall|i: int, j: int| 1 <= i < triangle.len() && 1 <= j < triangle[i].len() - 1 ==> \n            #[trigger] triangle[i][j] == triangle[i-1][j-1] + triangle[i-1][j]\n    ))\n}", "vc-helpers": "", "vc-spec": "fn generate(num_rows: i8) -> (result: Vec<Vec<i8>>)\n    requires num_rows >= 0\n    ensures valid_pascal_triangle(result@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int)), num_rows as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0652", "language": "verus", "source": "apps", "source_id": "apps_test_4676", "vc-description": "Given two strings O and E representing characters at odd-numbered and even-numbered positions\nof a password respectively, restore the original password by interleaving the characters.\nInput format: O on first line, E on second line, separated by newline.\nOutput: interleaved password where characters alternate between O and E.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    {\n        let o = lines[0];\n        let e = lines[1];\n        let a = o.len();\n        let b = e.len();\n        (a == b || a == b + 1) &&\n        (a > 0 || b == 0)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    /* Helper function to split input by newlines */\n    seq![]  /* Placeholder - would need actual implementation */\n}\n\nspec fn get_o(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[0]\n}\n\nspec fn get_e(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[1]\n}\n\nspec fn correct_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let o = get_o(input);\n    let e = get_e(input);\n    let a = o.len();\n    let b = e.len();\n    if a == b {\n        interleave_equal(o, e)\n    } else {\n        interleave_unequal(o, e)\n    }\n}\n\nspec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len()\n    decreases o.len()\n{\n    if o.len() == 0 {\n        seq![]\n    } else {\n        seq![o[0], e[0]] + interleave_equal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n\nspec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len() + 1\n    decreases e.len()\n{\n    if e.len() == 0 {\n        o\n    } else {\n        seq![o[0], e[0]] + interleave_unequal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == correct_result(input@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0653", "language": "verus", "source": "apps", "source_id": "apps_test_4677", "vc-description": "Simulate a 3-key text editor that processes keystrokes: '0' and '1' append characters,\n'B' deletes the rightmost character if the string is non-empty.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 10 && \n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1' || s[i] == 'B'\n}\n\nspec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>\n    decreases keystrokes.len()\n{\n    if keystrokes.len() == 0 {\n        Seq::<char>::empty()\n    } else {\n        let prev = simulate_keystrokes(keystrokes.subrange(0, keystrokes.len() - 1));\n        let last_key = keystrokes[keystrokes.len() - 1];\n        if last_key == 'B' {\n            if prev.len() > 0 {\n                prev.subrange(0, prev.len() - 1)\n            } else {\n                prev\n            }\n        } else {\n            prev.push(last_key)\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < result.len() ==> result[i] == '0' || result[i] == '1'\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@),\n    ensures \n        valid_output(result@),\n        result@ == simulate_keystrokes(s@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0654", "language": "verus", "source": "apps", "source_id": "apps_test_4679", "vc-description": "Three players (Alice, Bob, Charlie) play a card game with decks of cards labeled 'a', 'b', or 'c'.\nAlice starts first. On each turn, if current player's deck is empty, they win the game.\nOtherwise, discard the top card; the letter determines next player ('a'→Alice, 'b'→Bob, 'c'→Charlie).\nGiven initial decks as strings, determine the winner.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_deck(deck: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < deck.len() ==> (deck[i] == 'a' || deck[i] == 'b' || deck[i] == 'c')\n}\n\nspec fn valid_input(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {\n    valid_deck(a) && valid_deck(b) && valid_deck(c)\n}\n\nspec fn valid_winner(winner: char) -> bool {\n    winner == 'A' || winner == 'B' || winner == 'C'\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<char>, b: Vec<char>, c: Vec<char>) -> (result: char)\n    requires valid_input(a@, b@, c@)\n    ensures valid_winner(result)", "vc-code": "{\n    assume(false);\n    'A'\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0655", "language": "verus", "source": "apps", "source_id": "apps_test_4680", "vc-description": "Given three integers A, B, and C representing syllable counts of three phrases,\ndetermine if these phrases can be arranged to form a Haiku. A Haiku requires\nexactly two phrases with 5 syllables and one phrase with 7 syllables.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10\n}\n\nspec fn can_form_haiku(a: int, b: int, c: int) -> bool {\n    (a == 5 && b == 5 && c == 7) ||\n    (a == 5 && b == 7 && c == 5) ||\n    (a == 7 && b == 5 && c == 5)\n}\n\nspec fn valid_output(result: &str) -> bool {\n    result == \"YES\" || result == \"NO\"\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8) -> (result: &'static str)\n    requires \n        valid_input(a as int, b as int, c as int),\n    ensures \n        valid_output(result),\n        (result == \"YES\") <==> can_form_haiku(a as int, b as int, c as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0656", "language": "verus", "source": "apps", "source_id": "apps_test_4681", "vc-description": "Compute the N-th Lucas number where the Lucas sequence is defined as:\nL₀ = 2, L₁ = 1, and Lᵢ = Lᵢ₋₁ + Lᵢ₋₂ for i ≥ 2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn lucas(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 {\n        2\n    } else if n == 1 {\n        1\n    } else {\n        lucas(n - 1) + lucas(n - 2)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 86\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures result as int == lucas(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0657", "language": "verus", "source": "apps", "source_id": "apps_test_4688", "vc-description": "Given N balls in a row and K available colors, count the number of ways to paint \nthe balls such that no two adjacent balls have the same color. The solution is\nbased on the combinatorial formula: first ball has K choices, each subsequent \nball has (K-1) choices, giving K * (K-1)^(N-1) total ways.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn power(base: int, exp: int) -> int\n  decreases exp when exp >= 0\n{\n  if exp <= 0 { 1 } else { base * power(base, exp - 1) }\n}\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n  1 <= n <= 1000 && 2 <= k <= 1000\n}\n\nspec fn painting_ways(n: int, k: int) -> int\n{\n  if valid_input(n, k) { k * power(k - 1, n - 1) } else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n  requires \n    valid_input(n as int, k as int)\n  ensures \n    result as int == painting_ways(n as int, k as int),\n    result > 0", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0658", "language": "verus", "source": "apps", "source_id": "apps_test_4690", "vc-description": "Given dimensions of two rectangles (A×B and C×D), return the area of the rectangle with the larger area.\nIf both rectangles have equal areas, return that common area.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    1 <= a <= 10000 && 1 <= b <= 10000 && 1 <= c <= 10000 && 1 <= d <= 10000\n}\n\nspec fn max_area(a: int, b: int, c: int, d: int) -> int {\n    if a * b >= c * d { a * b } else { c * d }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int, d as int)\n    ensures \n        result as int == max_area(a as int, b as int, c as int, d as int),\n        result as int >= (a as int) * (b as int) && result as int >= (c as int) * (d as int),\n        result as int == (a as int) * (b as int) || result as int == (c as int) * (d as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0659", "language": "verus", "source": "apps", "source_id": "apps_test_4692", "vc-description": "Calculate how many hours remain from M o'clock (24-hour format) on December 30th \nuntil New Year (0 o'clock on January 1st). M is an integer between 1 and 23 inclusive.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(m: int) -> bool {\n    1 <= m <= 23\n}\n\nspec fn hours_until_new_year(m: int) -> int\n    recommends valid_input(m)\n{\n    48 - m\n}\n\nspec fn valid_output(m: int, result: int) -> bool\n    recommends valid_input(m)\n{\n    result == hours_until_new_year(m) && 25 <= result <= 47\n}", "vc-helpers": "", "vc-spec": "fn solve(m: i8) -> (result: i8)\n    requires valid_input(m as int)\n    ensures valid_output(m as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0661", "language": "verus", "source": "apps", "source_id": "apps_test_4697", "vc-description": "Given N S-shaped pieces and M c-shaped pieces, find the maximum number of \"Scc groups\"\nthat can be formed. Each Scc group requires exactly 1 S-shaped piece and 2 c-shaped pieces.\nAdditionally, 2 c-shaped pieces can be combined to create 1 S-shaped piece.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 0 && m >= 0\n}\n\nspec fn max_scc_groups(n: int, m: int) -> int {\n    if valid_input(n, m) {\n        let direct_groups = if n < m / 2 { n } else { m / 2 };\n        let remaining_c_pieces = m - direct_groups * 2;\n        let additional_groups = remaining_c_pieces / 4;\n        direct_groups + additional_groups\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (result: i8)\n  requires valid_input(n as int, m as int)\n  ensures \n      result >= 0,\n      result as int == max_scc_groups(n as int, m as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0662", "language": "verus", "source": "apps", "source_id": "apps_test_4701", "vc-description": "Start with value 1 and perform exactly N operations. Each operation is either:\nOperation A: multiply current value by 2, or Operation B: add K to current value.\nFind the minimum possible final value after N operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1\n}\n\nspec fn apply_operations(start: int, operations: Seq<bool>, k: int) -> int\n    decreases operations.len()\n{\n    if operations.len() == 0 {\n        start\n    } else if operations[0] {\n        apply_operations(start * 2, operations.subrange(1, operations.len() as int), k)\n    } else {\n        apply_operations(start + k, operations.subrange(1, operations.len() as int), k)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8) -> (result: i8)\n    requires valid_input(n as int, k as int)\n    ensures result as int >= 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0663", "language": "verus", "source": "apps", "source_id": "apps_test_4702", "vc-description": "Given an integer x where 0 ≤ x ≤ 1 represented as a string, output the logical NOT of x.\nIf x = 0, output 1. If x = 1, output 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    (input[0] == '0' || input[0] == '1') && \n    (input.len() == 1 || (input.len() > 1 && input[1] == '\\n'))\n}\n\nspec fn logical_not(digit: char) -> Seq<char>\n    recommends digit == '0' || digit == '1'\n{\n    if digit == '0' { seq!['1', '\\n'] } else { seq!['0', '\\n'] }\n}\n\nspec fn correct_output(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    output == logical_not(input[0])\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (output: String)\n    requires valid_input(input@)\n    ensures correct_output(input@, output@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0664", "language": "verus", "source": "apps", "source_id": "apps_test_4705", "vc-description": "Calculate the net amount paid by a customer for N meals at a restaurant.\nEach meal costs 800 yen. For every 15 meals ordered, the customer receives\n200 yen cashback. Return the net amount (total cost minus cashback).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 100\n}\n\nspec fn total_cost(n: int) -> int\n    recommends valid_input(n)\n{\n    800 * n\n}\n\nspec fn cashback(n: int) -> int\n    recommends valid_input(n)\n{\n    (n / 15) * 200\n}\n\nspec fn net_amount(n: int) -> int\n    recommends valid_input(n)\n{\n    total_cost(n) - cashback(n)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures result as int == net_amount(n as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0665", "language": "verus", "source": "apps", "source_id": "apps_test_4706", "vc-description": "Given a 3×3 grid of lowercase English letters, extract and concatenate \nthe characters on the main diagonal (from top-left to bottom-right) \nto form a string of length 3.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() == 3 && forall|i: int| 0 <= i < 3 ==> lines[i].len() == 3\n}\n\nspec fn extract_diagonal(lines: Seq<Seq<char>>) -> Seq<char>\n    recommends valid_input(lines)\n{\n    seq![lines[0][0], lines[1][1], lines[2][2]]\n}", "vc-helpers": "", "vc-spec": "fn solve(lines: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires valid_input(lines@.map(|i: int, v: Vec<char>| v@))\n    ensures \n        result@.len() == 4 &&\n        result@[0] == lines@[0]@[0] &&\n        result@[1] == lines@[1]@[1] &&\n        result@[2] == lines@[2]@[2] &&\n        result@[3] == '\\n' &&\n        result@ == extract_diagonal(lines@.map(|i: int, v: Vec<char>| v@)).push('\\n')", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0667", "language": "verus", "source": "apps", "source_id": "apps_test_4710", "vc-description": "Given an integer rating x, classify it as \"ABC\" if x < 1200, otherwise \"ARC\".\nThe input must be between 1 and 3000 inclusive.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int) -> bool {\n    1 <= x <= 3000\n}\n\nspec fn correct_output(x: int, result: Seq<char>) -> bool {\n    (x < 1200 ==> result == seq!['A', 'B', 'C', '\\n']) &&\n    (x >= 1200 ==> result == seq!['A', 'R', 'C', '\\n'])\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i32) -> (result: Vec<char>)\n    requires valid_input(x as int)\n    ensures correct_output(x as int, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0668", "language": "verus", "source": "apps", "source_id": "apps_test_4711", "vc-description": "Given three bell prices a, b, and c (in yen), find the minimum cost to purchase exactly two bells of different types.\nConstraints: 1 ≤ a, b, c ≤ 10000 (integers)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 10000 && 1 <= b <= 10000 && 1 <= c <= 10000\n}\n\nspec fn min_of_three(x: int, y: int, z: int) -> int {\n    if x <= y && x <= z { x }\n    else if y <= z { y }\n    else { z }\n}\n\nspec fn correct_result(a: int, b: int, c: int) -> int {\n    min_of_three(a + b, a + c, b + c)\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires valid_input(a as int, b as int, c as int)\n    ensures result as int == correct_result(a as int, b as int, c as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0669", "language": "verus", "source": "apps", "source_id": "apps_test_4713", "vc-description": "Given a string S of length N containing only characters 'I' and 'D', simulate the following process:\nStart with x = 0. For each character in S from left to right:\nIf the character is 'I', increment x by 1. If the character is 'D', decrement x by 1.\nFind the maximum value that x reaches during this entire process (including the initial value 0).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn max_value(s: Seq<char>) -> int {\n    max_value_up_to_index(s, s.len() as int)\n}\n\nspec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int\n    decreases up_to when 0 <= up_to <= s.len()\n{\n    if up_to == 0 { 0 }\n    else {\n        let current_value = current_value_at_index(s, up_to);\n        let max_before = max_value_up_to_index(s, up_to - 1);\n        if current_value > max_before { current_value } else { max_before }\n    }\n}\n\nspec fn current_value_at_index(s: Seq<char>, index: int) -> int\n    decreases index when 0 <= index <= s.len()\n{\n    if index == 0 { 0 }\n    else { \n        current_value_at_index(s, index - 1) + (if s[index - 1 as nat] == 'I' { 1 } else { -1 })\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        1 <= n <= 100,\n        n as int == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'I' || s@[i] == 'D',\n    ensures \n        result >= 0,\n        result as int == max_value(s@),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0671", "language": "verus", "source": "apps", "source_id": "apps_test_4715", "vc-description": "Given three integers representing colors, count the number of distinct colors.\nInput constraints: 1 ≤ a,b,c ≤ 100\nOutput: number of different kinds of colors (1, 2, or 3)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nspec fn count_distinct_colors(a: int, b: int, c: int) -> int {\n    if a == b && b == c { 1 }\n    else if a == b || b == c || a == c { 2 }\n    else { 3 }\n}\n\nspec fn all_same(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n\nspec fn exactly_two_same(a: int, b: int, c: int) -> bool {\n    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)\n}\n\nspec fn all_different(a: int, b: int, c: int) -> bool {\n    a != b && b != c && a != c\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int)\n    ensures \n        1 <= result as int <= 3,\n        result as int == count_distinct_colors(a as int, b as int, c as int),\n        result as int == 1 <==> all_same(a as int, b as int, c as int),\n        result as int == 2 <==> exactly_two_same(a as int, b as int, c as int),\n        result as int == 3 <==> all_different(a as int, b as int, c as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0672", "language": "verus", "source": "apps", "source_id": "apps_test_4717", "vc-description": "Given three distinct positions x, a, and b on a number line, determine whether position a or position b \nis closer to position x. Output \"A\" if position a is closer, \"B\" if position b is closer.\nDistance between two positions s and t is |s-t|.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, a: int, b: int) -> bool {\n    1 <= x <= 1000 &&\n    1 <= a <= 1000 &&\n    1 <= b <= 1000 &&\n    x != a && x != b && a != b &&\n    distance(x, a) != distance(x, b)\n}\n\nspec fn distance(s: int, t: int) -> nat {\n    if s >= t { (s - t) as nat } else { (t - s) as nat }\n}\n\nspec fn correct_result(x: int, a: int, b: int, result: Seq<char>) -> bool {\n    (result == seq!['A'] <==> distance(x, a) < distance(x, b)) &&\n    (result == seq!['B'] <==> distance(x, b) < distance(x, a))\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8, a: i8, b: i8) -> (result: String)\n    requires \n        valid_input(x as int, a as int, b as int),\n    ensures \n        result@ == seq!['A'] || result@ == seq!['B'],\n        correct_result(x as int, a as int, b as int, result@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0673", "language": "verus", "source": "apps", "source_id": "apps_test_4718", "vc-description": "Given a date string in format \"2017/01/dd\" where dd represents a day from 01 to 31,\nreplace the year \"2017\" with \"2018\" and output the corrected date string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(date_str: Seq<char>) -> bool {\n    date_str.len() == 10 && date_str.subrange(0, 4) == seq!['2', '0', '1', '7']\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool \n    recommends input.len() >= 4\n{\n    output == seq!['2', '0', '1', '8'].add(input.subrange(4, input.len() as int)) &&\n    output.len() == 10 &&\n    output.subrange(0, 4) == seq!['2', '0', '1', '8'] &&\n    output.subrange(4, output.len() as int) == input.subrange(4, input.len() as int)\n}", "vc-helpers": "", "vc-spec": "fn solve(date_str: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(date_str@)\n    ensures valid_output(date_str@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0674", "language": "verus", "source": "apps", "source_id": "apps_test_4721", "vc-description": "Given n east-west streets and m north-south streets in a city where all streets intersect,\ndetermine the number of rectangular blocks formed by the street grid.\nn east-west streets create (n-1) horizontal strips, m north-south streets create (m-1) vertical strips,\nresulting in (n-1) * (m-1) rectangular blocks.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    2 <= n <= 100 && 2 <= m <= 100\n}\n\nspec fn count_blocks(n: int, m: int) -> int\n    recommends valid_input(n, m)\n{\n    (n - 1) * (m - 1)\n}\n\nspec fn correct_output(n: int, m: int, blocks: int) -> bool {\n    valid_input(n, m) && blocks == count_blocks(n, m)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8) -> (blocks: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        correct_output(n as int, m as int, blocks as int),\n        blocks >= 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0675", "language": "verus", "source": "apps", "source_id": "apps_test_4722", "vc-description": "Given two integers A and B representing cookies in two tins, determine if cookies\ncan be distributed equally among three goats by choosing A, B, or A+B total cookies.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100\n}\n\nspec fn distribution_possible(a: int, b: int) -> bool {\n    a % 3 == 0 || b % 3 == 0 || (a + b) % 3 == 0\n}", "vc-helpers": "", "vc-spec": "fn solve(a: i8, b: i8) -> (result: String)\n    requires \n        valid_input(a as int, b as int)\n    ensures \n        result@ == seq!['P', 'o', 's', 's', 'i', 'b', 'l', 'e'] <==> distribution_possible(a as int, b as int),\n        result@ == seq!['P', 'o', 's', 's', 'i', 'b', 'l', 'e'] || result@ == seq!['I', 'm', 'p', 'o', 's', 's', 'i', 'b', 'l', 'e']", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VA0676", "language": "verus", "source": "apps", "source_id": "apps_test_4724", "vc-description": "Given a current rating R and target rating G, find the required performance P\nsuch that the new rating equals G, where new rating = (R + P) / 2 = G.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(r: int, g: int) -> bool {\n    0 <= r <= 4500 && 0 <= g <= 4500\n}\n\nspec fn required_performance(r: int, g: int) -> int {\n    2 * g - r\n}\n\nspec fn correct_result(r: int, g: int, p: int) -> bool {\n    (r + p) == 2 * g\n}", "vc-helpers": "", "vc-spec": "fn solve(r: i8, g: i8) -> (result: i8)\n    requires \n        valid_input(r as int, g as int)\n    ensures \n        result as int == required_performance(r as int, g as int) &&\n        correct_result(r as int, g as int, result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
