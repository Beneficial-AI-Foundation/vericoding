vc-description: |-
  Given n distinct points representing electric poles, count the number of pairs of wires that intersect.
  Every pair of poles is connected by a wire (infinite straight line). If multiple poles lie on the same line,
  they share a single wire. Return the number of intersecting wire pairs.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
      seq![]
  }

  spec fn is_valid_first_line(line: Seq<char>) -> bool {
      true
  }

  spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {
      0
  }

  spec fn is_valid_coordinate_line(line: Seq<char>) -> bool {
      true
  }

  spec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<int> {
      seq![]
  }

  spec fn group_lines_by_slope(lines: Seq<int>) -> Seq<Seq<int>> {
      seq![]
  }

  spec fn sum_over_slope_groups(groups: Seq<Seq<int>>, total: nat) -> nat {
      0
  }

  spec fn valid_input_format(input: Seq<char>) -> bool {
      input.len() > 0 && input[input.len() - 1] == '\n' && {
          let lines = split_lines(input);
          lines.len() >= 3 && lines.len() <= 1001 &&
          is_valid_first_line(lines[0]) && {
              let n = parse_first_line_as_nat(lines[0]);
              n >= 2 && n <= 1000 && lines.len() == n + 1 &&
              forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(lines[i])
          }
      }
  }
  
  spec fn is_non_negative_numeric_string(s: Seq<char>) -> bool {
      s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
  }
  
  spec fn valid_coordinate(point: (int, int)) -> bool {
      let (x, y) = point;
      -10000 <= x <= 10000 && -10000 <= y <= 10000
  }
  
  spec fn extract_n(input: Seq<char>) -> nat
      requires valid_input_format(input)
  {
      let lines = split_lines(input);
      parse_first_line_as_nat(lines[0])
  }
  
  spec fn extract_points(input: Seq<char>) -> Seq<(int, int)>
      requires valid_input_format(input)
      ensures extract_points(input).len() == extract_n(input)
  {
      seq![(0, 0), (1, 1)]
  }
  
  spec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat
      requires points.len() >= 2,
      requires forall|i: int, j: int| 0 <= i < j < points.len() ==> points[i] != points[j],
      requires forall|i: int| 0 <= i < points.len() ==> valid_coordinate(points[i]),
      ensures count_intersecting_line_pairs(points) >= 0,
  {
      let distinct_lines = get_distinct_lines(points);
      let slope_groups = group_lines_by_slope(distinct_lines);
      let total_lines = distinct_lines.len();
      (sum_over_slope_groups(slope_groups, total_lines)) / 2
  }
  
  spec fn string_to_int(s: Seq<char>) -> nat
      requires is_non_negative_numeric_string(s)
  {
      0
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
      requires stdin_input.len() > 0,
      requires valid_input_format(stdin_input),
      ensures result.len() > 0,
      ensures is_non_negative_numeric_string(result),
      ensures {
          let n = extract_n(stdin_input);
          let points = extract_points(stdin_input);
          points.len() == n && n >= 2 && n <= 1000 &&
          (forall|i: int| 0 <= i < points.len() ==> valid_coordinate(points[i])) &&
          (forall|i: int, j: int| 0 <= i < j < points.len() ==> points[i] != points[j]) &&
          string_to_int(result) == count_intersecting_line_pairs(points)
      },

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}