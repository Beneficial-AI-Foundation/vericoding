vc-description: |-
  Given a fence with n planks of heights, find k consecutive planks with the minimum sum of heights.
  Return the 1-indexed starting position of such a sequence. If multiple solutions exist, return any valid one.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn sum_window(heights: Seq<int>, start: int, k: int) -> int
    recommends 
      0 <= start,
      start + k <= heights.len(),
      k > 0
    decreases k
  {
    if k == 1 { 
      heights[start] 
    } else { 
      heights[start] + sum_window(heights, start + 1, k - 1) 
    }
  }
  
  spec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool
  {
    1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> 1 <= heights[i] <= 100
  }
  
  spec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool
    recommends valid_input(n, k, heights)
  {
    1 <= result <= n-k+1 &&
    forall|start: int| 0 <= start <= n-k ==> 
      sum_window(heights, result-1, k) <= sum_window(heights, start, k) &&
    forall|start: int| 0 <= start < result-1 ==>
      sum_window(heights, start, k) > sum_window(heights, result-1, k)
  }

vc-spec: |-
  fn solve(n: int, k: int, heights: Seq<int>) -> (result: int)
    requires valid_input(n, k, heights)
    ensures valid_result(result, n, k, heights)

vc-code: |-
  {
    assume(false);
    unreached()
  }

vc-postamble: |-

  }

  fn main() {}