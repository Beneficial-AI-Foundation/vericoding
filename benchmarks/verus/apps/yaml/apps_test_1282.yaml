vc-description: |-
  Given a string of 'M' (boys) and 'F' (girls), determine how many seconds
  it takes for all girls to move to the front of the line. Each second,
  all boys immediately in front of girls simultaneously swap positions.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(input: Seq<char>) -> bool {
      input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> (input[i] == 'M' || input[i] == 'F')
  }

  spec fn reverse_seq(s: Seq<char>) -> Seq<char> {
      Seq::new(s.len(), |i: int| s[s.len() - 1 - i])
  }

  spec fn find_char(s: Seq<char>, c: char, start: int) -> int {
      if start >= s.len() {
          -1
      } else if s[start] == c {
          start
      } else {
          find_char(s, c, start + 1)
      }
  }

  spec fn rfind_char(s: Seq<char>, c: char) -> int {
      if s.len() == 0 {
          -1
      } else {
          rfind_char_helper(s, c, (s.len() - 1) as int)
      }
  }

  spec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int {
      if pos < 0 {
          -1
      } else if s[pos] == c {
          pos
      } else {
          rfind_char_helper(s, c, pos - 1)
      }
  }

  spec fn count_char(s: Seq<char>, c: char) -> int {
      count_char_helper(s, c, 0)
  }

  spec fn count_char_helper(s: Seq<char>, c: char, i: int) -> int {
      if i >= s.len() {
          0
      } else if s[i] == c {
          1 + count_char_helper(s, c, i + 1)
      } else {
          count_char_helper(s, c, i + 1)
      }
  }

  spec fn calculate_balance(s: Seq<char>) -> int {
      calculate_balance_helper(s, 0, 0)
  }

  spec fn calculate_balance_helper(s: Seq<char>, i: int, balance: int) -> int {
      if i >= s.len() {
          balance
      } else if s[i] == 'M' {
          calculate_balance_helper(s, i + 1, balance + 1)
      } else {
          calculate_balance_helper(s, i + 1, balance - 1)
      }
  }

  spec fn compute_swap_time(input: Seq<char>) -> nat
      recommends valid_input(input)
  {
      let rev_input = reverse_seq(input);
      let first_f = find_char(rev_input, 'F', 0);

      if first_f == -1 {
          0
      } else {
          let first_m_after_f = find_char(rev_input, 'M', first_f + 1);
          if first_m_after_f == -1 {
              0
          } else {
              let last_m = rfind_char(rev_input, 'M');
              if last_m < first_m_after_f {
                  0
              } else {
                  let substring = rev_input.subrange(first_m_after_f, last_m + 1);
                  let balance = calculate_balance(substring);
                  let f_count = count_char(substring, 'F');
                  (balance + f_count + first_m_after_f - first_f - 1) as nat
              }
          }
      }
  }

  spec fn nat_to_string(n: nat) -> Seq<char> {
      nat_to_string_helper(n)
  }

  spec fn nat_to_string_helper(n: nat) -> Seq<char> {
      if n < 10 {
          Seq::new(1, |j: int| ('0' as u8 + n as u8) as char)
      } else {
          nat_to_string_helper(n / 10).add(Seq::new(1, |j: int| ('0' as u8 + (n % 10) as u8) as char))
      }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(input: Seq<char>) -> (result: Seq<char>)
      requires
          valid_input(input),
      ensures
          result.len() >= 1,
          result[result.len() - 1] == '\n',
          exists|val: nat| result == nat_to_string(val).add(Seq::new(1, |j: int| '\n')),
          result == nat_to_string(compute_swap_time(input)).add(Seq::new(1, |j: int| '\n')),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}