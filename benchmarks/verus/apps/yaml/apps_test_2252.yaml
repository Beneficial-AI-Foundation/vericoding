vc-description: |-
  Given a permutation P of n pages and m queries, determine for each query whether a specific element 
  remains in the same position after sorting a subsegment in ascending order. For each query with 
  parameters (l, r, x): sort the subsegment P[l...r] in ascending order, check if the element at 
  position x remains unchanged. Each query is independent (permutation resets after each query).

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input_format(input: Seq<u8>) -> bool {
      let lines = split_lines(input);
      lines.len() >= 2 && {
          let first_line = parse_integers(lines[0]);
          first_line.len() == 2 && {
              let n = first_line[0];
              let m = first_line[1];
              n >= 1 && m >= 0 &&
              parse_integers(lines[1]).len() == n &&
              is_valid_permutation(parse_integers(lines[1]), n) &&
              lines.len() == 2 + m &&
              forall|i: int| 2 <= i < lines.len() ==> {
                  let query = parse_integers(lines[i]);
                  query.len() == 3 && {
                      let l = query[0];
                      let r = query[1];
                      let x = query[2];
                      1 <= l <= x <= r <= n
                  }
              }
          }
      }
  }

  spec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {
      p.len() == n && 
      (forall|i: int| 0 <= i < p.len() ==> 1 <= p[i] <= n) &&
      (forall|i: int, j: int| 0 <= i < j < p.len() ==> p[i] != p[j])
  }

  spec fn valid_output_format(output: Seq<u8>) -> bool {
      let lines = split_lines(output);
      forall|line: Seq<u8>| lines.contains(line) ==> 
          seq_equal(line, seq![89u8, 101u8, 115u8]) || seq_equal(line, seq![78u8, 111u8])
  }

  spec fn output_matches_queries(input: Seq<u8>, output: Seq<u8>) -> bool {
      let input_lines = split_lines(input);
      let output_lines = split_lines(output);
      if input_lines.len() < 2 { 
          false 
      } else {
          let first_line = parse_integers(input_lines[0]);
          if first_line.len() != 2 { 
              false 
          } else {
              let n = first_line[0];
              let m = first_line[1];
              input_lines.len() == 2 + m &&
              output_lines.len() == m && {
                  let p = parse_integers(input_lines[1]);
                  forall|i: int| 0 <= i < m ==> {
                      let query = parse_integers(input_lines[2 + i]);
                      let l = query[0];
                      let r = query[1]; 
                      let x = query[2];
                      let px = p[x - 1];
                      let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);
                      if cnt == x {
                          seq_equal(output_lines[i], seq![89u8, 101u8, 115u8])
                      } else {
                          seq_equal(output_lines[i], seq![78u8, 111u8])
                      }
                  }
              }
          }
      }
  }

  spec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int
      decreases if start <= end { end - start + 1 } else { 0 }
  {
      if start > end {
          0int
      } else if start < 0 || start >= p.len() {
          0int
      } else {
          (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value)
      }
  }

  spec fn parse_integers(line: Seq<u8>) -> Seq<int> {
      seq![]
  }

  spec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>>
      decreases s.len()
  {
      if s.len() == 0 {
          seq![]
      } else {
          let idx = find_newline(s, 0);
          if idx == -1 {
              seq![s]
          } else {
              seq![s.subrange(0, idx)] + split_lines(s.subrange(idx + 1, s.len() as int))
          }
      }
  }

  spec fn find_newline(s: Seq<u8>, start: nat) -> int
      decreases s.len() - start
  {
      if start >= s.len() {
          -1
      } else if s[start as int] == 10u8 {
          start as int
      } else {
          find_newline(s, start + 1)
      }
  }

  spec fn seq_equal(s1: Seq<u8>, s2: Seq<u8>) -> bool {
      s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]
  }

vc-helpers: |

vc-spec: |-
  fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
      requires
          stdin_input@.len() > 0,
          exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == 10u8,
          valid_input_format(stdin_input@),
      ensures
          result@.len() > 0,
          forall|i: int| 0 <= i < result@.len() ==> 
              result@[i] == 89u8 || 
              result@[i] == 101u8 || 
              result@[i] == 115u8 || 
              result@[i] == 78u8 || 
              result@[i] == 111u8 || 
              result@[i] == 32u8 || 
              result@[i] == 10u8,
          result@.len() > 0 ==> result@[result@.len() - 1] == 10u8,
          valid_output_format(result@),
          output_matches_queries(stdin_input@, result@),

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |2-

  }

  fn main() {}
