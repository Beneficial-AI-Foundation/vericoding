vc-description: |-
  Given an n Ã— m grid where '.' represents empty cells and '#' represents occupied cells,
  count the number of distinct ways to create a pipe with constraints:
  1. The pipe is a width-1 polyline through empty cells only
  2. The pipe starts and ends on the grid boundary (but not corner cells)
  3. The pipe has at most 2 turns (90-degree turns)
  4. The pipe touches exactly 2 boundary cells (start and end)
  5. If the pipe is a straight line, start and end must be on different edges
  6. Each non-boundary pipe cell has exactly 2 adjacent pipe cells
  7. Each boundary pipe cell has exactly 1 adjacent pipe cell

  /* Simplified implementation */

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(input: Seq<char>) -> bool {
      input.len() > 0 && input.index(input.len() - 1) == '\n'
  }

  spec fn valid_output(output: Seq<char>) -> bool {
      output.len() > 0 && output.index(output.len() - 1) == '\n'
  }

  spec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {
      (seq![], 0, 0)
  }

  spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
      seq![]
  }

  spec fn find_newline(s: Seq<char>, start: int) -> int {
      -1
  }

  spec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {
      grid.len() == rows &&
      rows >= 0 && cols >= 0 &&
      (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&
      (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> 
          grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')
  }

  spec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {
      i == 0 || i == rows - 1 || j == 0 || j == cols - 1
  }

  spec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {
      (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||
      (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)
  }

  spec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {
      0
  }

vc-helpers: |

vc-spec: |-
  fn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)
      requires valid_input(input)
      ensures valid_output(output)

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |2-

  }

  fn main() {}
