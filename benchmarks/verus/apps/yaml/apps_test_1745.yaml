vc-description: |-
  Given an n Ã— m grid where '.' represents empty cells and '#' represents occupied cells,
  count the number of distinct ways to create a pipe with constraints:
  1. The pipe is a width-1 polyline through empty cells only
  2. The pipe starts and ends on the grid boundary (but not corner cells)
  3. The pipe has at most 2 turns (90-degree turns)
  4. The pipe touches exactly 2 boundary cells (start and end)
  5. If the pipe is a straight line, start and end must be on different edges
  6. Each non-boundary pipe cell has exactly 2 adjacent pipe cells
  7. Each boundary pipe cell has exactly 1 adjacent pipe cell
  
  /* Simplified implementation */

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn valid_input(input: &str) -> bool {
      input.len() > 0 && input.as_bytes()[input.len() - 1] == 10u8
  }
  
  spec fn valid_output(output: &str) -> bool {
      output.len() > 0 && output.as_bytes()[output.len() - 1] == 10u8
  }
  
  fn parse_grid(input: &str) -> (Vec<Vec<char>>, usize, usize)
      requires valid_input(input)
  {
      let lines = split_lines(input);
      if lines.len() == 0 {
          (Vec::new(), 0, 0)
      } else {
          let grid: Vec<Vec<char>> = lines.into_iter().map(|line| line.chars().collect()).collect();
          let rows = grid.len();
          let cols = if rows > 0 { grid[0].len() } else { 0 };
          (grid, rows, cols)
      }
  }
  
  fn split_lines(s: &str) -> Vec<String>
      decreases s.len()
  {
      if s.len() == 0 {
          Vec::new()
      } else {
          let newline_pos = find_newline(s, 0);
          if newline_pos == -1 {
              vec![s.to_string()]
          } else if newline_pos == 0 {
              let mut result = vec!["".to_string()];
              result.append(&mut split_lines(&s[1..]));
              result
          } else {
              assert(0 < newline_pos && newline_pos < s.len());
              assert(0 <= newline_pos && newline_pos <= s.len());
              assert(0 <= newline_pos + 1 && newline_pos + 1 <= s.len());
              let mut result = vec![s[..newline_pos as usize].to_string()];
              result.append(&mut split_lines(&s[newline_pos as usize + 1..]));
              result
          }
      }
  }
  
  fn find_newline(s: &str, start: usize) -> i32
      requires start <= s.len()
      ensures (find_newline(s, start) == -1) || (start <= find_newline(s, start) && find_newline(s, start) < s.len())
      decreases s.len() - start
  {
      if start >= s.len() {
          -1
      } else if s.as_bytes()[start] == 10u8 {
          start as i32
      } else {
          find_newline(s, start + 1)
      }
  }
  
  spec fn is_valid_grid(grid: &Vec<Vec<char>>, rows: int, cols: int) -> bool {
      grid.len() == rows &&
      rows >= 0 && cols >= 0 &&
      (forall|i: int| 0 <= i < rows ==> #[trigger] grid[i].len() == cols) &&
      (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> 
          #[trigger] grid[i][j] == '.' || #[trigger] grid[i][j] == '#')
  }
  
  spec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool
      recommends rows > 0 && cols > 0
  {
      i == 0 || i == rows - 1 || j == 0 || j == cols - 1
  }
  
  spec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool
      recommends rows > 0 && cols > 0
  {
      (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||
      (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)
  }
  
  fn count_valid_pipes(grid: &Vec<Vec<char>>, rows: int, cols: int) -> i32
      requires is_valid_grid(grid, rows, cols)
  {
      0
  }

vc-spec: |-
  fn execute_python_logic(input: &str) -> String
      requires valid_input(input)
      ensures valid_output(&execute_python_logic(input))

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}