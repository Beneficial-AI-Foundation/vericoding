vc-description: |-
  Given n buttons and m bulbs, where each button can turn on a specific subset of bulbs,
  determine if it's possible to turn on all m bulbs by pressing some combination of buttons.
  Return "YES" if all bulbs can be turned on, "NO" otherwise.

vc-preamble: |-
  use vstd::prelude::*;
  use vstd::string::*;

  verus! {
  spec fn valid_input(n: nat, m: nat, buttons: Seq<Seq<nat>>) -> bool {
      buttons.len() == n &&
      n >= 1 && m >= 1 &&
      forall|i: int| 0 <= i < n ==> 
          #[trigger] buttons[i].len() >= 0 &&
          forall|j: int| 0 <= j < buttons[i].len() ==> 1 <= #[trigger] buttons[i][j] <= m
  }

  spec fn union_of_all_bulbs(buttons: Seq<Seq<nat>>) -> Set<nat> {
      Set::new(|bulb: nat| 
          exists|i: int, j: int| 
              0 <= i < buttons.len() && 
              0 <= j < buttons[i].len() && 
              #[trigger] buttons[i][j] == bulb
      )
  }

  spec fn can_turn_on_all_bulbs(m: nat, buttons: Seq<Seq<nat>>) -> bool {
      union_of_all_bulbs(buttons).finite() && union_of_all_bulbs(buttons).len() == m
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: u8, m: u8, buttons: Vec<Vec<u8>>) -> (result: String)
      requires
          valid_input(n as nat, m as nat, buttons@.map(|i: int, button: Vec<u8>| button@.map(|j: int, bulb: u8| bulb as nat))),
      ensures
          result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
          (result@ == seq!['Y', 'E', 'S']) <==> can_turn_on_all_bulbs(m as nat, buttons@.map(|i: int, button: Vec<u8>| button@.map(|j: int, bulb: u8| bulb as nat)))

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}