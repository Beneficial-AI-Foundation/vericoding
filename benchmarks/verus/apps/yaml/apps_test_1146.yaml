vc-description: |-
  Given n buttons and m bulbs, where each button can turn on a specific subset of bulbs,
  determine if it's possible to turn on all m bulbs by pressing some combination of buttons.
  Return "YES" if all bulbs can be turned on, "NO" otherwise.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: nat, m: nat, buttons: Seq<Seq<nat>>) -> bool {
      buttons.len() == n &&
      n >= 1 && m >= 1 &&
      forall|i: int| 0 <= i < n ==> forall|j: int| 0 <= j < buttons[i].len() ==> 1 <= buttons[i][j] <= m
  }

  spec fn union_of_all_bulbs(buttons: Seq<Seq<nat>>) -> Set<nat> {
      Set::new(|x: nat| exists|i: int, j: int| 0 <= i < buttons.len() && 0 <= j < buttons[i].len() && buttons[i][j] == x)
  }

  spec fn can_turn_on_all_bulbs(m: nat, buttons: Seq<Seq<nat>>) -> bool {
      union_of_all_bulbs(buttons).len() == m
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: nat, m: nat, buttons: Seq<Seq<nat>>) -> (result: Seq<char>)
      requires
          valid_input(n, m, buttons),
      ensures
          result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O'],
          (result == seq!['Y', 'E', 'S']) <==> can_turn_on_all_bulbs(m, buttons)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
