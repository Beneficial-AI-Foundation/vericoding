vc-description: |-
  Given k game levels represented as n×m grids containing candies (letters) or empty cells ('.'),
  find the minimum cost to transmit all levels. Each level can be transmitted in full (cost: n×m)
  or as differences from a previously transmitted level (cost: d×w where d is number of differing cells).

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
      Seq::empty()
  }
  
  spec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {
      (1, 1, 1, 1)
  }
  
  spec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {
      Seq::empty()
  }
  
  spec fn int_to_string(n: nat) -> Seq<char> {
      Seq::empty()
  }
  
  spec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {
      (1, 0)
  }
  
  spec fn valid_input(stdin_input: Seq<char>) -> bool {
      stdin_input.len() > 0 &&
      stdin_input[stdin_input.len() as int - 1] == '\n' &&
      {
          let lines = split_lines(stdin_input);
          lines.len() >= 1 &&
          exists|n: nat, m: nat, k: nat, w: nat| {
              parse_first_line(lines[0]) == (n, m, k, w) &&
              1 <= n <= 10 && 1 <= m <= 10 && 1 <= k <= 1000 && 1 <= w <= 1000 &&
              lines.len() >= 1 + k * n &&
              (forall|i: int| 1 <= i < 1 + k * n ==> lines[i].len() == m) &&
              (forall|i: int| 1 <= i < 1 + k * n ==> 
                  forall|j: int| 0 <= j < lines[i].len() ==> 
                      (lines[i][j] == '.' || ('a' <= lines[i][j] <= 'z') || ('A' <= lines[i][j] <= 'Z')))
          }
      }
  }
  
  spec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {
      result.len() > 0 &&
      result[result.len() as int - 1] == '\n' &&
      {
          let result_lines = split_lines(result);
          let lines = split_lines(stdin_input);
          lines.len() >= 1 &&
          exists|n: nat, m: nat, k: nat, w: nat, input_levels: Seq<Seq<Seq<char>>>| {
              parse_first_line(lines[0]) == (n, m, k, w) &&
              1 <= n <= 10 && 1 <= m <= 10 && 1 <= k <= 1000 && 1 <= w <= 1000 &&
              lines.len() >= 1 + k * n &&
              input_levels == parse_levels(lines, n, m, k) &&
              input_levels.len() == k &&
              (forall|i: int| 0 <= i < k ==> input_levels[i].len() == n) &&
              (forall|i: int| 0 <= i < k ==> forall|j: int| 0 <= j < n ==> input_levels[i][j].len() == m) &&
      
              result_lines.len() == k + 1 &&
      
              exists|total_cost: nat| {
                  result_lines[0] == int_to_string(total_cost) &&
                  total_cost == calculate_mst_cost(n, m, k, w, input_levels) &&
      
                  (forall|i: int| 1 <= i <= k ==> 
                      exists|level: nat, parent: nat| {
                          parse_dependency_line(result_lines[i]) == (level, parent) &&
                          1 <= level <= k &&
                          0 <= parent <= k &&
                          level != parent
                      }) &&
      
                  (forall|level: int| 1 <= level <= k ==> 
                      exists|i: int| 
                          1 <= i <= k && 
                          parse_dependency_line(result_lines[i]).0 == level &&
                          (forall|j: int| 1 <= j <= k && j != i ==> 
                              parse_dependency_line(result_lines[j]).0 != level)) &&
      
                  is_valid_spanning_tree(result_lines, k)
              }
          }
      }
  }
  
  spec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {
      0
  }
  
  spec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {
      true
  }
  
  spec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {
      0
  }

vc-spec: |-
  fn solve(stdin_input: &str) -> (result: String)
      requires valid_input(stdin_input@)
      ensures valid_output(result@, stdin_input@)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}