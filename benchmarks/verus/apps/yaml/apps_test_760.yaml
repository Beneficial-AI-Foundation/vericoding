vc-description: |-
  Given a string s and integer k, find the maximum possible length of a tandem repeat substring
  that can appear after appending k characters to s. A tandem repeat of length 2n has its first
  half exactly matching its second half.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn is_tandem_repeat(s: Seq<char>) -> bool {
      if s.len() % 2 != 0 {
          false
      } else {
          let half_len = s.len() / 2;
          let first_half = s.subrange(0, half_len as int);
          let second_half = s.subrange(half_len as int, s.len() as int);
          forall|i: int| 0 <= i < half_len ==> 
              (first_half[i] == '*' || second_half[i] == '*' || first_half[i] == second_half[i])
      }
  }

vc-spec: |-
  fn solve(s: Seq<char>, k: int) -> (result: int)
      requires 
          k >= 1,
          s.len() >= 1,
      ensures 
          result >= 0,
          result % 2 == 0,
          result <= s.len() + k,
          forall|i: int, n: int| 0 <= i < s.len() + k && 2 <= n <= s.len() + k - i && n % 2 == 0 && 
              is_tandem_repeat((s + Seq::new(k as nat, |j: int| '*')).subrange(i, i + n)) ==> n <= result,
          result == 0 ==> forall|i: int, n: int| 0 <= i < s.len() + k && 2 <= n <= s.len() + k - i && n % 2 == 0 ==> 
              !is_tandem_repeat((s + Seq::new(k as nat, |j: int| '*')).subrange(i, i + n)),
          result > 0 ==> exists|i: int, n: int| 0 <= i < s.len() + k && 2 <= n <= s.len() + k - i && n % 2 == 0 && 
              (is_tandem_repeat((s + Seq::new(k as nat, |j: int| '*')).subrange(i, i + n)) && n == result),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}