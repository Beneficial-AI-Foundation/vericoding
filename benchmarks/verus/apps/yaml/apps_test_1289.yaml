vc-description: |-
  Given n bus stops at positions a_i (sorted in increasing order), a bus travels back and forth 
  between stops 1 and n in order: 1→2→...→n→(n-1)→...→1→2→... repeatedly.
  Given a segment of the bus journey as a sorted list of stop numbers with their visit frequencies,
  calculate the total distance traveled during this segment, or return -1 if the distance cannot 
  be uniquely determined.
  
  /* Since |visits| >= 1, there must be at least one visit */
  
  /* This means at least one count > 0, so if allZero then maxRounds >= 1 */

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn is_sorted(s: Seq<int>) -> bool {
      forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
  }
  
  spec fn all_distances_equal(positions: Seq<int>) -> bool {
      if positions.len() <= 2 {
          true
      } else {
          let first_dist = positions[1] - positions[0];
          forall|i: int| 1 <= i < positions.len() - 1 ==> positions[i + 1] - positions[i] == first_dist
      }
  }
  
  spec fn count_visits(visits: Seq<int>, target: int) -> int
      decreases visits.len()
  {
      if visits.len() == 0 {
          0
      } else if visits[0] == target {
          1 + count_visits(visits.subrange(1, visits.len() as int), target)
      } else {
          count_visits(visits.subrange(1, visits.len() as int), target)
      }
  }
  
  spec fn max_val(s: Seq<int>) -> int {
      if s.len() == 0 {
          0
      } else if s.len() == 1 {
          s[0]
      } else {
          let rest_max = max_val(s.subrange(1, s.len() as int));
          if s[0] > rest_max { s[0] } else { rest_max }
      }
  }
  
  spec fn min(a: int, b: int) -> int {
      if a < b { a } else { b }
  }
  
  spec fn sum(s: Seq<int>) -> int
      decreases s.len()
  {
      if s.len() == 0 {
          0
      } else {
          s[0] + sum(s.subrange(1, s.len() as int))
      }
  }
  
  spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> {
      let base_counts = Seq::new(n as nat, |i: int| count_visits(visits, i + 1));
      Seq::new(n as nat, |i: int| 
          if i == 0 || i == n - 1 {
              base_counts[i] * 2
          } else {
              base_counts[i]
          }
      )
  }
  
  spec fn compute_max_rounds(counts: Seq<int>) -> int {
      max_val(Seq::new(counts.len(), |i: int| counts[i] / 2))
  }
  
  spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool {
      let counts = compute_counts(n, visits);
      let max_rounds = compute_max_rounds(counts);
      let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);
      let all_zero = forall|i: int| 0 <= i < n ==> remaining_counts[i] == 0;
  
      all_zero && n > 2 && !all_distances_equal(positions)
  }
  
  spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int {
      let counts = compute_counts(n, visits);
      let max_rounds = compute_max_rounds(counts);
      let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);
      let all_zero = forall|i: int| 0 <= i < n ==> remaining_counts[i] == 0;
  
      if all_zero {
          if n == 2 {
              max_rounds * (positions[1] - positions[0]) * 2 - (positions[1] - positions[0])
          } else {
              let first_dist = positions[1] - positions[0];
              max_rounds * first_dist * 2 * (n - 1) - first_dist
          }
      } else {
          let edge_distance = sum(Seq::new((n-1) as nat, |i: int| min(remaining_counts[i], remaining_counts[i+1]) * (positions[i+1] - positions[i])));
          let total_edge_length = sum(Seq::new((n-1) as nat, |i: int| positions[i+1] - positions[i]));
          edge_distance + max_rounds * 2 * total_edge_length
      }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(n: int, positions: Seq<int>, m: int, visits: Seq<int>) -> (result: int)
      requires 
          n >= 2,
          positions.len() == n,
          m >= 1,
          visits.len() == m,
          forall|i: int| 0 <= i < visits.len() ==> 1 <= visits[i] <= n,
          forall|i: int| 0 <= i < n - 1 ==> positions[i] < positions[i + 1],
          forall|i: int| 0 <= i < positions.len() ==> positions[i] >= 1,
          is_sorted(visits)
      ensures 
          result >= (-1),
          result == (-1) <==> has_ambiguous_path(n, positions, visits),
          result >= 0 ==> result == calculate_total_distance(n, positions, visits),
          result >= 0 ==> (forall|i: int| 0 <= i < n-1 ==> positions[i+1] - positions[i] > 0)

vc-code: |-
  {
      // impl-start
      assume(false);
      (-1)
      // impl-end
  }

vc-postamble: |-

  }
  
  fn main() {}