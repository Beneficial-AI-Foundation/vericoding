vc-description: |-
  Given a DNA base represented by a single letter (A, C, G, or T), find its complementary base
  according to the pairing rules: A pairs with T, T pairs with A, C pairs with G, G pairs with C

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_dna_base(c: char) -> bool {
      c == 'A' || c == 'T' || c == 'C' || c == 'G'
  }
  
  spec fn dna_complement(c: char) -> char 
      requires valid_dna_base(c)
  {
      match c {
          'A' => 'T',
          'T' => 'A', 
          'C' => 'G',
          'G' => 'C',
      }
  }

  spec fn find_newline(input: Seq<char>) -> int
      requires exists|i: int| 0 <= i < input.len() && input[i] == '\n'
  {
      choose|i: int| 0 <= i < input.len() && input[i] == '\n'
  }
  
  spec fn valid_input(input: Seq<char>) -> bool {
      let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\n' {
          input.subrange(0, find_newline(input))
      } else {
          input
      };
      input_line.len() == 1 && valid_dna_base(input_line[0])
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
      requires stdin_input.len() > 0
      ensures ({
          let input_line = if exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n' {
              stdin_input.subrange(0, find_newline(stdin_input))
          } else {
              stdin_input
          };
          if valid_input(stdin_input) {
              result == seq![dna_complement(input_line[0]), '\n']
          } else {
              result == Seq::<char>::empty()
          }
      })

vc-code: |-
  {
      assume(false);
      Seq::<char>::empty()
  }

vc-postamble: |-

  }

  fn main() {}