vc-description: |-
  Given a 1Ã—n grid where Alice claims to have placed k ships of size a (consecutive cells)
  such that no two ships intersect or touch, and Bob makes m shots that all "miss",
  determine the first shot after which we can be certain Alice is cheating
  (i.e., it becomes impossible to place k non-intersecting, non-touching ships without hitting a shot).

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {
      n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&
      (forall|i: int| 0 <= i < shots.len() ==> 1 <= shots[i] <= n)
  }
  
  spec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool
      decreases shots.len() - num_shots
  {
      if !(n > 0 && k > 0 && a > 0 && num_shots >= 0) {
          false
      } else if !(num_shots <= shots.len()) {
          false
      } else if !(forall|i: int| 0 <= i < shots.len() ==> 1 <= shots[i] <= n) {
          false
      } else {
          let hit_cells = Set::new(|i: int| 0 <= i < num_shots && i < shots.len(), |i: int| shots[i]);
          greedy_ship_placement(n, k, a, hit_cells) >= k
      }
  }
  
  spec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int {
      if !(n > 0 && k > 0 && a > 0) {
          0
      } else if !(forall|cell: int| hit_cells.contains(cell) ==> 1 <= cell <= n) {
          0
      } else {
          greedy_place_ships_from_position(1, n, k, a, hit_cells)
      }
  }
  
  spec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int
      decreases n - pos + 1, k
  {
      if !(pos >= 1 && n > 0 && k >= 0 && a > 0) {
          0
      } else if !(forall|cell: int| hit_cells.contains(cell) ==> 1 <= cell <= n) {
          0
      } else {
          if pos > n || k == 0 {
              0
          } else if pos + a - 1 <= n && (forall|cell: int| pos <= cell <= pos + a - 1 ==> !hit_cells.contains(cell)) {
              1 + greedy_place_ships_from_position(pos + a + 1, n, k - 1, a, hit_cells)
          } else {
              greedy_place_ships_from_position(pos + 1, n, k, a, hit_cells)
          }
      }
  }
  
  spec fn is_natural_number_string(s: Seq<char>) -> bool {
      s.len() > 0 && s[0] != '0' && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9')
  }
  
  spec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>> {
      if input.len() > 0 {
          seq![]
      } else {
          seq![]
      }
  }
  
  spec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {
      (1, 1, 1)
  }
  
  spec fn parse_int_spec(line: Seq<char>) -> int {
      0
  }
  
  spec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {
      seq![]
  }
  
  spec fn int_to_string_spec(value: int) -> Seq<char> {
      if value >= 1 {
          seq!['1']
      } else {
          seq!['1']
      }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: &str) -> (result: String)
      requires
          stdin_input.len() > 0,
      requires
          stdin_input@[stdin_input@.len()-1] == '\n',
      ensures
          result.len() > 0,
      ensures
          result@[result@.len()-1] == '\n',
      ensures
          result == "-1\n" || (exists|shot_num_str: Seq<char>| shot_num_str.len() > 0 && 
              result@ == shot_num_str + seq!['\n'] && is_natural_number_string(shot_num_str)),
      ensures
          {
              let lines = parse_input_spec(stdin_input@);
              if lines.len() >= 3 {
                  let first_line = parse_three_ints_spec(lines[0]);
                  let (n, k, a) = (first_line.0, first_line.1, first_line.2);
                  let m = parse_int_spec(lines[1]);
                  let shots = parse_int_array_spec(lines[2]);
                  if valid_input(n, k, a, m, shots) {
                      if can_place_ships_func(n, k, a, shots, m) {
                          result == "-1\n"
                      } else {
                          exists|shot_idx: int| 1 <= shot_idx <= m && 
                                             result@ == int_to_string_spec(shot_idx) + seq!['\n'] &&
                                             !can_place_ships_func(n, k, a, shots, shot_idx) &&
                                             (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))
                      }
                  } else {
                      true
                  }
              } else {
                  true
              }
          },

vc-code: |-
  {
      // impl-start
      assume(false);
      String::new()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}