vc-description: |-
  Given a positive integer n, express it as a sum of composite numbers using the maximum possible number of summands.
  A composite number is an integer greater than 1 that is not prime (has positive divisors other than 1 and itself).
  For each query, return the maximum number of composite summands, or -1 if no such splitting exists.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn is_composite(x: int) -> bool {
      x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0
  }

  spec fn valid_input(queries: Seq<int>) -> bool {
      forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1
  }

  spec fn max_composite_summands(n: int) -> int {
      if n % 4 == 0 {
          n / 4
      } else if n % 4 == 1 && n / 4 >= 2 {
          n / 4 - 1
      } else if n % 4 == 2 && n / 4 >= 1 {
          n / 4
      } else if n % 4 == 3 && n / 4 >= 3 {
          n / 4 - 1
      } else {
          -1
      }
  }

  spec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {
      results.len() == queries.len() &&
      forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&
      forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1
  }

vc-helpers: |

vc-spec: |-
  fn solve(queries: Seq<int>) -> (results: Seq<int>)
      requires valid_input(queries)
      ensures valid_result(queries, results)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
