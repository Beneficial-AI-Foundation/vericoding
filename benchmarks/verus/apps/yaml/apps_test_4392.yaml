vc-description: |-
  Given an array and a set of allowed swap positions, determine if the array can be sorted 
  in non-decreasing order using only adjacent swaps at the allowed positions. An allowed swap
  exchanges elements at positions i and i+1 if position i is in the allowed set.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {
      a.len() > 1 && allowed_pos.len() == a.len()
  }
  
  spec fn is_sorted(a: Seq<int>) -> bool
      decreases a.len()
  {
      if a.len() <= 1 {
          true
      } else {
          a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))
      }
  }
  
  spec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {
      original.len() == target.len() && target.len() == allowed.len() &&
      original.to_multiset() == target.to_multiset()
  }
  
  spec fn sort_sequence(s: Seq<int>) -> Seq<int>
      decreases s.len()
  {
      if s.len() <= 1 {
          s
      } else {
          bubble_sort_seq(s)
      }
  }
  
  spec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>
      decreases s.len()
  {
      if s.len() <= 1 {
          s
      } else {
          bubble_sort_helper(s, s.len() as nat)
      }
  }
  
  spec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>
      decreases passes
  {
      if passes == 0 {
          s
      } else {
          bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)
      }
  }
  
  spec fn bubble_pass(s: Seq<int>) -> Seq<int>
      decreases s.len()
  {
      if s.len() <= 1 {
          s
      } else {
          bubble_pass_helper(s, 0)
      }
  }
  
  spec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>
      decreases if pos <= s.len() { s.len() - pos } else { 0 }
  {
      if pos >= s.len() || pos >= s.len() - 1 {
          s
      } else if s[pos as int] > s[(pos + 1) as int] {
          bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)
      } else {
          bubble_pass_helper(s, pos + 1)
      }
  }

vc-helpers: |-

vc-spec: |-
  fn can_sort(a: &mut Vec<int>, allowed_pos: &[bool]) -> (result: bool)
      requires 
          valid_input(old(a)@, allowed_pos@),
      ensures 
          a@.to_multiset() == old(a)@.to_multiset(),
          result == is_sorted(a@),

vc-code: |-
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}