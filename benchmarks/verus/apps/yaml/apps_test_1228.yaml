vc-description: |-
  Given a current HP value, determine how much to increase it (by 0, 1, or 2) to achieve the highest possible category.
  HP categories are defined by remainder when divided by 4:
  Category A: remainder 1 (highest priority), Category B: remainder 3, Category C: remainder 2, Category D: remainder 0 (lowest priority)
  Priority order: A > B > C > D

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
      spec fn get_category(hp: int) -> char {
          let remainder = hp % 4;
          if remainder == 1 {
              'A'
          } else if remainder == 3 {
              'B'
          } else if remainder == 2 {
              'C'
          } else {
              'D'
          }
      }
      
      spec fn valid_input(n: int) -> bool {
          30 <= n <= 100
      }
      
      spec fn valid_output(a: int, b: char) -> bool {
          0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')
      }
      
      spec fn optimal_choice(n: int, a: int, b: char) -> bool {
          b == get_category(n + a) &&
          ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&
          ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&
          ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&
          ((n % 4 == 0) ==> (a == 1 && b == 'A'))
      }

vc-helpers: |-

vc-spec: |-
  fn solve(n: i32) -> (result: (i32, char))
      requires 
          30 <= n <= 100
      ensures 
          0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),
          optimal_choice(n as int, result.0 as int, result.1),
          result.1 == 'A' || result.1 == 'B'

vc-code: |-
  {
      assume(false);
      (0, 'A')
  }

vc-postamble: |-
  }

  fn main() {}