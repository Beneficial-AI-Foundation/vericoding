vc-description: |-
  Given a sequence of movement commands for a robot on an infinite grid, find the maximum number of commands 
  that could be executed such that the robot returns to its starting position (0, 0). The robot can move 
  U (up), D (down), L (left), or R (right). To return to origin, we need equal numbers of L/R movements 
  and equal numbers of U/D movements.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn count_char(s: Seq<char>, c: char) -> int
      decreases s.len()
  {
      if s.len() == 0 {
          0int
      } else {
          (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)
      }
  }

  spec fn min(a: int, b: int) -> int {
      if a <= b { a } else { b }
  }

  spec fn valid_commands(commands: Seq<char>) -> bool {
      forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: usize, commands: Vec<char>) -> (result: usize)
      requires 
          n >= 0,
          commands@.len() == n,
          valid_commands(commands@)
      ensures 
          result >= 0,
          result <= n,
          result % 2 == 0,
          result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + 
                           2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))

vc-code: |-
  {
      assume(false);
      0
  }

vc-postamble: |2-

  }

  fn main() {}