vc-description: |-
  Given n problems numbered 1 to n in ascending order of difficulty and m pairs 
  of similar problems, split the problems into two non-empty divisions such that:
  1. Each problem belongs to exactly one division
  2. All problems in division 1 are harder than all problems in division 2  
  3. Similar problems must be in different divisions
  Count the number of valid ways to make this split.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: int, m: int, pairs: Seq<(int, int)>) -> bool {
      n >= 2 && 
      m >= 0 && 
      pairs.len() == m &&
      (forall|i: int| 0 <= i < pairs.len() ==> 1 <= pairs[i].0 <= n && 1 <= pairs[i].1 <= n) &&
      (forall|i: int| 0 <= i < pairs.len() ==> pairs[i].0 != pairs[i].1)
  }

  spec fn compute_final_l(pairs: Seq<(int, int)>) -> int
      decreases pairs.len()
  {
      if pairs.len() == 0 {
          1
      } else {
          let x = pairs[pairs.len() - 1].0;
          let y = pairs[pairs.len() - 1].1;
          let min_val = if x < y { x } else { y };
          let rest_l = compute_final_l(pairs.subrange(0, pairs.len() - 1));
          if rest_l > min_val { rest_l } else { min_val }
      }
  }

  spec fn compute_final_r(n: int, pairs: Seq<(int, int)>) -> int
      decreases pairs.len()
  {
      if pairs.len() == 0 {
          n
      } else {
          let x = pairs[pairs.len() - 1].0;
          let y = pairs[pairs.len() - 1].1;
          let max_val = if x > y { x } else { y };
          let rest_r = compute_final_r(n, pairs.subrange(0, pairs.len() - 1));
          if rest_r < max_val { rest_r } else { max_val }
      }
  }

  spec fn max(a: int, b: int) -> int {
      if a > b { a } else { b }
  }

  spec fn valid_result(n: int, pairs: Seq<(int, int)>, result: int) -> bool {
      result >= 0 &&
      result <= n - 1 &&
      result == max(compute_final_r(n, pairs) - compute_final_l(pairs), 0)
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: int, m: int, pairs: Seq<(int, int)>) -> (result: int)
      requires valid_input(n, m, pairs)
      ensures valid_result(n, pairs, result)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
