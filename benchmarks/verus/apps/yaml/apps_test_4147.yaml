vc-description: |-
  Given N bamboos with lengths, find minimum magic points (MP) to create exactly three bamboos 
  with target lengths A, B, and C. Operations: Extension Magic (1 MP per unit), Shortening Magic 
  (1 MP per unit), Composition Magic (10 MP to combine two bamboos). Input format: first line 
  contains N A B C, followed by N lines with bamboo lengths. Output minimum MP needed.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(input: Seq<char>) -> bool {
      exists|lines: Seq<Seq<char>>| (lines == split_lines(input) &&
      lines.len() >= 2 &&
      exists|n: nat, a: nat, b: nat, c: nat| 
          parse_first_line_bamboo(lines[0]) == (n, a, b, c) &&
          3 <= n <= 8 &&
          1 <= c < b < a <= 1000 &&
          lines.len() >= n + 1 &&
          forall|i: int| 1 <= i <= n ==> {
              let li = parse_bamboo_length(lines[i]);
              1 <= li <= 1000
          })
  }
  
  spec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {
      valid_input(input) &&
      exists|lines: Seq<Seq<char>>, n: nat, a: nat, b: nat, c: nat| 
          lines == split_lines(input) &&
          parse_first_line_bamboo(lines[0]) == (n, a, b, c) &&
          assignment.len() == n &&
          (forall|i: int| 0 <= i < n ==> assignment[i] < 4) &&
          has_all_three_groups(assignment)
  }
  
  spec fn has_all_three_groups(assignment: Seq<nat>) -> bool {
      (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&
      (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&
      (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)
  }
  
  spec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat
      recommends valid_input(input) && valid_assignment(input, assignment)
  {
      composition_cost(assignment) + adjustment_cost(input, assignment)
  }
  
  spec fn composition_cost(assignment: Seq<nat>) -> nat {
      let group_a_size = count_group_members(assignment, 1);
      let group_b_size = count_group_members(assignment, 2);
      let group_c_size = count_group_members(assignment, 3);
      (if group_a_size > 0 { (group_a_size - 1) * 10 } else { 0 }) as nat +
      (if group_b_size > 0 { (group_b_size - 1) * 10 } else { 0 }) as nat +
      (if group_c_size > 0 { (group_c_size - 1) * 10 } else { 0 }) as nat
  }
  
  spec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat
      recommends valid_input(input) && valid_assignment(input, assignment)
  {
      let lines = split_lines(input);
      let (n, a, b, c) = parse_first_line_bamboo(lines[0]);
      let sum_a = calculate_group_sum(input, assignment, 1);
      let sum_b = calculate_group_sum(input, assignment, 2);
      let sum_c = calculate_group_sum(input, assignment, 3);
      abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)
  }
  
  spec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat
      decreases assignment.len()
  {
      if assignment.len() == 0 { 
          0nat 
      } else { 
          (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.subrange(1, assignment.len() as int), group)
      }
  }
  
  spec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat
      recommends valid_input(input)
  {
      0nat
  }
  
  spec fn abs_diff(a: nat, b: nat) -> nat {
      if a >= b { sub(a, b) } else { sub(b, a) }
  }
  
  spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
      seq![]
  }
  
  spec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {
      (0nat, 0nat, 0nat, 0nat)
  }
  
  spec fn parse_bamboo_length(line: Seq<char>) -> nat {
      0nat
  }
  
  spec fn int_to_string_spec(n: nat) -> Seq<char> {
      seq!['0']
  }
  
  fn int_to_string(n: nat) -> (result: Vec<char>)
      ensures
          result@ == int_to_string_spec(n),
          result.len() > 0,
  {
      vec!['0']
  }
  
  spec fn string_to_int(s: Seq<char>) -> nat {
      0nat
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
      requires 
          stdin_input.len() > 0,
          stdin_input[stdin_input.len() - 1] == '\n' || exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n',
          valid_input(stdin_input@ + (if stdin_input[stdin_input.len() - 1] == '\n' { seq![] } else { seq!['\n'] })),
      ensures
          result.len() > 0,
          result[result.len() - 1] == '\n',
          exists|val: nat| val >= 0 && result@ == int_to_string_spec(val) + seq!['\n'],
          forall|assignment: Seq<nat>| valid_assignment(stdin_input@ + (if stdin_input[stdin_input.len() - 1] == '\n' { seq![] } else { seq!['\n'] }), assignment) ==>
              string_to_int(result@.subrange(0, result.len() - 1)) <= calculate_assignment_cost(stdin_input@ + (if stdin_input[stdin_input.len() - 1] == '\n' { seq![] } else { seq!['\n'] }), assignment),

vc-code: |-
  {
      // impl-start
      assume(false);
      vec!['0', '\n']
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}