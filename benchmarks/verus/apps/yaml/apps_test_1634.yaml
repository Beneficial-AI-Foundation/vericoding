vc-description: |-
  Given ticket costs and transportation usage, find the minimum cost to buy tickets.
  There are 4 ticket types: individual ride cost, unlimited rides on one vehicle,
  unlimited rides on all buses OR all trolleys, and unlimited rides on everything.
  Input includes 4 costs and arrays of ride counts for buses and trolleys.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_costs(c: &[int]) -> bool {
    c.len() == 4 &&
    c[0] >= 1 && c[1] >= 1 && c[2] >= 1 && c[3] >= 1 &&
    c[0] <= 1000 && c[1] <= 1000 && c[2] <= 1000 && c[3] <= 1000
  }
  
  spec fn valid_rides(rides: &[int]) -> bool {
    rides.len() >= 1 && rides.len() <= 1000 &&
    forall|i: int| 0 <= i < rides.len() ==> 0 <= rides[i] <= 1000
  }
  
  spec fn sum_array(arr: Seq<int>) -> int
    decreases arr.len()
  {
    if arr.len() == 0 {
      0
    } else {
      arr[0] + sum_array(arr.subrange(1, arr.len() as int))
    }
  }
  
  spec fn optimized_cost(rides: Seq<int>, individual_cost: int, unlimited_cost: int) -> int {
    let initial_cost = sum_array(rides) * individual_cost;
    min_with_unlimited(rides, initial_cost, individual_cost, unlimited_cost, 0)
  }
  
  spec fn min_with_unlimited(rides: Seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int) -> int
    decreases rides.len() - index
  {
    if index >= rides.len() {
      current_cost
    } else {
      let new_cost = current_cost - rides[index] * individual_cost + unlimited_cost;
      let updated_cost = if new_cost < current_cost && new_cost >= 0 { new_cost } else { current_cost };
      min_with_unlimited(rides, updated_cost, individual_cost, unlimited_cost, index + 1)
    }
  }
  
  spec fn min5(a: int, b: int, c: int, d: int, e: int) -> int {
    let min_ab = if a <= b { a } else { b };
    let min_cd = if c <= d { c } else { d };
    let min_abcd = if min_ab <= min_cd { min_ab } else { min_cd };
    if min_abcd <= e { min_abcd } else { e }
  }
  
  spec fn correct_result(c: &[int], a: &[int], b: &[int], result: int) -> bool {
    result == min5(
      optimized_cost(a@, c[0], c[1]) + optimized_cost(b@, c[0], c[1]),
      optimized_cost(a@, c[0], c[1]) + c[2],
      optimized_cost(b@, c[0], c[1]) + c[2],
      c[2] + c[2],
      c[3]
    )
  }

vc-helpers: |-

vc-spec: |-
  fn solve(c: &[int], a: &[int], b: &[int]) -> (result: int)
    requires 
      valid_costs(c) &&
      valid_rides(a) &&
      valid_rides(b)
    ensures 
      result >= 0 &&
      correct_result(c, a, b, result) &&
      result <= min5(sum_array(a@) * c[0] + sum_array(b@) * c[0], 
                    sum_array(a@) * c[0] + c[2],
                    sum_array(b@) * c[0] + c[2],
                    c[2] + c[2],
                    c[3])

vc-code: |-
  {
    assume(false);
    unreached()
  }

vc-postamble: |-

  }

  fn main() {}