vc-description: |-
  Given N checkpoints with coordinates (x_i, y_i) and times t_i, determine if it's possible 
  to visit each checkpoint at the specified time, starting from (0,0) at time 0. 
  At each time step, you must move to an adjacent cell (up, down, left, right) and cannot 
  stay in the same position.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  #[derive(Clone, Copy, PartialEq, Eq)]
  pub struct Checkpoint {
      pub t: int,
      pub x: int,
      pub y: int,
  }

  spec fn valid_input_format(input: &str) -> bool {
      let lines = split_lines(input);
      lines.len() > 0 && is_valid_integer(&lines[0]) && {
          let n = parse_int(&lines[0]);
          n >= 0 && n + 1 == lines.len() &&
          (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(&lines[i]))
      }
  }

  spec fn can_visit_all_checkpoints(input: &str) -> bool 
      recommends valid_input_format(input)
  {
      let lines = split_lines(input);
      let n = parse_int(&lines[0]);
      if n == 0 { 
          true 
      } else {
          let checkpoints = parse_checkpoints(&lines.subrange(1, lines.len() as int));
          checkpoints.len() == n &&
          checkpoints_feasible(&checkpoints, 0, 0, 0)
      }
  }

  spec fn checkpoints_feasible(checkpoints: &Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool {
      if checkpoints.len() == 0 { 
          true 
      } else {
          let cp = checkpoints[0];
          let dt = cp.t - current_t;
          let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };
          let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };
          let dis = dx + dy;
          if dt < dis { 
              false 
          } else if (dt - dis) % 2 != 0 { 
              false 
          } else { 
              checkpoints_feasible(&checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) 
          }
      }
  }

  spec fn split_lines(input: &str) -> Seq<String> {
      Seq::empty()
  }

  spec fn is_valid_integer(s: &str) -> bool {
      true
  }

  spec fn parse_int(s: &str) -> int {
      0
  }

  spec fn is_valid_checkpoint_line(s: &str) -> bool {
      true
  }

  spec fn parse_checkpoints(lines: &Seq<String>) -> Seq<Checkpoint> {
      Seq::empty()
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: &str) -> (result: String)
      requires 
          stdin_input.len() > 0,
          valid_input_format(stdin_input),
      ensures 
          result == "Yes\n" || result == "No\n",
          (result == "Yes\n") <==> can_visit_all_checkpoints(stdin_input),

vc-code: |-
  {
      assume(false);
      String::new()
  }

vc-postamble: |-

  }

  fn main() {}