vc-description: |-
  Given a tree with n nodes, determine the maximum number of edges that can be added 
  while maintaining the bipartite property and keeping the graph simple (no loops or multiple edges).
  Since any tree is bipartite, we can 2-color it into partitions of sizes a and b.
  A complete bipartite graph has a×b edges, and the tree has n-1 edges, so answer is a×b-(n-1).

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn is_connected_tree(n: int, edges: Seq<(int, int)>) -> bool {
      n >= 1 && edges.len() == n - 1 &&
      (n == 1 ==> edges.len() == 0) &&
      (n > 1 ==> is_connected_graph(n, edges))
  }
  
  spec fn is_connected_graph(n: int, edges: Seq<(int, int)>) -> bool {
      n > 1 ==>
      (forall|node: int| 2 <= node <= n ==> 
          can_reach_node_one(node, edges, n))
  }
  
  spec fn can_reach_node_one(target: int, edges: Seq<(int, int)>, max_depth: int) -> bool
      decreases max_depth
  {
      if max_depth <= 0 { 
          false
      } else if target == 1 { 
          true
      } else {
          exists|i: int| 0 <= i < edges.len() && 
              ((edges[i].0 == target && can_reach_node_one(edges[i].1, edges, max_depth - 1)) ||
               (edges[i].1 == target && can_reach_node_one(edges[i].0, edges, max_depth - 1)))
      }
  }
  
  spec fn valid_tree_input(n: int, edges: Seq<(int, int)>) -> bool {
      n >= 1 &&
      edges.len() == n - 1 &&
      (forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n) &&
      (forall|i: int| 0 <= i < edges.len() ==> edges[i].0 != edges[i].1) &&
      (forall|i: int, j: int| 0 <= i < j < edges.len() ==> 
          !(edges[i].0 == edges[j].0 && edges[i].1 == edges[j].1) && 
          !(edges[i].0 == edges[j].1 && edges[i].1 == edges[j].0)) &&
      (n == 1 ==> edges.len() == 0) &&
      (n > 1 ==> (forall|node: int| #![trigger node] 1 <= node <= n ==> 
          (exists|i: int| 0 <= i < edges.len() && (edges[i].0 == node || edges[i].1 == node)))) &&
      is_connected_tree(n, edges)
  }

vc-helpers: |-

vc-spec: |-
  fn solve(n: int, edges: Seq<(int, int)>) -> (result: int)
      requires valid_tree_input(n, edges)
      ensures 
          result >= 0 &&
          (exists|blue: int, red: int| 
              blue >= 0 && red >= 0 && blue + red == n && result == blue * red - (n - 1)) &&
          (n == 1 ==> result == 0int) &&
          (n == 2 ==> result == 0int) &&
          (n > 2 ==> exists|blue: int, red: int| 
              blue > 0 && red > 0 && blue + red == n && result == blue * red - (n - 1)) &&
          result <= (n * n) / 4 - (n - 1) + (if n % 2 == 0 { 0int } else { 1int })

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}