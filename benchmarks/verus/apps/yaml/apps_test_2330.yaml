vc-description: |-
  Given n fridges with weights a₁, a₂, ..., aₙ, create exactly m steel chains between fridges 
  such that all fridges are "private". A chain connecting fridges u and v costs aᵤ + aᵥ. 
  A fridge is "private" if only its owner can unlock it. Find the minimum total cost to create 
  exactly m chains making all fridges private, or determine if impossible.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  pub enum Result {
      Impossible,
      Possible { cost: int, edges: Seq<(int, int)> }
  }
  
  spec fn seq_sum(s: Seq<int>) -> int
      decreases s.len()
  {
      if s.len() == 0 { 0 } else { s[0] + seq_sum(s.subrange(1, s.len() as int)) }
  }
  
  spec fn seq_sum_first(s: Seq<int>, n: int) -> int
      decreases n
  {
      if n == 0 { 0 } else { s[n-1] + seq_sum_first(s, n-1) }
  }
  
  spec fn min_index(weights: Seq<int>) -> int {
      min_index_helper(weights, 0, 1)
  }
  
  spec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int
      decreases weights.len() - next
  {
      if next >= weights.len() { current_min }
      else if weights[next] < weights[current_min] { min_index_helper(weights, next, next + 1) }
      else { min_index_helper(weights, current_min, next + 1) }
  }
  
  spec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {
      let first_valid = if exclude == 0 { 1 } else { 0 };
      min_index_excluding_helper(weights, exclude, first_valid, 0)
  }
  
  spec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int
      decreases weights.len() - next
  {
      if next >= weights.len() { current_min }
      else if next == exclude { min_index_excluding_helper(weights, exclude, current_min, next + 1) }
      else if weights[next] < weights[current_min] { min_index_excluding_helper(weights, exclude, next, next + 1) }
      else { min_index_excluding_helper(weights, exclude, current_min, next + 1) }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(t: int, cases: Seq<(int, int, Seq<int>)>) -> (results: Seq<Result>)
      requires 
          t >= 0,
          cases.len() == t,
          forall|i: int| 0 <= i < t ==> 
              cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2.len() == cases[i].0,
      ensures 
          results.len() == t,
          forall|i: int| 0 <= i < t ==> 
              {
                  let n = cases[i].0;
                  let m = cases[i].1;
                  (n <= 2 || m < n) ==> matches!(results.index(i), Result::Impossible)
              },
          forall|i: int| 0 <= i < t ==> 
              {
                  let n = cases[i].0;
                  let m = cases[i].1;
                  let weights = cases[i].2;
                  (n > 2 && m >= n && matches!(results.index(i), Result::Possible { .. })) ==> 
                      match results.index(i) {
                          Result::Possible { edges, .. } => {
                              edges.len() == m &&
                              (forall|j: int| 0 <= j < edges.len() ==> 
                                  1 <= edges[j].0 <= n && 1 <= edges[j].1 <= n &&
                                  edges[j].0 != edges[j].1)
                          },
                          _ => true
                      }
              },
          forall|i: int| 0 <= i < t ==> 
              {
                  let n = cases[i].0;
                  let m = cases[i].1;
                  let weights = cases[i].2;
                  (n > 2 && m >= n && matches!(results.index(i), Result::Possible { .. })) ==> 
                      {
                          let min1_idx = min_index(weights);
                          let min2_idx = min_index_excluding(weights, min1_idx);
                          match results.index(i) {
                              Result::Possible { cost, .. } => 
                                  cost == 2 * seq_sum(weights) + (m - n) * (weights[min1_idx] + weights[min2_idx]),
                              _ => true
                          }
                      }
              },
          forall|i: int| 0 <= i < t ==> 
              {
                  let n = cases[i].0;
                  let m = cases[i].1;
                  (n > 2 && m >= n && matches!(results.index(i), Result::Possible { .. })) ==> 
                      match results.index(i) {
                          Result::Possible { edges, .. } => {
                              (forall|j: int| 0 <= j < n ==> 
                                  edges[j] == (j + 1, if j == n - 1 { 1 } else { j + 2 })) &&
                              (forall|j: int| n <= j < m ==> 
                                  {
                                      let min1_idx = min_index(cases[i].2);
                                      let min2_idx = min_index_excluding(cases[i].2, min1_idx);
                                      edges[j] == (min1_idx + 1, min2_idx + 1)
                                  })
                          },
                          _ => true
                      }
              },

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}