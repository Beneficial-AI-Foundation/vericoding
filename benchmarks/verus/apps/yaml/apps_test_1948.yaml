vc-description: |-
  Given an undirected tree with n vertices rooted at vertex 1, Alice starts at vertex 1 and Bob starts at vertex x.
  Players alternate turns with Bob going first. Each turn a player can stay at current vertex or move to adjacent vertex.
  Game ends when Alice reaches Bob's vertex. Alice minimizes total moves, Bob maximizes total moves.
  Find the total number of moves in optimal play.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(n: int, x: int, edges: Seq<(int, int)>) -> bool {
    n > 0 && 1 <= x <= n && edges.len() == n - 1 &&
    forall|e: (int, int)| edges.contains(e) ==> 0 <= e.0 < n && 0 <= e.1 < n
  }

  spec fn valid_distances(way_a: Seq<int>, way_b: Seq<int>, n: int, x: int) -> bool {
    way_a.len() == n && way_b.len() == n && n > 0 && 1 <= x <= n &&
    way_a[0] == 0 && way_b[x-1] == 0 &&
    forall|i: int| 0 <= i < n ==> way_a[i] >= 0 && way_b[i] >= 0
  }

  spec fn valid_leaves(leaves: Seq<int>, edges: Seq<(int, int)>, n: int) -> bool {
    valid_input(n, 1, edges) ==>
    (forall|i: int| 0 <= i < leaves.len() ==> 0 <= leaves[i] < n) &&
    (forall|i: int| 0 <= i < leaves.len() ==> is_leaf_node(leaves[i], edges, n)) &&
    (forall|i: int| 0 <= i < n ==> is_leaf_node(i, edges, n) ==> leaves.contains(i)) &&
    no_duplicates(leaves)
  }

  spec fn optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {
    if valid_distances(way_a, way_b, way_a.len() as int, x) &&
       (forall|i: int| 0 <= i < leaves.len() ==> 0 <= leaves[i] < way_a.len() && 0 <= leaves[i] < way_b.len()) {
      2 * compute_optimal_moves(way_a, way_b, leaves, x-1)
    } else {
      0
    }
  }
  spec fn is_leaf_node(node: int, edges: Seq<(int, int)>, n: int) -> bool {
    true /* placeholder - represents whether node is a leaf in the tree */
  }

  spec fn no_duplicates(seq: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < seq.len() && 0 <= j < seq.len() && i != j ==> seq[i] != seq[j]
  }

  spec fn compute_optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x_adjusted: int) -> int {
    0 /* placeholder - represents the core game theory computation */
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: int, x: int, edges: Seq<(int, int)>, leaves: Seq<int>, way_a: Seq<int>, way_b: Seq<int>) -> (result: int)
    requires 
        valid_input(n, x, edges),
        valid_distances(way_a, way_b, n, x),
        valid_leaves(leaves, edges, n),
        forall|i: int| 0 <= i < leaves.len() ==> 0 <= leaves[i] < way_a.len() && 0 <= leaves[i] < way_b.len(),
    ensures 
        result >= 0,
        result == optimal_moves(way_a, way_b, leaves, x),
        result % 2 == 0,
        result >= 2 * way_a[x-1],

vc-code: |-
  {
    assume(false);
    unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
