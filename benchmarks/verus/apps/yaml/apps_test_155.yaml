vc-description: |-
  Given an nÃ—m matrix where n is even, determine Lara's position after exactly k moves
  following a specific path: start at (1,1), move down column 1 to (n,1), then move in
  a snake pattern through remaining columns alternating between moving right-up-left-up
  until reaching (1,2). Find coordinates after exactly k moves.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: int, m: int, k: int) -> bool {
      n >= 2 && m >= 2 && n % 2 == 0 && k >= 0 && k < n * m
  }

  spec fn valid_output(result: &Vec<int>, n: int, m: int) -> bool {
      result.len() == 2 && result[0] >= 1 && result[0] <= n && result[1] >= 1 && result[1] <= m
  }

  spec fn correct_position(result: &Vec<int>, n: int, m: int, k: int) -> bool
      recommends valid_input(n, m, k) && result.len() == 2
  {
      if k < n {
          result[0] == k + 1 && result[1] == 1
      } else {
          let k_remaining = k - n;
          let r = n - k_remaining / (m - 1);
          result[0] == r &&
          (r % 2 == 1 ==> result[1] == m - k_remaining % (m - 1)) &&
          (r % 2 == 0 ==> result[1] == 2 + k_remaining % (m - 1))
      }
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: int, m: int, k: int) -> (result: Vec<int>)
      requires
          valid_input(n, m, k)
      ensures
          valid_output(&result, n, m),
          correct_position(&result, n, m, k)

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |2-

  }

  fn main() {}
