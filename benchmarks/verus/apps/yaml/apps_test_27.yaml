vc-description: |-
  Given a string s of n lowercase Latin letters, find the minimum number of operations
  to construct it starting from an empty string. Operations are: (1) add one character
  to the end (unlimited use), (2) copy current string and append it to itself (at most once).

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(n: nat, s: Seq<char>) -> bool {
      s.len() == n
  }
  
  spec fn max_copy_savings(s: Seq<char>, n: nat) -> nat
      requires s.len() == n
      ensures max_copy_savings(s, n) <= n / 2
  {
      max_copy_savings_up_to(s, n, n / 2)
  }
  
  spec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat
      requires 
          s.len() == n,
          limit <= n / 2,
      ensures max_copy_savings_up_to(s, n, limit) <= limit
      decreases limit
  {
      if limit == 0 {
          0
      } else {
          let i = (limit - 1) as nat;
          let current = if can_copy_at(s, n, i) { i } else { 0 };
          let prev = max_copy_savings_up_to(s, n, i);
          if current > prev { current } else { prev }
      }
  }
  
  spec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool
      requires 
          s.len() == n,
          i < n / 2,
  {
      let prefix_len = i + 1;
      let end_pos = i + 1 + prefix_len;
      end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i + 1) as int, end_pos as int)
  }

vc-helpers: |-

vc-spec: |-
  fn solve(n: nat, s: Seq<char>) -> (result: nat)
      requires valid_input(n, s)
      ensures 
          result <= n,
          n == 0 ==> result == 0,
          n > 0 ==> result >= 1,
          result == n - max_copy_savings(s, n),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}