vc-description: |-
  Given a credit card account starting with 0 money and n consecutive days of transactions,
  determine the minimum number of days deposits are needed to satisfy all constraints.
  Each day deposits can be made in the morning, then transactions occur in the evening.
  If any evening transaction causes the balance to exceed limit d, return -1.
  On days when evening transaction is 0 (balance check days), the balance after the
  transaction must be non-negative. Morning deposits can be any positive integer amount.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {
    n >= 1 && d >= 1 &&
    transactions.len() == n &&
    forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000
  }

  spec fn prefix_sum(transactions: Seq<int>, index: int) -> int
    decreases index
  {
    if index < 0 || index >= transactions.len() { 0int }
    else if index == 0 { transactions[0] }
    else { prefix_sum(transactions, index - 1) + transactions[index] }
  }

  spec fn count_zero_transactions(transactions: Seq<int>) -> int
    decreases transactions.len()
  {
    if transactions.len() == 0 { 0int }
    else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }
  }

  spec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int
    decreases day
  {
    if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }
    else if day == 0 { deposits[0] + transactions[0] }
    else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }
  }

  spec fn count_positive_deposits(deposits: Seq<int>) -> int
    decreases deposits.len()
  {
    if deposits.len() == 0 { 0int }
    else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }
  }

  spec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {
    deposits_schedule.len() == transactions.len() &&
    (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&
    num_deposits == count_positive_deposits(deposits_schedule) &&
    forall|i: int| 0 <= i < transactions.len() ==> 
      (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)
  }

  spec fn filter_positive(deposits: Seq<int>) -> Seq<int>
    decreases deposits.len()
  {
    if deposits.len() == 0 { Seq::empty() }
    else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }
    else { filter_positive(deposits.drop_first()) }
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: int, d: int, transactions: Seq<int>) -> (result: int)
    requires valid_input(n, d, transactions)
    ensures result == -1 || result >= 0

vc-code: |-
  {
    assume(false);
    unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
