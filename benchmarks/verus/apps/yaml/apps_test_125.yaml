vc-description: |-
  Given a 4-way intersection with 4 road parts arranged counter-clockwise, determine if a traffic accident
  between cars and pedestrians is possible. Each road part has 4 traffic lights: left turn (l), straight (s),
  right turn (r), and pedestrian crossing (p). Each light can be red (0) or green (1). An accident is possible
  if a pedestrian crossing light is green and a car light is green that allows cars to reach that crossing.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn count_newlines(s: Seq<u8>, pos: int) -> nat
    decreases s.len() - pos
  {
      if pos >= s.len() {
          0
      } else if s[pos] == '\n' as u8 {
          1 + count_newlines(s, pos + 1)
      } else {
          count_newlines(s, pos + 1)
      }
  }

  spec fn valid_input_string(s: Seq<u8>) -> bool {
      s.len() >= 7 &&
      contains_four_lines(s) &&
      all_lines_have_four_valid_integers(s)
  }
  
  spec fn contains_four_lines(s: Seq<u8>) -> bool {
      count_newlines(s, 0) >= 3
  }
  
  spec fn all_lines_have_four_valid_integers(s: Seq<u8>) -> bool {
      forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' as u8 || s[i] == '1' as u8 || s[i] == ' ' as u8 || s[i] == '\n' as u8)
  }
  
  spec fn parse_input(s: Seq<u8>, input_lines: Seq<Seq<int>>) -> bool {
      input_lines.len() == 4 &&
      (forall|i: int| 0 <= i < 4 ==> input_lines[i].len() == 4) &&
      (forall|i: int| 0 <= i < 4 ==> forall|j: int| 0 <= j < 4 ==> 
          (input_lines[i][j] >= 0 && input_lines[i][j] <= 1)) &&
      string_contains_four_lines_of_four_integers(s, input_lines)
  }
  
  spec fn string_contains_four_lines_of_four_integers(s: Seq<u8>, input_lines: Seq<Seq<int>>) -> bool {
      input_lines.len() == 4 &&
      (forall|i: int| 0 <= i < 4 ==> input_lines[i].len() == 4) &&
      valid_input_string(s)
  }
  
  spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool {
      &&& lanes.len() == 4
      &&& (forall|i: int| 0 <= i < 4 ==> lanes[i].len() == 4)
      &&& (forall|i: int| 0 <= i < 4 ==> forall|j: int| 0 <= j < 4 ==> 
          (lanes[i][j] == 0 || lanes[i][j] == 1))
      &&& (exists|i: int| 0 <= i < 4 && accident_at_lane(i, lanes))
  }
  
  spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool {
      &&& 0 <= i < 4
      &&& lanes.len() == 4
      &&& (forall|j: int| 0 <= j < 4 ==> lanes[j].len() == 4)
      &&& ((lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||
           (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||
           (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||
           (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1))
  }

vc-helpers: |-

vc-spec: |-
  fn solve(s: &[u8]) -> (result: Vec<u8>)
    requires 
      s.len() > 0,
      forall|i: int| 0 <= i < s.len() ==> s[i] <= 127,
      valid_input_string(s@),
    ensures 
      result@ =~= seq![89u8, 69u8, 83u8, 10u8] || result@ =~= seq![78u8, 79u8, 10u8],
      exists|input_lines: Seq<Seq<int>>| 
          parse_input(s@, input_lines) && 
          (result@ =~= seq![89u8, 69u8, 83u8, 10u8] <==> accident_possible(input_lines)),
      result.len() >= 3,

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  
  fn main() {}