vc-description: |-
  Given a rectangular park represented as an nÃ—m grid of squares, find the minimum number 
  of lanterns needed to light up all squares. Lanterns are placed on edges between squares,
  and each lantern illuminates adjacent squares (up to 2 squares, or 1 if on boundary).

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn split_lines(s: &str) -> Seq<&str> {
      Seq::empty()
  }
  
  spec fn split_spaces(s: &str) -> Seq<&str> {
      Seq::empty()
  }
  
  spec fn parse_int(s: &str) -> int {
      0
  }

  spec fn valid_input(input: &str) -> bool {
      let lines = split_lines(input);
      lines.len() > 0 &&
      {
          let t = parse_int(lines[0]);
          t > 0 && lines.len() >= t + 1 &&
          forall|i: int| 0 <= i < t ==> {
              let parts = split_spaces(lines[i+1]);
              parts.len() >= 2 &&
              {
                  let n = parse_int(parts[0]);
                  let m = parse_int(parts[1]);
                  n >= 1 && m >= 1
              }
          }
      }
  }
  
  spec fn min_lanterns(n: int, m: int) -> int {
      if n >= 1 && m >= 1 {
          (n * m + 1) / 2
      } else {
          0
      }
  }
  
  spec fn valid_output(input: &str, output: Seq<int>) -> bool {
      if valid_input(input) {
          let lines = split_lines(input);
          let t = parse_int(lines[0]);
          output.len() == t &&
          forall|i: int| 0 <= i < t ==> {
              let parts = split_spaces(lines[i+1]);
              parts.len() >= 2 &&
              {
                  let n = parse_int(parts[0]);
                  let m = parse_int(parts[1]);
                  n >= 1 && m >= 1 &&
                  output[i] == min_lanterns(n, m)
              }
          }
      } else {
          false
      }
  }

vc-helpers: |-

vc-spec: |-
  fn solve_lanterns() -> (result: bool)

vc-code: |-
  {
      assume(false);
      false
  }

vc-postamble: |-

  }
  
  fn main() {}