vc-description: |-
  Given a positive integer a, find the maximum possible value of gcd(a ⊕ b, a & b) 
  where b is chosen from the range [1, a-1] and ⊕ denotes XOR and & denotes AND operations.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn power2(k: int) -> int
    recommends k >= 0
    decreases k
  {
    if k <= 0 { 1 } else { 2 * power2(k - 1) }
  }
  
  spec fn valid_query(a: int) -> bool
  {
    2 <= a <= power2(25) - 1
  }
  
  spec fn valid_queries(queries: Seq<int>) -> bool
  {
    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])
  }
  
  spec fn largest_proper_divisor(n: int) -> int
    recommends n > 1
  {
    largest_proper_divisor_helper(n, 2)
  }
  
  spec fn largest_proper_divisor_helper(n: int, d: int) -> int
    recommends n > 1 && d >= 2
    decreases n - d
  {
    if d * d > n {
      1
    } else if n % d == 0 {
      let quotient = n / d;
      if quotient == d {
        quotient
      } else {
        let remainder_check = largest_proper_divisor_helper(n, d + 1);
        if quotient > remainder_check { quotient } else { remainder_check }
      }
    } else {
      largest_proper_divisor_helper(n, d + 1)
    }
  }
  
  spec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool
  {
    results.len() == queries.len() &&
    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&
    (forall|i: int| 0 <= i < queries.len() ==> 
      (exists|c: int| 1 <= c <= 26 && power2(c) - 1 >= queries[i] && 
       (c == 1 || power2(c-1) - 1 < queries[i]) &&
       (power2(c) - 1 > queries[i] ==> results[i] == power2(c) - 1) &&
       (power2(c) - 1 == queries[i] ==> 
         results[i] == (if power2(c) - 1 <= 1 { 1 } else { largest_proper_divisor(power2(c) - 1) }))))
  }

vc-helpers: |-

vc-spec: |-
  fn solve(queries: Seq<int>) -> (results: Seq<int>)
    requires valid_queries(queries)
    ensures valid_results(queries, results)

vc-code: |-
  {
    assume(false);
    unreached()
  }

vc-postamble: |-

  }

  fn main() {}