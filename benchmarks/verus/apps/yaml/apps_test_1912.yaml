vc-description: |-
  Given T test cases with four integers r, g, b, w representing ball counts,
  determine if balls can be arranged into a palindrome after performing operations.
  Operation: select one red, green, and blue ball and change all three to white.
  For palindromes, at most one color can have an odd count.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() as int - 1] == '\n' &&
    valid_input_structure(input)
  }
  
  spec fn valid_input_structure(input: Seq<char>) -> bool {
    input.len() > 0
  }
  
  spec fn valid_output_format(output: Seq<char>) -> bool {
    output.len() == 0 || output[output.len() as int - 1] == '\n'
  }
  
  spec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input) && valid_output_format(output)
  {
    true
  }
  
  spec fn process_input(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
  {
    seq![]
  }
  
  spec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool
    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0
  {
    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + 
                    (if g % 2 == 1 { 1int } else { 0int }) + 
                    (if b % 2 == 1 { 1int } else { 0int }) + 
                    (if w % 2 == 1 { 1int } else { 0int });
    odd_count <= 1 || 
    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))
  }
  
  spec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool
    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0
  {
    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + 
                    (if g % 2 == 1 { 1int } else { 0int }) + 
                    (if b % 2 == 1 { 1int } else { 0int }) + 
                    (if w % 2 == 1 { 1int } else { 0int });
    odd_count <= 1
  }
  
  spec fn valid_chars() -> Set<char> {
    set!['Y', 'e', 's', 'N', 'o', '\n', ' ']
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: &str) -> (result: String)
    requires
      stdin_input.len() > 0,
      valid_input(stdin_input@),
    ensures
      result.len() >= 0,
      forall|i: int| 0 <= i < result.len() ==> valid_chars().contains(#[trigger] result@[i]),
      result.len() == 0 || result@[result.len() as int - 1] == '\n',
      valid_output_format(result@),
      input_output_correspondence(stdin_input@, result@),
      result@ == process_input(stdin_input@),

vc-code: |-
  {
    assume(false);
    String::new()
  }

vc-postamble: |-

  }

  fn main() {}