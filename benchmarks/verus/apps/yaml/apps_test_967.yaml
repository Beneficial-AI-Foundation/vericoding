vc-description: |-
  Given n threads initially ordered 1, 2, ..., n, after some messages are posted, 
  the threads are reordered such that the thread now at position i was originally 
  at position a_i. When a message is posted in a thread, that thread moves to the 
  top of the list. Find the number of threads that must have received new messages.
  A thread "surely has a new message" if there is no possible sequence of message 
  posts that could result in the given reordering without that thread receiving a message.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: int, a: Seq<int>) -> bool {
      n >= 1 &&
      a.len() == n &&
      (forall|i: int| 0 <= i < n ==> 1 <= a[i] <= n) &&
      (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])
  }

  spec fn valid_output(n: int, result: int) -> bool {
      0 <= result <= n
  }

  spec fn reversed_array(a: Seq<int>) -> Seq<int>
      recommends a.len() >= 1
  {
      Seq::new(a.len(), |i: int| a[a.len() - 1 - i])
  }

  spec fn has_increasing_pair(ar: Seq<int>) -> bool {
      exists|i: int| 1 <= i < ar.len() && ar[i] > ar[i-1]
  }

  spec fn min_index(ar: Seq<int>, n: int) -> int;

  spec fn correct_result(n: int, a: Seq<int>) -> int
      recommends valid_input(n, a)
  {
      let ar = reversed_array(a);
      if has_increasing_pair(ar) {
          let min_i = min_index(ar, n);
          n - min_i
      } else {
          0
      }
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: int, a: Seq<int>) -> (result: int)
      requires 
          valid_input(n, a)
      ensures 
          valid_output(n, result),
          result == correct_result(n, a)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
