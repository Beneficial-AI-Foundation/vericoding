vc-description: |-
  Given a circular building with n entrances, m floors per entrance, and k apartments per floor,
  find the minimum time to travel from apartment a to apartment b. Apartments are numbered 1 to n·m·k
  sequentially. Travel costs: stairs 5s/floor, adjacent entrances 15s, elevator 10s wait + 1s/floor,
  same floor 0s. Can walk around building in either direction.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {
    n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b
  }
  
  spec fn get_entrance(apt: int, m: int, k: int) -> int
    recommends apt >= 1, m > 0 && k > 0
  {
    (apt - 1) / (m * k)
  }
  
  spec fn get_floor(apt: int, m: int, k: int) -> int
    recommends apt >= 1, m > 0 && k > 0
  {
    ((apt - 1) - get_entrance(apt, m, k) * m * k) / k
  }
  
  spec fn min_travel_time(floors: int) -> int
    recommends floors >= 0
  {
    let stair_time = 5 * floors;
    let elevator_time = 10 + floors;
    if stair_time < elevator_time { stair_time } else { elevator_time }
  }
  
  spec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int
    recommends n > 0
  {
    let clockwise = (entrance_b - entrance_a + n) % n;
    let counterclockwise = (entrance_a - entrance_b + n) % n;
    if clockwise <= counterclockwise { clockwise } else { counterclockwise }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(n: int, m: int, k: int, a: int, b: int) -> (result: int)
    requires valid_input(n, m, k, a, b)
    ensures result >= 0

vc-code: |-
  {
    assume(false);
    unreached()
  }

vc-postamble: |-

  }

  fn main() {}