vc-description: |-
  Read an integer N from input. If N=1, print "Hello World". If N=2, read two additional integers A and B, then print their sum.
  Constraints: N is 1 or 2, A and B are integers between 1 and 9 (inclusive).

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn valid_input(stdin_input: Seq<char>) -> bool {
      stdin_input.len() > 0
  }
  
  spec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {
      let lines = split_lines_func(stdin_input);
      if lines.len() >= 1 {
          let n = string_to_int(lines[0]);
          if n == 1 {
              Seq::new(12, |i: int| if i == 0 { 'H' } 
                  else if i == 1 { 'e' } 
                  else if i == 2 { 'l' } 
                  else if i == 3 { 'l' } 
                  else if i == 4 { 'o' } 
                  else if i == 5 { ' ' } 
                  else if i == 6 { 'W' } 
                  else if i == 7 { 'o' } 
                  else if i == 8 { 'r' } 
                  else if i == 9 { 'l' } 
                  else if i == 10 { 'd' } 
                  else { '\n' })
          } else if n != 1 && lines.len() >= 3 {
              let a = string_to_int(lines[1]);
              let b = string_to_int(lines[2]);
              int_to_string(a + b).add(Seq::new(1, |_: int| '\n'))
          } else {
              Seq::empty()
          }
      } else {
          Seq::empty()
      }
  }
  
  spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
      split_lines_func_helper(s, 0, Seq::empty(), Seq::empty())
  }
  
  spec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
      recommends 0 <= i <= s.len()
      decreases s.len() - i
  {
      if i >= s.len() {
          if current.len() == 0 {
              acc
          } else {
              acc.push(current)
          }
      } else if s[i] == '\n' {
          split_lines_func_helper(s, i + 1, Seq::empty(), acc.push(current))
      } else {
          split_lines_func_helper(s, i + 1, current.push(s[i]), acc)
      }
  }
  
  spec fn string_to_int(s: Seq<char>) -> int {
      if s.len() == 0 {
          0
      } else if s[0] == '-' {
          -string_to_int_helper(s.subrange(1, s.len() as int))
      } else {
          string_to_int_helper(s)
      }
  }
  
  spec fn string_to_int_helper(s: Seq<char>) -> int {
      if s.len() == 0 {
          0
      } else {
          string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))
      }
  }
  
  spec fn int_to_string(n: int) -> Seq<char> {
      if n == 0 {
          Seq::new(1, |_: int| '0')
      } else if n < 0 {
          Seq::new(1, |_: int| '-').add(int_to_string_helper(-n))
      } else {
          int_to_string_helper(n)
      }
  }
  
  spec fn int_to_string_helper(n: int) -> Seq<char>
      recommends n >= 0
  {
      if n == 0 {
          Seq::empty()
      } else {
          int_to_string_helper(n / 10).push((n % 10 + ('0' as int)) as char)
      }
  }

vc-spec: |-
  fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
      requires valid_input(stdin_input)
      ensures result == expected_output(stdin_input)

vc-code: |-
  {
      assume(false);
      Seq::empty()
  }

vc-postamble: |-

  }

  fn main() {}