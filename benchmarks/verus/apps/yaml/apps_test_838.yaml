vc-description: |-
  Count non-empty sets of cells in a binary grid where all cells have the same color (0 or 1)
  and every pair of cells in the set shares either a row or a column.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(stdin_input: Seq<char>) -> bool {
      stdin_input.len() > 0
  }
  
  spec fn valid_grid(grid: &Seq<Seq<int>>) -> bool {
      grid.len() > 0 && grid[0].len() > 0 &&
      forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[0].len() ==>
          grid[i][j] == 0 || grid[i][j] == 1
  }
  
  spec fn count_valid_sets(grid: &Seq<Seq<int>>) -> int
      recommends valid_grid(grid)
  {
      grid.len() * grid[0].len() + 
      sum_row_contributions(grid) + 
      sum_col_contributions(grid)
  }
  
  spec fn sum_row_contributions(grid: &Seq<Seq<int>>) -> int {
      sum_row_contributions_helper(grid, 0)
  }
  
  spec fn sum_row_contributions_helper(grid: &Seq<Seq<int>>, row: int) -> int
      recommends 0 <= row <= grid.len()
      decreases grid.len() - row
  {
      if row == grid.len() { 0 }
      else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }
  }
  
  spec fn row_contribution(grid: &Seq<Seq<int>>, row: int) -> int
      recommends 0 <= row < grid.len()
  {
      let cnt0 = count_in_row(grid, row, 0);
      let cnt1 = count_in_row(grid, row, 1);
      (if cnt0 > 1 { power_of_two(cnt0) - cnt0 - 1 } else { 0 }) +
      (if cnt1 > 1 { power_of_two(cnt1) - cnt1 - 1 } else { 0 })
  }
  
  spec fn power_of_two(n: int) -> int 
      recommends n >= 0
  {
      if n == 0 { 1 }
      else if n == 1 { 2 }
      else { 2 * power_of_two(n - 1) }
  }
  
  spec fn sum_col_contributions(grid: &Seq<Seq<int>>) -> int {
      sum_col_contributions_helper(grid, 0)
  }
  
  spec fn sum_col_contributions_helper(grid: &Seq<Seq<int>>, col: int) -> int
      recommends 0 <= col <= grid[0].len()
      decreases grid[0].len() - col
  {
      if col == grid[0].len() { 0 }
      else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }
  }
  
  spec fn col_contribution(grid: &Seq<Seq<int>>, col: int) -> int
      recommends 0 <= col < grid[0].len()
  {
      let cnt0 = count_in_col(grid, col, 0);
      let cnt1 = count_in_col(grid, col, 1);
      (if cnt0 > 1 { power_of_two(cnt0) - cnt0 - 1 } else { 0 }) +
      (if cnt1 > 1 { power_of_two(cnt1) - cnt1 - 1 } else { 0 })
  }
  
  spec fn count_in_row(grid: &Seq<Seq<int>>, row: int, value: int) -> int
      recommends 0 <= row < grid.len()
  {
      count_in_row_helper(grid, row, value, 0)
  }
  
  spec fn count_in_row_helper(grid: &Seq<Seq<int>>, row: int, value: int, col: int) -> int
      recommends 0 <= row < grid.len() && 0 <= col <= grid[0].len()
      decreases grid[0].len() - col
  {
      if col == grid[0].len() { 0 }
      else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }
  }
  
  spec fn count_in_col(grid: &Seq<Seq<int>>, col: int, value: int) -> int
      recommends 0 <= col < grid[0].len()
  {
      if grid.len() == 0 { 0 }
      else { count_col_helper(grid, col, value, 0) }
  }
  
  spec fn count_col_helper(grid: &Seq<Seq<int>>, col: int, value: int, row: int) -> int
      recommends 0 <= col < grid[0].len() && 0 <= row <= grid.len()
      decreases grid.len() - row
  {
      if row == grid.len() { 0 }
      else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
      requires valid_input(stdin_input)
      ensures result.len() > 0

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}