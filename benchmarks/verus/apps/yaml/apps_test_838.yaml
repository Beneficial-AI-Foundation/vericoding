vc-description: |-
  Count non-empty sets of cells in a binary grid where all cells have the same color (0 or 1)
  and every pair of cells in the set shares either a row or a column.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(stdin_input: &str) -> bool {
      stdin_input.len() > 0
  }
  
  spec fn valid_grid(grid: &Vec<Vec<int>>) -> bool {
      grid.len() > 0 && 
      (forall|i: int| 0 <= i < grid.len() ==> grid[i as usize].len() > 0) &&
      (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i as usize].len() ==> 
          grid[i as usize][j as usize] == 0 || grid[i as usize][j as usize] == 1)
  }
  
  spec fn count_valid_sets(grid: &Vec<Vec<int>>) -> int
      requires valid_grid(grid)
  {
      grid.len() as int * grid[0].len() as int + 
      sum_row_contributions(grid) + 
      sum_col_contributions(grid)
  }
  
  spec fn sum_row_contributions(grid: &Vec<Vec<int>>) -> int {
      sum_row_contributions_helper(grid, 0)
  }
  
  spec fn sum_row_contributions_helper(grid: &Vec<Vec<int>>, row: int) -> int
      requires 0 <= row <= grid.len()
      decreases grid.len() - row
  {
      if row == grid.len() { 
          0
      } else { 
          row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1)
      }
  }
  
  spec fn row_contribution(grid: &Vec<Vec<int>>, row: int) -> int
      requires 0 <= row < grid.len()
  {
      let cnt0 = count_in_row(grid, row, 0);
      let cnt1 = count_in_row(grid, row, 1);
      (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +
      (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })
  }
  
  spec fn sum_col_contributions(grid: &Vec<Vec<int>>) -> int {
      sum_col_contributions_helper(grid, 0)
  }
  
  spec fn sum_col_contributions_helper(grid: &Vec<Vec<int>>, col: int) -> int
      requires 0 <= col <= (if grid.len() > 0 { grid[0].len() } else { 0 })
      decreases (if grid.len() > 0 { grid[0].len() } else { 0 }) - col
  {
      if col == (if grid.len() > 0 { grid[0].len() } else { 0 }) { 
          0
      } else { 
          col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1)
      }
  }
  
  spec fn col_contribution(grid: &Vec<Vec<int>>, col: int) -> int
      requires grid.len() > 0 && 0 <= col < grid[0].len()
  {
      let cnt0 = count_in_col(grid, col, 0);
      let cnt1 = count_in_col(grid, col, 1);
      (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +
      (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })
  }
  
  spec fn count_in_row(grid: &Vec<Vec<int>>, row: int, value: int) -> int
      requires 0 <= row < grid.len()
  {
      count_in_row_helper(grid, row, value, 0)
  }
  
  spec fn count_in_row_helper(grid: &Vec<Vec<int>>, row: int, value: int, col: int) -> int
      requires 0 <= row < grid.len(),
      requires 0 <= col <= grid[row as usize].len(),
      decreases grid[row as usize].len() - col,
  {
      if col == grid[row as usize].len() { 
          0
      } else { 
          (if grid[row as usize][col as usize] == value { 1 } else { 0 }) + count_in_row_helper(grid, row, value, col + 1)
      }
  }
  
  spec fn count_in_col(grid: &Vec<Vec<int>>, col: int, value: int) -> int
      requires grid.len() > 0 && 0 <= col < grid[0].len()
  {
      if grid.len() == 0 { 
          0
      } else { 
          count_col_helper(grid, col, value, 0)
      }
  }
  
  spec fn count_col_helper(grid: &Vec<Vec<int>>, col: int, value: int, row: int) -> int
      requires grid.len() > 0 && 0 <= col < grid[0].len(),
      requires 0 <= row <= grid.len(),
      decreases grid.len() - row,
  {
      if row == grid.len() { 
          0
      } else { 
          (if grid[row as usize][col as usize] == value { 1 } else { 0 }) + count_col_helper(grid, col, value, row + 1)
      }
  }

  spec fn power(base: int, exp: int) -> int
      requires exp >= 0
      decreases exp
  {
      if exp == 0 { 
          1
      } else { 
          base * power(base, exp - 1)
      }
  }

  spec fn int_to_string(n: int) -> String {
      n.to_string()
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: &str) -> (result: String)
      requires valid_input(stdin_input)
      ensures result.len() > 0
      ensures result.chars().last() == Some('\n')
      ensures exists|output_value: int| output_value >= 0 && result == int_to_string(output_value) + "\n"

vc-code: |-
  {
      // impl-start
      assume(false);
      String::new()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}