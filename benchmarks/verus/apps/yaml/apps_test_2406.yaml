vc-description: |-
  Simulate a landslide process on an array of strictly increasing heights.
  Each minute, for every position j where h_j + 2 â‰¤ h_{j+1}, one unit slides 
  from position j+1 to position j. All transfers happen simultaneously.
  The process stops when no position satisfies the sliding condition.
  Return the final stable heights.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: int, heights: Seq<int>) -> bool {
      n > 0 && heights.len() == n &&
      (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&
      (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])
  }

  spec fn valid_output(n: int, result: Seq<int>) -> bool {
      result.len() == n &&
      (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&
      (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&
      (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)
  }

  spec fn is_stable(result: Seq<int>) -> bool {
      forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])
  }

  spec fn sum_seq(s: Seq<int>) -> int
      decreases s.len()
  {
      if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: int, heights: Seq<int>) -> (result: Seq<int>)
      requires 
          valid_input(n, heights)
      ensures 
          valid_output(n, result) &&
          sum_seq(result) == sum_seq(heights) &&
          is_stable(result)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
