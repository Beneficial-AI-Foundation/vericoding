vc-description: |-
  Given N questions with scores, find the maximum possible sum of a subset 
  such that the sum is NOT a multiple of 10. If no such sum exists, return 0.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn valid_input(scores: Seq<int>) -> bool {
      scores.len() > 0 && scores.len() <= 100 &&
      forall|i: int| 0 <= i < scores.len() ==> 1 <= scores[i] <= 100
  }
  
  spec fn sum_seq(scores: Seq<int>) -> int
      decreases scores.len()
  {
      if scores.len() == 0 {
          0
      } else {
          scores[0] + sum_seq(scores.subrange(1, scores.len() as int))
      }
  }
  
  spec fn all_multiples_of_10(scores: Seq<int>) -> bool {
      forall|i: int| 0 <= i < scores.len() ==> scores[i] % 10 == 0
  }
  
  spec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {
      scores.contains(value) && 
      value % 10 != 0 &&
      forall|x: int| scores.contains(x) && x % 10 != 0 ==> value <= x
  }
  
  spec fn correct_result(scores: Seq<int>, result: int) -> bool {
      let total_sum = sum_seq(scores);
      if total_sum % 10 != 0 {
          result == total_sum
      } else if all_multiples_of_10(scores) {
          result == 0
      } else {
          exists|smallest_non_multiple: int| 
              is_smallest_non_multiple(scores, smallest_non_multiple) &&
              result == total_sum - smallest_non_multiple
      }
  }

vc-spec: |-
  fn solve(scores: Seq<int>) -> (result: int)
      requires valid_input(scores)
      ensures correct_result(scores, result)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}