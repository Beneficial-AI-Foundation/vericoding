vc-description: |-
  Given N astronauts with current point rankings and N point awards for the next race,
  find the best possible ranking for astronaut at position D after the race.
  The target astronaut gets the maximum award, and we try to minimize awards to astronauts
  ahead of them to maximize how many can be overtaken.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {
      n >= 1 && n <= 200000 &&
      d >= 1 && d <= n &&
      current_points.len() == n &&
      awards.len() == n &&
      d-1 < current_points.len() &&
      (forall|i: int| 0 <= i < current_points.len()-1 ==> current_points[i] >= current_points[i+1]) &&
      (forall|i: int| 0 <= i < awards.len()-1 ==> awards[i] >= awards[i+1])
  }

  spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int
      recommends
          current_points.len() == awards.len(),
          d >= 1 && d <= current_points.len(),
          d-1 < current_points.len(),
          forall|i: int| 0 <= i < awards.len()-1 ==> awards[i] >= awards[i+1]
  {
      count_overtaken_helper(current_points, awards, d, 0, 0)
  }

  spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int
      recommends
          current_points.len() == awards.len(),
          d >= 1 && d <= current_points.len(),
          d-1 < current_points.len(),
          forall|i: int| 0 <= i < awards.len()-1 ==> awards[i] >= awards[i+1],
          0 <= pos <= d-1,
          0 <= used_awards <= awards.len()
      decreases d-1-pos
  {
      if pos >= d-1 {
          0
      } else {
          let target_score = current_points[d-1] + awards[0];
          let remaining_awards = awards.len() - used_awards;
          if remaining_awards > 0 && used_awards < awards.len() && current_points[pos] + awards[awards.len()-1-used_awards] <= target_score {
              1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)
          } else {
              count_overtaken_helper(current_points, awards, d, pos+1, used_awards)
          }
      }
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> (result: int)
      requires valid_input(n, d, current_points, awards)
      ensures 
          1 <= result <= d,
          result == d - count_overtaken(current_points, awards, d)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
