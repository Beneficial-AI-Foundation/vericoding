vc-description: |-
  Given a list of n integers, compute 2 + (third_element XOR smallest_element), where:
  - third_element is the element at index 2 (third position) in the original list
  - smallest_element is the minimum value in the list
  - XOR is the bitwise exclusive OR operation

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(lst: Seq<int>) -> bool {
      5 <= lst.len() <= 10 &&
      forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32
  }

  spec fn int_xor(a: int, b: int) -> int {
      let a_bv = a as u32;
      let b_bv = b as u32;
      (a_bv ^ b_bv) as int
  }

  spec fn min_of_sequence(s: Seq<int>) -> int
      decreases s.len()
  {
      if s.len() == 0 {
          0
      } else if s.len() == 1 {
          s[0]
      } else {
          let tail_min = min_of_sequence(s.skip(1));
          if s[0] <= tail_min {
              s[0]
          } else {
              tail_min
          }
      }
  }

vc-helpers: |

vc-spec: |-
  fn solve(lst: Seq<int>) -> (result: int)
      requires valid_input(lst)
      ensures result == 2 + int_xor(lst[2], min_of_sequence(lst))

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
