vc-description: |-
  Two players play a sequential game on a grid of restaurant costs.
  Emma (first player) chooses a row to maximize final cost.
  Jack (second player) then chooses a column to minimize final cost.
  Both play optimally. Find the resulting cost when both play optimally.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
      grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0
  }
  
  spec fn seq_min(s: Seq<int>) -> int 
      recommends s.len() > 0
      decreases s.len()
      when s.len() > 0
  {
      if s.len() == 1 { 
          s[0]
      } else {
          let tail_min = seq_min(s.drop_first());
          if s[0] <= tail_min { 
              s[0]
          } else { 
              tail_min
          }
      }
  }
  
  spec fn seq_max(s: Seq<int>) -> int
      recommends s.len() > 0
      decreases s.len()
      when s.len() > 0
  {
      if s.len() == 1 { 
          s[0]
      } else {
          let tail_max = seq_max(s.drop_first());
          if s[0] >= tail_max { 
              s[0]
          } else { 
              tail_max
          }
      }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(grid: Seq<Seq<int>>) -> (result: int)
      requires valid_grid(grid)
      ensures ({
          let row_mins = Seq::new(grid.len(), |i: int| seq_min(grid[i]));
          result == seq_max(row_mins)
      })

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}