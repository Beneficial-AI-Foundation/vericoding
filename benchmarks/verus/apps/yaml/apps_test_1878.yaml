vc-description: |-
  Given n rectangles on a 100×100 grid, where each rectangle is defined by its bottom-left corner (x₁, y₁) and top-right corner (x₂, y₂), 
  calculate the sum of all cell values in the grid. Each cell's value equals the number of rectangles that contain it.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(input: Seq<char>) -> bool {
      true
  }
  
  spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
      if s.len() == 0 { Seq::empty() }
      else { split_lines_helper(s, 0, 0, Seq::empty()) }
  }
  
  spec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
      decreases s.len() - pos
  {
      if pos >= s.len() {
          if start < pos {
              acc.push(s.subrange(start, pos))
          } else { acc }
      } else if s[pos] == '\n' {
          let new_acc = if start < pos {
              acc.push(s.subrange(start, pos))
          } else { acc };
          split_lines_helper(s, pos + 1, pos + 1, new_acc)
      } else {
          split_lines_helper(s, start, pos + 1, acc)
      }
  }
  
  spec fn parse_int_func(s: Seq<char>) -> int {
      if s.len() == 0 { 0 }
      else if s[0] == '-' { -parse_int_pos_func(s.subrange(1, s.len() as int)) }
      else { parse_int_pos_func(s) }
  }
  
  spec fn parse_int_pos_func(s: Seq<char>) -> int
      decreases s.len()
  {
      if s.len() == 0 { 0 }
      else if '0' <= s[0] <= '9' {
          (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))
      } else { 0 }
  }
  
  spec fn parse_ints_func(s: Seq<char>) -> Seq<int> {
      if s.len() == 0 { Seq::empty() }
      else { parse_ints_helper(s, 0, 0, Seq::empty()) }
  }
  
  spec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>
      decreases s.len() - pos
  {
      if pos >= s.len() {
          if start < pos { acc.push(parse_int_func(s.subrange(start, pos))) } else { acc }
      } else if s[pos] == ' ' {
          let new_acc = if start < pos { acc.push(parse_int_func(s.subrange(start, pos))) } else { acc };
          parse_ints_helper(s, pos + 1, pos + 1, new_acc)
      } else {
          parse_ints_helper(s, start, pos + 1, acc)
      }
  }
  
  spec fn int_to_string_func(n: int) -> Seq<char> {
      if n == 0 { seq!['0'] }
      else if n > 0 { int_to_string_pos(n) }
      else { seq!['-'] + int_to_string_pos(-n) }
  }
  
  spec fn int_to_string_pos(n: int) -> Seq<char>
      decreases n
  {
      if n <= 0 { Seq::empty() }
      else if n < 10 { seq![('0' as int + n) as char] }
      else { int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char] }
  }
  
  spec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int
      decreases rectangle_lines.len()
  {
      if rectangle_lines.len() == 0 { 0 }
      else {
          let coords = parse_ints_func(rectangle_lines[0]);
          let area = if coords.len() >= 4 {
              let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);
              if computed >= 0 { computed } else { 0 }
          } else { 0 };
          area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))
      }
  }
  
  spec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int
      decreases n
  {
      if n <= 0 || rectangle_lines.len() == 0 { 0 }
      else {
          let coords = parse_ints_func(rectangle_lines[0]);
          let area = if coords.len() >= 4 {
              let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);
              if computed >= 0 { computed } else { 0 }
          } else { 0 };
          area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)
      }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(input: Seq<char>) -> (result: Seq<char>)
      requires valid_input(input)
      ensures result.len() >= 1
      ensures result[result.len() - 1] == '\n'
      ensures exists|total_area: int|
          total_area >= 0 &&
          result == int_to_string_func(total_area) + seq!['\n'] &&
          {
              let processed_input = if input.len() > 0 && input[input.len() - 1] == '\n' { input } else { input + seq!['\n'] };
              let lines = split_lines_func(processed_input);
              if lines.len() == 0 { total_area == 0 }
              else {
                  let n = parse_int_func(lines[0]);
                  if n >= 0 && n + 1 <= lines.len() {
                      total_area == compute_total_area(lines.subrange(1, n + 1))
                  } else {
                      total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)
                  }
              }
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}