vc-description: |-
  Given five integers representing the values of variables x₁, x₂, x₃, x₄, x₅, find which variable has the value 0.
  Initially, each variable xᵢ had value i, but exactly one variable was changed to 0.
  Input: Five space-separated integers. Output: The index i (1-indexed) of the variable xᵢ that has value 0.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(s: Seq<char>) -> bool {
      s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> {
          let c = s[i];
          c == ' ' || c == '\n' || ('0' <= c && c <= '9') || c == '-'
      })
  }

  spec fn valid_number(s: Seq<char>) -> bool {
      s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> {
          let c = s[i];
          ('0' <= c && c <= '9') || (i == 0 && c == '-')
      })
  }

  spec fn count_zeros(numbers: Seq<int>) -> int
      decreases numbers.len()
  {
      if numbers.len() == 0 {
          0int
      } else {
          (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))
      }
  }

  spec fn find_zero_index(numbers: Seq<int>) -> int
      decreases numbers.len()
  {
      if numbers.len() > 0 && count_zeros(numbers) == 1 {
          if numbers[0] == 0 {
              0int
          } else if numbers.len() > 1 {
              1int + find_zero_index(numbers.subrange(1, numbers.len() as int))
          } else {
              0int
          }
      } else {
          0int
      }
  }

  spec fn parse_ints(s: Seq<char>) -> Seq<int> {
      if s.len() > 0 && valid_input(s) {
          parse_ints_helper(s, 0, seq![], seq![])
      } else {
          seq![]
      }
  }

  spec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<int>) -> Seq<int>
      decreases s.len() - pos
  {
      if pos >= s.len() {
          if current.len() > 0 { acc.push(0int) } else { acc }
      } else {
          acc
      }
  }

  spec fn generate_output(numbers: Seq<int>) -> Seq<char> {
      generate_output_helper(numbers, 0, seq![])
  }

  spec fn generate_output_helper(numbers: Seq<int>, pos: int, acc: Seq<char>) -> Seq<char>
      decreases numbers.len() - pos
  {
      if pos >= numbers.len() {
          acc
      } else {
          acc
      }
  }

vc-helpers: |

vc-spec: |-
  fn solve(input: Seq<char>) -> (result: Seq<char>)
      requires 
          valid_input(input),
          input.len() > 0,
      ensures ({
          let numbers = parse_ints(input);
          result == generate_output(numbers)
      })

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
