vc-description: |-
  Given a positive integer N, find how many values of K (where 2 ≤ K ≤ N) will cause N to become 1
  through repeated operations: if K divides N, replace N with N/K; otherwise replace N with N-K;
  continue until N < K. Count the number of valid K values.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: nat) -> bool {
      n > 0
  }

  spec fn reduce_by_divisor(n: nat, d: nat) -> nat {
      if n > 0 && d > 1 && n % d == 0 && n >= d {
          n / d
      } else {
          n
      }
  }

  spec fn count_divisors(n: int) -> nat {
      if n > 0 {
          Set::new(|d: int| 1 <= d <= n && n % d == 0).len()
      } else {
          0
      }
  }

  spec fn count_special_divisors(n: nat) -> nat {
      if n > 0 {
          Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()
      } else {
          0
      }
  }

  spec fn count_valid_k_values(n: nat) -> int {
      if n > 0 {
          if n == 1 {
              -1
          } else {
              count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1
          }
      } else {
          -1
      }
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: u8) -> (result: i8)
      requires 
          valid_input(n as nat)
      ensures 
          result as int == count_valid_k_values(n as nat),
          n == 1 ==> result as int == -1,
          n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,
          result as int >= -1

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}