vc-description: |-
  Given n castles with soldiers, two players alternate turns starting with White.
  Each turn a player attacks a castle using mixed (x damage), infantry (y damage, 
  forbidden if previous attack on same castle was infantry), or cavalry (z damage,
  forbidden if previous attack on same castle was cavalry). Player making the last
  attack wins. Find number of White's winning first moves using Grundy number theory.
  
  /* Implementation uses Grundy number theory */

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  struct TestCase {
      n: nat,
      x: nat,
      y: nat,
      z: nat,
      castles: Seq<nat>,
  }
  
  spec fn split_by_newline(input: &str) -> Seq<&str> { uninterpreted() }
  spec fn is_non_negative_integer_string(s: &str) -> bool { uninterpreted() }
  spec fn parse_integer(s: &str) -> nat { uninterpreted() }
  spec fn is_valid_test_case_params(s: &str) -> bool { uninterpreted() }
  spec fn is_valid_castles_line(s: &str, n: nat) -> bool { uninterpreted() }
  spec fn get_n_from_params(s: &str) -> nat { uninterpreted() }
  spec fn get_x_from_params(s: &str) -> nat { uninterpreted() }
  spec fn get_y_from_params(s: &str) -> nat { uninterpreted() }
  spec fn get_z_from_params(s: &str) -> nat { uninterpreted() }
  spec fn count_lines(s: &str) -> nat { uninterpreted() }
  spec fn get_line(s: &str, i: nat) -> &str { uninterpreted() }
  spec fn parse_castle_array(s: &str) -> Seq<nat> { uninterpreted() }
  
  spec fn valid_input(input: &str) -> bool {
      input.len() > 0 &&
      (exists|lines: Seq<&str>| {
          &&& lines == split_by_newline(input)
          &&& lines.len() >= 1
          &&& is_non_negative_integer_string(lines[0])
          &&& (exists|t: nat| {
              &&& t == parse_integer(lines[0])
              &&& 1 <= t <= 1000
              &&& lines.len() == 1 + 2 * t
              &&& forall|i: nat| 0 <= i < t ==> {
                  let params_line = lines[1 + 2*i as int];
                  let castles_line = lines[2 + 2*i as int];
                  &&& is_valid_test_case_params(params_line)
                  &&& is_valid_castles_line(castles_line, get_n_from_params(params_line))
                  &&& get_n_from_params(params_line) <= 300000
                  &&& 1 <= get_x_from_params(params_line) <= 5
                  &&& 1 <= get_y_from_params(params_line) <= 5
                  &&& 1 <= get_z_from_params(params_line) <= 5
              }
          })
      })
  }
  
  spec fn valid_output(input: &str, output: &str) -> bool
      recommends valid_input(input)
  {
      output.len() > 0 &&
      output.get_char((output.len() - 1) as int) == '\n' &&
      count_lines(output) == get_test_count(input) &&
      forall|i: nat| 0 <= i < count_lines(output) ==> {
          let line = get_line(output, i);
          line != "" ==> is_non_negative_integer_string(line)
      }
  }
  
  spec fn get_test_count(s: &str) -> nat
      recommends valid_input(s)
      ensures 1 <= get_test_count(s) <= 1000
  {
      parse_integer(split_by_newline(s)[0])
  }
  
  spec fn get_test_case(s: &str, i: nat) -> TestCase
      recommends valid_input(s) && i < get_test_count(s)
      ensures ({
          let tc = get_test_case(s, i);
          &&& 1 <= tc.n <= 300000
          &&& 1 <= tc.x <= 5 && 1 <= tc.y <= 5 && 1 <= tc.z <= 5
          &&& tc.castles.len() == tc.n
          &&& forall|j: int| 0 <= j < tc.castles.len() ==> tc.castles[j] >= 1
      })
  {
      let lines = split_by_newline(s);
      let params_line = lines[1 + 2*i as int];
      let castles_line = lines[2 + 2*i as int];
      TestCase {
          n: get_n_from_params(params_line),
          x: get_x_from_params(params_line),
          y: get_y_from_params(params_line),
          z: get_z_from_params(params_line),
          castles: parse_castle_array(castles_line),
      }
  }
  
  spec fn count_winning_first_moves(tc: TestCase) -> nat
      ensures count_winning_first_moves(tc) <= 3 * tc.n
  {
      0
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: &str) -> (result: String)
      requires valid_input(stdin_input)
      ensures valid_output(stdin_input, &result)

vc-code: |-
  {
      // impl-start
      assume(false);
      String::new()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}