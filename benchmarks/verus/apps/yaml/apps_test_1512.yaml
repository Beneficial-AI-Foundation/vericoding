vc-description: |-
  Given a permutation of integers from 1 to n, determine which single element to remove
  to maximize the number of records in the remaining sequence. A record is an element
  that is greater than all elements that appear before it in the sequence. If multiple
  elements can be removed to achieve the same maximum number of records, return the
  smallest such element.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_permutation(p: Seq<int>, n: int) -> bool {
    p.len() == n && n >= 1 &&
    (forall|i: int| 0 <= i < n ==> 1 <= p[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> p[i] != p[j])
  }
  
  spec fn count_records(s: Seq<int>) -> int
  decreases s.len()
  {
    if s.len() == 0 { 0 }
    else { 1 + count_records_from_index(s, 1, s[0]) }
  }
  
  spec fn count_records_after_removal(p: Seq<int>, to_remove: int) -> int
  {
    let filtered = Seq::new(p.len() - 1, |i: int| 
      if index_of(p, to_remove) <= i { p[i + 1] } else { p[i] });
    count_records(filtered)
  }

vc-helpers: |-
  spec fn count_records_from_index(s: Seq<int>, start: int, max_so_far: int) -> int
  decreases s.len() - start
  {
    if start >= s.len() { 0 }
    else if s[start] > max_so_far { 1 + count_records_from_index(s, start + 1, s[start]) }
    else { count_records_from_index(s, start + 1, max_so_far) }
  }

  spec fn index_of(p: Seq<int>, element: int) -> int
  {
    choose|i: int| 0 <= i < p.len() && p[i] == element
  }

vc-spec: |-
  fn solve(n: int, p: Seq<int>) -> (result: int)
    requires valid_permutation(p, n)
    ensures 1 <= result <= n,
    ensures p.contains(result),
    ensures forall|x: int| p.contains(x) ==> count_records_after_removal(p, result) >= count_records_after_removal(p, x),
    ensures forall|x: int| p.contains(x) && count_records_after_removal(p, x) == count_records_after_removal(p, result) ==> result <= x,

vc-code: |-
  {
    assume(false);
    unreached()
  }

vc-postamble: |-

  }

  fn main() {}