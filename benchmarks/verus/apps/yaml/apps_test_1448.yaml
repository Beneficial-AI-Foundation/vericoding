vc-description: |-
  Given integers n and d, determine for each grasshopper whether their position 
  is inside or on the boundary of a cornfield quadrilateral with vertices at 
  (0,d), (d,0), (n,n-d), (n-d,n). Output "YES" if inside/on boundary, "NO" otherwise.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn valid_input(input: Seq<char>) -> bool {
      let lines = split_lines(input);
      lines.len() >= 3 && 
      valid_first_line(lines[0]) &&
      valid_second_line(lines[1]) &&
      valid_grasshopper_lines_simple(lines) &&
      {
          let first_line = split_spaces(lines[0]);
          let n = string_to_int(first_line[0]);
          let d = string_to_int(first_line[1]);
          let m = string_to_int(lines[1]);
          d >= 1 && d < n && n <= 100 &&
          m >= 1 && m <= 100 &&
          lines.len() >= 2 + m &&
          forall|i: int| 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)
      }
  }
  
  spec fn valid_first_line(line: Seq<char>) -> bool {
      let parts = split_spaces(line);
      parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])
  }
  
  spec fn valid_second_line(line: Seq<char>) -> bool {
      is_valid_integer(line)
  }
  
  spec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {
      lines.len() >= 3 &&
      {
          let m = string_to_int(lines[1]);
          lines.len() >= 2 + m
      }
  }
  
  spec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {
      let parts = split_spaces(line);
      parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&
      string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&
      string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n
  }
  
  spec fn is_valid_integer(s: Seq<char>) -> bool {
      s.len() > 0 && (s[0] != '-' ==> forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9') &&
      (s[0] == '-' ==> s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> '0' <= s[i] <= '9')
  }
  
  spec fn get_n(input: Seq<char>) -> int {
      let lines = split_lines(input);
      let first_line = split_spaces(lines[0]);
      string_to_int(first_line[0])
  }
  
  spec fn get_d(input: Seq<char>) -> int {
      let lines = split_lines(input);
      let first_line = split_spaces(lines[0]);
      string_to_int(first_line[1])
  }
  
  spec fn get_number_of_grasshoppers(input: Seq<char>) -> int {
      let lines = split_lines(input);
      string_to_int(lines[1])
  }
  
  spec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {
      let lines = split_lines(input);
      let coords = split_spaces(lines[2 + i]);
      (string_to_int(coords[0]), string_to_int(coords[1]))
  }
  
  spec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {
      let (x, y) = grasshopper;
      x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d
  }

  /* Helper functions for string processing (assumed to exist) */
  spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>
      uninterp;
  
  spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>>
      uninterp;
  
  spec fn string_to_int(s: Seq<char>) -> int
      uninterp;

vc-spec: |-
  fn solve(input: Seq<char>) -> (result: Vec<Vec<char>>)
      requires
          input.len() > 0,
          valid_input(input)
      ensures
          result.len() == get_number_of_grasshoppers(input),
          forall|i: int| 0 <= i < result.len() ==> 
              (result[i] == vec!['Y', 'E', 'S'] || result[i] == vec!['N', 'O']),
          forall|i: int| 0 <= i < result.len() ==> 
              result[i] == {
                  if is_inside_cornfield(get_grasshopper(input, i), get_n(input), get_d(input)) {
                      vec!['Y', 'E', 'S']
                  } else {
                      vec!['N', 'O']
                  }
              }

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}