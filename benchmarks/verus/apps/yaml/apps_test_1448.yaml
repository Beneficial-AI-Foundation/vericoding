vc-description: |-
  Given integers n and d, determine for each grasshopper whether their position 
  is inside or on the boundary of a cornfield quadrilateral with vertices at 
  (0,d), (d,0), (n,n-d), (n-d,n). Output "YES" if inside/on boundary, "NO" otherwise.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* Placeholder spec functions for string operations - would need actual implementations */
  spec fn split_lines(input: &str) -> Seq<&str> { 
      Seq::empty()
  }
  
  spec fn split_spaces(line: &str) -> Seq<&str> { 
      Seq::empty()
  }
  
  spec fn string_to_int(s: &str) -> int { 
      0
  }

  spec fn str_len(s: &str) -> nat {
      0
  }

  spec fn valid_input(input: &str) -> bool {
      let lines = split_lines(input);
      lines.len() >= 3 && 
      valid_first_line(lines[0]) &&
      valid_second_line(lines[1]) &&
      valid_grasshopper_lines_simple(lines) &&
      {
          let first_line = split_spaces(lines[0]);
          let n = string_to_int(first_line[0]);
          let d = string_to_int(first_line[1]);
          let m = string_to_int(lines[1]);
          d >= 1 && d < n && n <= 100 &&
          m >= 1 && m <= 100 &&
          lines.len() >= 2 + m &&
          forall|i: int| 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)
      }
  }
  
  spec fn valid_first_line(line: &str) -> bool {
      let parts = split_spaces(line);
      parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])
  }
  
  spec fn valid_second_line(line: &str) -> bool {
      is_valid_integer(line)
  }
  
  spec fn valid_grasshopper_lines_simple(lines: Seq<&str>) -> bool {
      lines.len() >= 3 &&
      {
          let m = string_to_int(lines[1]);
          lines.len() >= 2 + m
      }
  }
  
  spec fn valid_grasshopper_line(line: &str, n: int) -> bool {
      let parts = split_spaces(line);
      parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&
      string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&
      string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n
  }
  
  spec fn is_valid_integer(s: &str) -> bool {
      str_len(s) > 0
  }
  
  spec fn get_n(input: &str) -> int {
      let lines = split_lines(input);
      let first_line = split_spaces(lines[0]);
      string_to_int(first_line[0])
  }
  
  spec fn get_d(input: &str) -> int {
      let lines = split_lines(input);
      let first_line = split_spaces(lines[0]);
      string_to_int(first_line[1])
  }
  
  spec fn get_number_of_grasshoppers(input: &str) -> int {
      let lines = split_lines(input);
      string_to_int(lines[1])
  }
  
  spec fn get_grasshopper(input: &str, i: int) -> (int, int) {
      let lines = split_lines(input);
      let coords = split_spaces(lines[2 + i]);
      (string_to_int(coords[0]), string_to_int(coords[1]))
  }
  
  spec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {
      let (x, y) = grasshopper;
      x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d
  }

vc-helpers: |-

vc-spec: |-
  fn solve(input: &str) -> (result: Vec<String>)
      requires
          str_len(input) > 0,
          valid_input(input),
      ensures
          result.len() == get_number_of_grasshoppers(input),

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}