vc-description: |-
  Given n+1 pylons numbered 0 to n, where pylon 0 has height 0 and pylons 1 to n have heights h₁, h₂, ..., hₙ.
  A player starts at pylon 0 with 0 energy and wants to reach pylon n by jumping from pylon k to pylon k+1.
  Each jump from pylon k to k+1 changes energy by (hₖ - hₖ₊₁). Energy must remain non-negative at all times.
  The player can pay $1 to increase any pylon's height by 1. Find the minimum cost to make the journey possible.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(n: int, heights: Seq<int>) -> bool {
      n > 0 && heights.len() == n
  }
  
  spec fn max_in_seq(s: Seq<int>) -> int
      recommends s.len() > 0
      decreases s.len()
      via max_in_seq_decreases
  {
      if s.len() == 1 {
          s[0]
      } else {
          let tail = s.subrange(1, s.len() as int);
          let tail_max = max_in_seq(tail);
          if s[0] >= tail_max { s[0] } else { tail_max }
      }
  }

  #[via_fn]
  proof fn max_in_seq_decreases(s: Seq<int>) {
      assume(false);
  }
  
  spec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool
      recommends valid_input(n, heights)
  {
      result == max_in_seq(heights) &&
      forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&
      exists|i: int| 0 <= i < heights.len() && heights[i] == result
  }

vc-helpers: |-

vc-spec: |-
  fn solve(n: int, heights: Seq<int>) -> (result: int)
      requires valid_input(n, heights)
      ensures valid_result(n, heights, result)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-

  }

  fn main() {}