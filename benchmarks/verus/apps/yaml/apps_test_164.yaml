vc-description: |-
  Given a rectangular football field where Robo-Wallace is at position (x_b, y_b) with a ball of radius r,
  find a point x_w on the right wall (at y = y_w) such that kicking the ball there will cause it to bounce
  once and go through the goal. The goal is located at x = 0, between y-coordinates y_1 and y_2.
  The ball moves in straight lines and bounces elastically off walls. A goal is scored when the ball's
  center crosses the y-axis between y_1 and y_2. Output x_w if possible, otherwise -1.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {
      y1 < y2 < y_w &&
      y_b + r < y_w &&
      2 * r < y2 - y1 &&
      x_b > 0 && y_b > 0 && r > 0 &&
      2 * (y_w - r) - y1 - y_b - r != 0
  }
  
  spec fn compute_w(y_w: int, r: int) -> int {
      y_w - r
  }
  
  spec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {
      2 * (y_w - r) - y1 - y_b - r
  }
  
  spec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {
      2 * (y_w - r) - y2 - y_b
  }
  
  spec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {
      x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)
  }
  
  spec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {
      (new_y1 * new_y1 + x_b * x_b) * r * r
  }
  
  spec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool 
      recommends valid_input(y1, y2, y_w, x_b, y_b, r)
  {
      let w = compute_w(y_w, r);
      let new_y1 = compute_new_y1(y_w, r, y1, y_b);
      let new_y2 = compute_new_y2(y_w, r, y2, y_b);
      let left_side = compute_left_side(x_b, new_y1, new_y2);
      let right_side = compute_right_side(x_b, new_y1, r);
      left_side <= right_side
  }
  
  spec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> real
      recommends 
          valid_input(y1, y2, y_w, x_b, y_b, r),
          !is_impossible(y1, y2, y_w, x_b, y_b, r)
  {
      let w = compute_w(y_w, r);
      let new_y1 = compute_new_y1(y_w, r, y1, y_b);
      (x_b as real) * ((new_y1 + y_b - w) as real) / (new_y1 as real)
  }

vc-helpers: |-

vc-spec: |-
  fn solve(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> (result: real)
      requires valid_input(y1, y2, y_w, x_b, y_b, r)
      ensures is_impossible(y1, y2, y_w, x_b, y_b, r) ==> result == -1.0
      ensures !is_impossible(y1, y2, y_w, x_b, y_b, r) ==> result == compute_solution(y1, y2, y_w, x_b, y_b, r)

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}