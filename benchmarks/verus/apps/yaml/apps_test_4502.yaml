vc-description: |-
  Given an integer sequence a of length n, simulate n operations on an initially empty sequence b:
  Operation i: Append a[i] to the end of b, then reverse the entire sequence b
  Output the final sequence b after all n operations.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(n: int, a: Seq<int>) -> bool {
      n >= 1 && a.len() == n
  }
  
  spec fn simulate_operations(a: Seq<int>) -> Seq<int>
      recommends a.len() >= 1
      decreases a.len()
  {
      if a.len() == 1 {
          seq![a[0]]
      } else {
          let prev = simulate_operations(a.subrange(0, a.len() - 1));
          reverse_seq(prev.push(a[a.len() - 1]))
      }
  }
  
  spec fn compute_result(a: Seq<int>) -> Seq<int>
      recommends a.len() >= 1
  {
      let n = a.len();
      let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);
      let e = Seq::new(n / 2, |i: int| a[2*i + 1]);
      if n % 2 == 0 {
          reverse_seq(e).add(o)
      } else {
          reverse_seq(o).add(e)
      }
  }
  
  spec fn reverse_seq(s: Seq<int>) -> Seq<int> {
      if s.len() == 0 {
          seq![]
      } else {
          reverse_seq(s.subrange(1, s.len() as int)).push(s[0])
      }
  }

vc-helpers: |-

vc-spec: |-
  fn solve(n: int, a: Seq<int>) -> (result: Seq<int>)
      requires 
          valid_input(n, a)
      ensures 
          result.len() == n,
          result == compute_result(a)

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}