vc-description: |-
  Given an n×m matrix A containing only 0s and 1s, and matrix B initially all zeros.
  You can perform operations on B: choose integers x, y where 1 ≤ x < n and 1 ≤ y < m,
  then set B[x,y], B[x,y+1], B[x+1,y], and B[x+1,y+1] to 1.
  Determine if B can be made equal to A, and if so, provide a sequence of operations.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() as int - 1] == '\n' &&
    exists|lines: Seq<Seq<char>>| {
      &&& lines == split_lines(input)
      &&& lines.len() >= 3
      &&& valid_dimension_line(lines[0])
      &&& {
        let parsed = parse_dimensions(lines[0]);
        let n = parsed.0;
        let m = parsed.1;
        &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50
        &&& (forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m))
        &&& (forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==> 
             parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1)
      }
    }
  }
  
  spec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() as int - 1] == '\n' &&
    exists|lines: Seq<Seq<char>>| {
      &&& lines == split_lines(output)
      &&& lines.len() >= 1
      &&& valid_number(lines[0])
      &&& {
        let k = parse_number(lines[0]);
        &&& 0 <= k <= 2500
        &&& lines.len() == k + 1
        &&& {
          let parsed = parse_input(original_input);
          let n = parsed.0;
          let m = parsed.1;
          forall|i: int| 1 <= i <= k ==> valid_coordinate_pair(lines[i], n-1, m-1)
        }
      }
    }
  }
  
  spec fn valid_dimension_line(line: Seq<char>) -> bool { 
    line.len() > 0 
  }
  
  spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool { 
    line.len() > 0 && m > 0 
  }
  
  spec fn valid_number(s: Seq<char>) -> bool { 
    s.len() > 0 
  }
  
  spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool { 
    s.len() > 0 && max_x > 0 && max_y > 0 
  }
  
  spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> { 
    seq![s] 
  }
  
  spec fn parse_dimensions(line: Seq<char>) -> (int, int) { 
    (2, 2) 
  }
  
  spec fn parse_number(s: Seq<char>) -> int { 
    0 
  }
  
  spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) { 
    (2, 2, seq![seq![0, 0], seq![0, 0]]) 
  }
  
  spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> { 
    seq![] 
  }
  
  spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int { 
    0 
  }
  
  spec fn to_string(n: nat) -> Seq<char> { 
    seq!['0'] 
  }
  
  spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) {
    let b = seq![seq![0; m as nat]; n as nat];
    let ops = seq![];
    greedy_step(a, b, ops, 0, 0, n, m)
  }

  spec fn greedy_step(a: Seq<Seq<int>>, b: Seq<Seq<int>>, ops: Seq<(int, int)>, x: int, y: int, n: int, m: int) -> (Seq<Seq<int>>, Seq<(int, int)>) {
    (b, ops)
  }

  spec fn negative_one_sequence() -> Seq<char> {
    seq!['-', '1', '\n']
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
      stdin_input.len() > 0,
      valid_input_format(stdin_input),
    ensures
      result.len() > 0,
      result == negative_one_sequence() || valid_operation_sequence(result, stdin_input),
      result != negative_one_sequence() ==> {
        let parsed = parse_input(stdin_input);
        let n = parsed.0;
        let m = parsed.1;
        let a = parsed.2;
        let ops = parse_operations(result);
        let algorithm_result = apply_greedy_algorithm(n, m, a);
        let b = algorithm_result.0;
        let expected_ops = algorithm_result.1;
        b == a && ops == expected_ops
      },
      result == negative_one_sequence() ==> {
        let parsed = parse_input(stdin_input);
        let n = parsed.0;
        let m = parsed.1;
        let a = parsed.2;
        let algorithm_result = apply_greedy_algorithm(n, m, a);
        let b = algorithm_result.0;
        b != a
      },
      result == negative_one_sequence() || 
        exists|k: nat, lines: Seq<Seq<char>>| {
          &&& lines == split_lines(result)
          &&& lines.len() == k + 1
          &&& lines[0] == to_string(k) && k <= 2500
          &&& {
            let parsed = parse_input(stdin_input);
            let n = parsed.0;
            let m = parsed.1;
            forall|i: int| 1 <= i <= k ==> 
              exists|x: int, y: int| (1 <= x <= n-1 && 1 <= y <= m-1 && 
               lines[i] == to_string(x as nat) + seq![' '] + to_string(y as nat))
          }
        },

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}