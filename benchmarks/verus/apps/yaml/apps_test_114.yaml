vc-description: |-
  Given an n×m matrix A containing only 0s and 1s, and matrix B initially all zeros.
  You can perform operations on B: choose integers x, y where 1 ≤ x < n and 1 ≤ y < m,
  then set B[x,y], B[x,y+1], B[x+1,y], and B[x+1,y+1] to 1.
  Determine if B can be made equal to A, and if so, provide a sequence of operations.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input_format(input: &str) -> bool {
      input.len() > 0 && input.as_bytes()[input.len() - 1] == '\n' as u8 &&
      exists|lines: Seq<&str>|
          lines == split_lines(input) &&
          lines.len() >= 3 &&
          valid_dimension_line(lines[0]) &&
          {
              let parsed = parse_dimensions(lines[0]);
              let (n, m) = (parsed.0, parsed.1);
              lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50 &&
              forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m) &&
              forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==> 
                  parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1
          }
  }
  
  spec fn valid_operation_sequence(output: &str, original_input: &str) -> bool {
      output.len() > 0 && output.as_bytes()[output.len() - 1] == '\n' as u8 &&
      exists|lines: Seq<&str>|
          lines == split_lines(output) &&
          lines.len() >= 1 &&
          valid_number(lines[0]) &&
          {
              let k = parse_number(lines[0]);
              0 <= k <= 2500 &&
              lines.len() == k + 1 &&
              {
                  let parsed = parse_input(original_input);
                  let (n, m) = (parsed.0, parsed.1);
                  forall|i: int| 1 <= i <= k ==> valid_coordinate_pair(lines[i], n - 1, m - 1)
              }
          }
  }
  
  spec fn valid_dimension_line(line: &str) -> bool {
      line.len() > 0
  }
  
  spec fn valid_matrix_row(line: &str, m: int) -> bool {
      line.len() > 0 && m > 0
  }
  
  spec fn valid_number(s: &str) -> bool {
      s.len() > 0
  }
  
  spec fn valid_coordinate_pair(s: &str, max_x: int, max_y: int) -> bool {
      s.len() > 0 && max_x > 0 && max_y > 0
  }
  
  spec fn split_lines(s: &str) -> Seq<&str> {
      seq![s]
  }
  
  spec fn parse_dimensions(line: &str) -> (int, int) {
      (2, 2)
  }
  
  spec fn parse_number(s: &str) -> int {
      0
  }
  
  spec fn parse_input(input: &str) -> (int, int, Seq<Seq<int>>) {
      (2, 2, seq![seq![0, 0], seq![0, 0]])
  }
  
  spec fn parse_operations(output: &str) -> Seq<(int, int)> {
      seq![]
  }
  
  spec fn parse_matrix_element(line: &str, pos: int) -> int {
      0
  }
  
  spec fn to_string_fn(n: int) -> &'static str {
      "0"
  }
  
  spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>)
      recommends 2 <= n <= 50 && 2 <= m <= 50,
                a.len() == n && forall|i: int| 0 <= i < n ==> a[i].len() == m,
                forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> 
                    a[i][j] == 0 || a[i][j] == 1
  {
      let b = seq![seq![0; m as nat]; n as nat];
      let ops = seq![];
      greedy_step(a, b, ops, 0, 0, n, m)
  }

  spec fn greedy_step(a: Seq<Seq<int>>, b: Seq<Seq<int>>, ops: Seq<(int, int)>, 
                     x: int, y: int, n: int, m: int) -> (Seq<Seq<int>>, Seq<(int, int)>) {
      (b, ops)
  }

vc-helpers: |-

vc-spec: |-
  fn solve(stdin_input: &str) -> (result: String)
      requires
          stdin_input.len() > 0,
          valid_input_format(stdin_input),
      ensures
          result.len() > 0,
          result@ == "-1\n" || valid_operation_sequence(result.as_str(), stdin_input),
          result@ != "-1\n" ==> 
              {
                  let parsed = parse_input(stdin_input);
                  let (n, m, a) = (parsed.0, parsed.1, parsed.2);
                  let ops = parse_operations(result.as_str());
                  let algorithm_result = apply_greedy_algorithm(n, m, a);
                  let b = algorithm_result.0;
                  let expected_ops = algorithm_result.1;
                  b == a && ops == expected_ops
              },
          result@ == "-1\n" ==> 
              {
                  let parsed = parse_input(stdin_input);
                  let (n, m, a) = (parsed.0, parsed.1, parsed.2);
                  let algorithm_result = apply_greedy_algorithm(n, m, a);
                  let b = algorithm_result.0;
                  b != a
              },
          result@ == "-1\n" || 
              exists|k: nat, lines: Seq<&str>| 
                  lines == split_lines(result.as_str()) && 
                  lines.len() == k + 1 && 
                  lines[0] == to_string_fn(k as int) && k <= 2500 &&
                  {
                      let parsed = parse_input(stdin_input);
                      let (n, m) = (parsed.0, parsed.1);
                      forall|i: int| 1 <= i <= k ==> 
                          exists|x: int, y: int| 1 <= x <= n - 1 && 1 <= y <= m - 1
                  },

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}