vc-description: |-
  Given n packets of balloons, divide all packets between two people such that:
  1. Each person gets at least one packet
  2. All packets are distributed 
  3. The total number of balloons each person receives is different
  Find any valid distribution or return empty sequence if impossible.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {
  spec fn valid_input(n: int, packets: Seq<int>) -> bool {
      n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1
  }

  spec fn is_possible(n: int, packets: Seq<int>) -> bool
      recommends valid_input(n, packets)
  {
      n >= 2 && (n > 2 || packets[0] != packets[1])
  }

  spec fn sum_packets(packets: Seq<int>) -> int
      decreases packets.len()
  {
      if packets.len() == 0 {
          0
      } else {
          packets[0] + sum_packets(packets.subrange(1, packets.len() as int))
      }
  }

  spec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool
      recommends valid_input(n, packets)
  {
      if !is_possible(n, packets) {
          result.len() == 0
      } else {
          result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&
          exists|min_index: int| 0 <= min_index < packets.len() && 
          result[1] == min_index + 1 &&
          (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&
          (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])
      }
  }

vc-helpers: |

vc-spec: |-
  fn solve(n: int, packets: Seq<int>) -> (result: Seq<int>)
      requires valid_input(n, packets)
      ensures valid_solution(n, packets, result)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |2-

  }

  fn main() {}
