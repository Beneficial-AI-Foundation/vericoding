// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn spiral_order(row: int, col: int, n: int) -> int
    recommends 0 <= row < n && 0 <= col < n && n >= 1
    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1
{
    let layer = min(min(row, col), min(n-1-row, n-1-col));
    let layer_start = 4 * layer * (n - layer - 1) + layer;

    if row == layer {
        /* Top row of current layer */
        layer_start + (col - layer)
    } else if col == n - 1 - layer {
        /* Right column of current layer */
        layer_start + (n - 2 * layer - 1) + (row - layer)
    } else if row == n - 1 - layer {
        /* Bottom row of current layer */
        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)
    } else {
        /* Left column of current layer */
        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)
    }
}

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {
    matrix.len() == n &&
    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)
}
// </vc-preamble>

// <vc-helpers>
/* helper modified by LLM (iteration 5): Correct the lemma to reflect that spiral_order returns an int already by its spec so the +1 is sufficient, and the upper bound is n*n, not (n*n)-1 which was already accounted for. */
proof fn lemma_nth_value(i: int, j: int, n: int)
    requires
        0 <= i < n,
        0 <= j < n,
        n >= 1
    ensures
        1 <= (spiral_order(i, j, n) + 1) <= n * n
{
    // Assert the minimum value of spiral_order(i, j, n)
    let layer = min(min(i, j), min(n - 1 - i, n - 1 - j));
    assert(layer >= 0);
    let layer_start = 4 * layer * (n - layer - 1) + layer;
    assert(layer_start >= 0);

    if i == layer {
        assert(j - layer >= 0);
    } else if j == n - 1 - layer {
        assert(n - 2 * layer - 1 >= 0);
        assert(i - layer >= 0);
    } else if i == n - 1 - layer {
        assert(n - 2 * layer - 1 >= 0);
        assert(n - 1 - layer - j >= 0);
    } else {
        assert(n - 2 * layer - 1 >= 0);
        assert(n - 1 - layer - i >= 0);
    }
    assert(spiral_order(i, j, n) >= 0);

    // The values generated by spiral_order range from 0 to n*n - 1.
    // Since the problem asks for values from 1 to n*n, we add 1 to the result of spiral_order.
    // Therefore, the minimum value is 0 + 1 = 1.
    // The maximum value is (n*n - 1) + 1 = n*n.
    assert(n * n >= 1);
    assert(spiral_order(i, j, n) + 1 >= 1);
    assert(spiral_order(i, j, n) + 1 <= n * n);
}
// </vc-helpers>

// <vc-spec>
fn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)
    requires 
        valid_input(n as int)
    ensures 
        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&
        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&
        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)
// </vc-spec>
// <vc-code>
/* code modified by LLM (iteration 5): The Verus type 'nat' was used in the previous iteration only for intermediate calculations and then cast back to int. This produced compilation errors by using 'nat'/'int' in non-ghost contexts, as specified in the errors. This iteration removes the usage of 'nat' where not needed, allowing 'i' and 'j' to remain `usize` and `n_int` to remain `int` for the `spiral_order` function call. Assertions in while loop invariants referencing `n_int` changed to only `n` where `n` is usable and in scope. `n_int` remains if `n_int` is declared as an `int` to preserve the functionality as in previous iterations. `matrix` is also properly initialized now. */
{
    let n_int: int = n as int;
    let mut matrix: Vec<Vec<i8>> = Vec::new();

    let mut i: usize = 0;
    while (i as int) < n_int
        invariant
            0 <= i as int,
            i as int <= n_int,
            matrix.len() == i,
            forall|k: int| 0 <= k < i ==> matrix@[k].len() == n as usize,
            forall|row_idx: int, col_idx: int| 0 <= row_idx < i && 0 <= col_idx < n as int ==> (matrix@[row_idx][col_idx] as int) == spiral_order(row_idx, col_idx, n_int) + 1
    {
        let mut row_vec: Vec<i8> = Vec::new();
        let mut j: usize = 0;
        while (j as int) < n_int
            invariant
                0 <= i as int,
                (i as int) < n_int,
                0 <= j as int,
                j as int <= n_int,
                row_vec.len() == j,
                forall|col_idx: int| 0 <= col_idx < j ==> (row_vec@[col_idx] as int) == spiral_order(i as int, col_idx, n_int) + 1,
                matrix.len() == i,
                forall|k: int| 0 <= k < i ==> matrix@[k].len() == n as usize,
                forall|row_idx: int, col_idx: int| 0 <= row_idx < i && 0 <= col_idx < n as int ==> (matrix@[row_idx][col_idx] as int) == spiral_order(row_idx, col_idx, n_int) + 1
        {
            proof {
                lemma_nth_value(i as int, j as int, n_int);
            }
            let val = (spiral_order(i as int, j as int, n_int) + 1) as i8;
            row_vec.push(val);
            j = j + 1;
        }
        matrix.push(row_vec);
        i = i + 1;
    }
    matrix
}
// </vc-code>


}

fn main() {}