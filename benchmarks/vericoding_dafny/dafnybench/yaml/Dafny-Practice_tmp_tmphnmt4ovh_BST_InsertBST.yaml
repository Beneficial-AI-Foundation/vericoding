vc-preamble: |-
  datatype Tree = Empty | Node(int,Tree,Tree)

  function NumbersInTree(t: Tree): set<int>
  {
      NumbersInSequence(Inorder(t))
  }

  function NumbersInSequence(q: seq<int>): set<int>
  {
      set x | x in q
  }

  predicate BST(t: Tree)
  {
      Ascending(Inorder(t))
  }

  function Inorder(t: Tree): seq<int>
  {
      match t {
          case Empty => []
          case Node(n',nt1,nt2) => Inorder(nt1)+[n']+Inorder(nt2)
      }
  }

  predicate Ascending(q: seq<int>)
  {
      forall i,j :: 0 <= i < j < |q| ==> q[i] < q[j]
  }

  predicate NoDuplicates(q: seq<int>) { forall i,j :: 0 <= i < j < |q| ==> q[i] != q[j] }

  /*
      Goal: Implement correctly, clearly. No need to document the proof obligations.
  */

  /*
      Goal: Implement correctly, efficiently, clearly, documenting the proof obligations
      as we've learned, with assertions and a lemma for each proof goal
  */

vc-helpers: |-

vc-spec: |-
  method InsertBST(t0: Tree, x: int) returns (t: Tree)
      requires BST(t0) && x !in NumbersInTree(t0)
      ensures BST(t) && NumbersInTree(t) == NumbersInTree(t0)+{x}

vc-code: |-
  {
    assume false;
  }

vc-postamble: |-
  lemma   LemmaBinarySearchSubtree(n: int, left: Tree, right: Tree)
      requires BST(Node(n, left, right))
      ensures BST(left) && BST(right)
  {
      assert Ascending(Inorder(Node(n, left, right)));
      var qleft, qright := Inorder(left), Inorder(right);
      var q := qleft+[n]+qright;
      assert q == Inorder(Node(n, left, right));
      assert Ascending(qleft+[n]+qright);
      assert Ascending(qleft) by { LemmaAscendingSubsequence(q, qleft, 0); }
      assert Ascending(qright) by { LemmaAscendingSubsequence(q, qright, |qleft|+1); }
  }

  lemma LemmaAscendingSubsequence(q1: seq<int>, q2: seq<int>, i: nat)
      requires i <= |q1|-|q2| && q2 == q1[i..i+|q2|]
      requires Ascending(q1)
      ensures Ascending(q2)
  {}

  lemma lemma_all_small(q:seq<int>,i:int)
      requires forall k:: k in NumbersInSequence(q) ==> k < i
      requires forall k:: 0 <= k < |q| ==> q[k] in NumbersInSequence(q)
      ensures forall j::0<=j < |q| ==> q[j] < i
  {}

  lemma lemma_all_big(q:seq<int>,i:int)
      requires forall k:: k in NumbersInSequence(q) ==> k > i
      requires forall k:: 0 <= k < |q| ==> q[k] in NumbersInSequence(q)
      ensures forall j::0<=j < |q| ==> q[j] > i
  {}

