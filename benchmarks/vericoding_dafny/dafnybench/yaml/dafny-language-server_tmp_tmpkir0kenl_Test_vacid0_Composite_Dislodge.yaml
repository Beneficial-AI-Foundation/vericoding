vc-preamble: |-
  // RUN: %dafny /compile:0 "%s" > "%t"
  // RUN: %diff "%s.expect" "%t"

  class Composite {
    var left: Composite?
    var right: Composite?
    var parent: Composite?
    var val: int
    var sum: int

    function Valid(S: set<Composite>): bool
      reads this, parent, left, right
    {
      this in S &&
      (parent != null ==> parent in S && (parent.left == this || parent.right == this)) &&
      (left != null ==> left in S && left.parent == this && left != right) &&
      (right != null ==> right in S && right.parent == this && left != right) &&
      sum == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)
    }

    function Acyclic(S: set<Composite>): bool
      reads S
    {
      this in S &&
      (parent != null ==> parent.Acyclic(S - {this}))
    }
vc-helpers: ''
vc-spec: "method Dislodge(ghost S: set<Composite>) \n    requires this in S && Acyclic(S)\n    requires forall c :: c in S ==> c.Valid(S)\n    modifies S\n    ensures forall c :: c in S ==> c.Valid(S)\n    ensures forall c :: c in S ==> c.val == old(c.val)\n    ensures forall c :: c in S && c != this ==> c.parent == old(c.parent)\n    ensures parent == null\n    ensures forall c :: c in S ==> c.left == old(c.left) || (old(c.left) == this && c.left == null)\n    ensures forall c :: c in S ==> c.right == old(c.right) || (old(c.right) == this && c.right == null)\n    ensures Acyclic({this})"
vc-code: |-
  {
    assume false;
  }
vc-postamble: |-
  /*private*/ method Adjust(delta: int, ghost U: set<Composite>, ghost S: set<Composite>)
      requires U <= S && Acyclic(U)
      // everything else is valid:
      requires forall c :: c in S && c != this ==> c.Valid(S)
      // this is almost valid:
      requires parent != null ==> parent in S && (parent.left == this || parent.right == this)
      requires left != null ==> left in S && left.parent == this && left != right
      requires right != null ==> right in S && right.parent == this && left != right
      // ... except that sum needs to be adjusted by delta:
      requires sum + delta == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)
      // modifies sum fields in U:
      modifies U`sum
      // everything is valid, including this:
      ensures forall c :: c in S ==> c.Valid(S)
  {
    assume{:axiom} false;
  }
  }
