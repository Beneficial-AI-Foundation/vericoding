vc-preamble: "predicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k:\
  \ nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n{\n    // Check that both strings are larger than k \n    if (k > |str1| || k > |str2| ){\n        return false;\n    }\n    // Initialize variables\n    var i := 0;\n    var temp := false;\n\n    // Don't want to exceed the bounds of str1 when checking for the element that is k entries away\n    while i <= |str1|-k\n    // Invariant to stay within bounds\n    invariant 0 <= i <= (|str1|-k) + 1\n    // Invariant to show that when temp is true, it is a substring\n    invariant temp ==> 0 <= i <= (|str1| - k) && isSubstringPred(str1[i..i+k], str2)\n    // Invariant to show that when temp is false, it is not a substring\n    invariant !temp ==> (forall m,n :: (0 <= m < i && n == m+k) ==> isNotSubstringPred(str1[m..n], str2))\n    // Telling dafny that\
  \ i is that value that is increasing\n    decreases |str1| - k - i\n    {\n        assume false;\n\n        // Get an index from the array position were are at to the array position that is k away and check the substring\n        temp := isSubstring(str1[i..(i + k)], str2);\n        if  temp == true \n        {\n            return true;\n        }\n        i := i + 1;\n    }\n    return false;\n}"
vc-helpers: ''
vc-spec: |-
  method maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)
      requires (|str1| <= |str2|)
      ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))
      ensures haveCommonKSubstringPred(len,str1,str2)
vc-code: |-
  {
    assume false;
  }
vc-postamble: ''
