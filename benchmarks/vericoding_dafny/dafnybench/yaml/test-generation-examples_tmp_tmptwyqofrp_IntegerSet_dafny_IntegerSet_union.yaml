vc-preamble: "module IntegerSet {\n\n    class Set {\n\n        var elements: seq<int>;\n\n        constructor Set0() \n        ensures this.elements == []\n        ensures |this.elements| == 0\n        {\n            this.elements := [];\n        }\n\n        constructor Set(elements: seq<int>)\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures this.elements == elements\n        ensures forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements|  && j != i:: this.elements[i] != this.elements[j]\n        {\n            this.elements := elements;\n        }\n\n\n\n\n\n        //for computing the length of the intersection of 2 sets\n        function intersect_length(s1 : seq<int>, s2 : seq<int>, count : int, start : int, stop : int) : int \n        requires 0 <= start <= stop\n        requires stop <= |s1|\n        decreases stop - start\n        {\n            if start == stop then count else (if s1[start]\
  \ in s2 then intersect_length(s1, s2, count + 1, start + 1, stop) else intersect_length(s1, s2, count, start + 1, stop))\n        }\n\n        //for computing the length of the union of 2 sets\n        //pass in the length of s2 as the initial count\n        function union_length(s1 : seq<int>, s2 : seq<int>, count : int, i : int, stop : int) : int \n        requires 0 <= i <= stop\n        requires stop <= |s1|\n        decreases stop - i\n        {           \n            if i == stop then count else (if s1[i] !in s2 then union_length(s1, s2, count + 1, i + 1, stop) else union_length(s1, s2, count, i + 1, stop))\n        }"
vc-helpers: ''
vc-spec: |-
  method union(s : Set) returns (union : Set)
          requires forall i, j | 0 <= i < |s.elements| && 0 <= j < |s.elements| && i != j :: s.elements[i] != s.elements[j]
          requires forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements| && i != j :: this.elements[i] != this.elements[j]
          ensures forall i : int :: i in s.elements || i in this.elements <==> i in union.elements
          ensures forall i : int :: i !in s.elements && i !in this.elements <==> i !in union.elements
          ensures forall j, k | 0 <= j < |union.elements| && 0 <= k < |union.elements| && j != k :: union.elements[j] != union.elements[k]
          ensures fresh(union)
vc-code: |-
  {
    assume false;
  }
vc-postamble: |-
  }
  }
