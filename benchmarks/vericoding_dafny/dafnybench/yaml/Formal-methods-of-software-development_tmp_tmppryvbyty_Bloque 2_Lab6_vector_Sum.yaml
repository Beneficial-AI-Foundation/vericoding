vc-preamble: "/*predicate palindrome<T(==)> (s:seq<T>)\n{\n    forall i:: 0<=i<|s| ==> s[i] == s[|s|-i-1]\n}\n*/\n// SUM OF A SEQUENCE OF INTEGERS\nfunction sum(v: seq<int>): int \ndecreases v\n{\n    if v==[] then 0\n    else if |v|==1 then v[0]\n    else v[0]+sum(v[1..])\n}"
vc-helpers: ''
vc-spec: |-
  method vector_Sum(v:seq<int>) returns (x:int)
  ensures x == sum(v)
vc-code: |-
  {
    assume false;
  }
vc-postamble: "// Structural Induction on Sequences\n\n// MAXIMUM OF A SEQUENCE\n\n// TODO: Hacer\n// Derivar formalmente un calculo incremental de j*j*j\n\n\n// REVERSE OF A SEQUENCE\nfunction reverse<T> (s:seq<T>):seq<T> \n{\n    if s==[] then []\n    else reverse(s[1..])+[s[0]]\n}\n\nfunction seq2set<T> (s:seq<T>): set<T>\n{\n    if s==[] then {}\n    else {s[0]}+seq2set(s[1..])\n}\n\n\n// REVERSE IS ITS OWN INVERSE\n\n// SCALAR PRODUCT OF TWO VECTORS OF INTEGER\nfunction scalar_product (v1:seq<int>, v2:seq<int>):int\nrequires |v1| == |v2|\n{\n    if v1 == [] then 0 else v1[0]*v2[0] + scalar_product(v1[1..],v2[1..])\n}\n\n// MULTISETS\n\nmethod multiplicity_examples<T> ()\n{\n  assume{:axiom} false;\n}\n\n// REVERSE HAS THE SAME MULTISET "
